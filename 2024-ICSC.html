<!DOCTYPE html>
<html>

<head>
    <meta http-equiv='cache-control' content='no-cache'>
    <meta http-equiv='expires' content='0'>
    <meta http-equiv='pragma' content='no-cache'>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="dat.gui.js"></script>
    <script src="jquery.js"></script>
    <script src="sprintf.js"></script>
    <script src="three.js"></script>
    <script src="ace.js"></script>
    <script src="tinycolor.js"></script>
    <script src="CsoundAudioNode.js"></script>
    <script src="csound_loader.js"></script>
    <script src="CsoundAC.js"></script>
    <script src='Silencio.js'></script>
    <script src='ChordSpace.js'></script>
    <script src="TrackballControls.js"></script>
    <script src="strudel_embed.js"></script>
    <link rel="stylesheet" href="w3.css">
    <link rel="stylesheet" href="cloud-5.css">
    <script src='cloud-5.js'></script>
</head>

<body class="w3-medium w3-text-sand cloud5-body">
    <textarea id="csd" style="display:none;">
        <CsoundSynthesizer>
          <CsOptions>
          -d -m162 -odac
          </CsOptions>
          <CsInstruments>
          sr = 48000
          ksmps = 128
          nchnls = 2
          0dbfs = 3
          
          ; Ensure the same random stream for each rendering.
          ; rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.
          
          ;seed  81814
          ;seed  818145
          seed  88818145
          
          connect "Blower", "outleft", "ReverbSC", "inleft"
          connect "Blower", "outright", "ReverbSC", "inright"
          connect "Bower", "outleft", "ReverbSC", "inleft"
          connect "Bower", "outright", "ReverbSC", "inright"
          connect "Buzzer", "outleft", "ReverbSC", "inleft"
          connect "Buzzer", "outright", "ReverbSC", "inright"
          connect "Droner", "outleft", "ReverbSC", "inleft"
          connect "Droner", "outright", "ReverbSC", "inright"
          connect "FMWaterBell", "outleft", "ReverbSC", "inleft"
          connect "FMWaterBell", "outright", "ReverbSC", "inright"
          ; Phaser is the one that actually "buzzes" in this piece.
          connect "Phaser", "outleft", "ReverbSC", "inleft"
          connect "Phaser", "outright", "ReverbSC", "inright"
          connect "Sweeper", "outleft", "ReverbSC", "inleft"
          connect "Sweeper", "outright", "ReverbSC", "inright"
          connect "Shiner", "outleft", "ReverbSC", "inleft"
          connect "Shiner", "outright", "ReverbSC", "inright"
          connect "ZakianFlute", "outleft", "ReverbSC", "inleft"
          connect "ZakianFlute", "outright", "ReverbSC", "inright"
          connect "FilteredSines", "outleft", "ReverbSC", "inleft"
          connect "FilteredSines", "outright", "ReverbSC", "inright"
          connect "Guitar", "outleft", "ReverbSC", "inleft"
          connect "Guitar", "outleft", "ReverbSC", "inleft"
          connect "Harpsichord", "outleft", "ReverbSC", "inleft"
          connect "Harpsichord", "outright", "ReverbSC", "inright"
          connect "Kung2", "outleft", "ReverbSC", "inleft"
          connect "Kung2", "outright", "ReverbSC", "inright"
          connect "Kung4", "outleft", "ReverbSC", "inleft"
          connect "Kung4", "outright", "ReverbSC", "inright"
          connect "Plucked", "outleft", "ReverbSC", "inleft"
          connect "Plucked", "outright", "ReverbSC", "inright"
          connect "SeidelHarmOsc", "outleft", "ReverbSC", "inleft"
          connect "SeidelHarmOsc", "outright", "ReverbSC", "inright"
          connect "TubularBell", "outleft", "ReverbSC", "inleft"
          connect "TubularBell", "outright", "ReverbSC", "inright"
          connect "YiString", "outleft", "ReverbSC", "inleft"
          connect "YiString", "outright", "ReverbSC", "inright"
          connect "VcvOut", "outleft", "ReverbSC", "inleft"
          connect "VcvOut", "outright", "ReverbSC", "inright"
          connect "Xing", "outleft", "ReverbSC", "inleft"
          connect "Xing", "outright", "ReverbSC", "inright"
        
          connect "ReverbSC", "outleft", "MasterOutput", "inleft"
          connect "ReverbSC", "outright", "MasterOutput", "inright"
          
          alwayson "ReverbSC"
          alwayson "MasterOutputOff"
          alwayson "MasterOutput"
          
          gk_Duration_factor init 4.5
          
          prealloc 1, 50
          prealloc 2, 50
          prealloc 3, 50
          prealloc 4, 50
          prealloc 5, 50
          prealloc 6, 50
          prealloc 7, 50
          prealloc 8, 20
          prealloc 9, 20
        
          //////////////////////////////////////////////
          // Original by Steven Yi.
          // Adapted by Anonymous.
          //////////////////////////////////////////////
          gk_FMWaterBell_level chnexport "gk_FMWaterBell_level", 3 ; 0
          gi_FMWaterBell_attack chnexport "gi_FMWaterBell_attack", 3 ; 0.002
          gi_FMWaterBell_release chnexport "gi_FMWaterBell_release", 3 ; 0.01
          gi_FMWaterBell_sustain chnexport "gi_FMWaterBell_sustain", 3 ; 20
          gi_FMWaterBell_sustain_level chnexport "gi_FMWaterBell_sustain_level", 3 ; .1
          gk_FMWaterBell_index chnexport "gk_FMWaterBell_index", 3 ; .5
          gk_FMWaterBell_crossfade chnexport "gk_FMWaterBell_crossfade", 3 ; .5
          gk_FMWaterBell_vibrato_depth chnexport "gk_FMWaterBell_vibrato_depth", 3 ; 0.05
          gk_FMWaterBell_vibrato_rate chnexport "gk_FMWaterBell_vibrato_rate", 3 ; 6
          gk_FMWaterBell_midi_dynamic_range chnexport "gk_FMWaterBell_midi_dynamic_range", 3 ; 20
          gk_FMWaterBell_level init 0
          gi_FMWaterBell_attack init 0.002
          gi_FMWaterBell_release init 0.01
          gi_FMWaterBell_sustain init 20
          gi_FMWaterBell_sustain_level init .1
          gk_FMWaterBell_index init .5
          gk_FMWaterBell_crossfade init .5
          gk_FMWaterBell_vibrato_depth init 0.05
          gk_FMWaterBell_vibrato_rate init 6
          gk_FMWaterBell_midi_dynamic_range init 20
          gk_FMWaterBell_space_left_to_right chnexport "gk_FMWaterBell_space_left_to_right", 3
          gk_FMWaterBell_space_left_to_right init .5
          gi_FMWaterBell_cosine ftgen 0, 0, 65537, 11, 1
          instr FMWaterBell
          i_instrument = p1
          i_time = p2
          i_duration = p3
          ; One of the envelopes in this instrument should be releasing, and use this:
          i_sustain = 1000
          xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
          i_midi_key = p4
          i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
          i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
          k_space_front_to_back = p6
          if p7 == 0 then
          k_space_left_to_right = gk_FMWaterBell_space_left_to_right
          else
          k_space_left_to_right = p7
          endif
          k_space_bottom_to_top = p8
          i_phase = p9
          i_frequency = cpsmidinn(i_midi_key)
          ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
          i_level_correction = 80
          i_normalization = ampdb(-i_level_correction) / 2
          i_amplitude = ampdb(i_midi_velocity) * i_normalization * 1.6
          k_gain = ampdb(gk_FMWaterBell_level)
          i_releasing_attack = 3 / min(i_frequency, 256)
          i_releasing_release = .01
          a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gk_FMWaterBell_crossfade, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine ;, gi_FMWaterBell_sustain
          a_envelope transeg 0, gi_FMWaterBell_attack, 6,  1, gi_FMWaterBell_sustain, -6,  0
          a_declicking cossegr 0, i_releasing_attack, 1, gi_FMWaterBell_sustain - 1, 1, i_releasing_release, 0
          ;;;a_signal = a_signal * i_amplitude * a_envelope * a_declicking * k_gain
          a_signal = a_signal * i_amplitude * a_envelope * a_declicking * k_gain
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          ;printks "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
          endin
          
          gk_Phaser_attack chnexport "gk_Phaser_attack", 3 ;  .125
          gk_Phaser_release chnexport "gk_Phaser_release", 3 ;  .125
          gk_Phaser_ratio1 chnexport "gk_Phaser_ratio1", 3 ;  1
          gk_Phaser_ratio2 chnexport "gk_Phaser_ratio2", 3 ;  1/5
          gk_Phaser_index1 chnexport "gk_Phaser_index1", 3 ;  1.01
          gk_Phaser_index2 chnexport "gk_Phaser_index2", 3 ;  .103
          gk_Phaser_level chnexport "gk_Phaser_level", 3 ;  0.5
          gk_Phaser_midi_dynamic_range chnexport "gk_Phaser_midi_dynamic_range", 3 ;  20
          gk_Phaser_attack init .125
          gk_Phaser_release init .125
          gk_Phaser_ratio1 init 1
          gk_Phaser_ratio2 init 1/5
          gk_Phaser_index1 init 1.01
          gk_Phaser_index2 init .103
          gk_Phaser_level init 0.5
          gk_Phaser_midi_dynamic_range init 20
          gi_Phaser_sine ftgen 0,0,65537,10,1
          instr Phaser
          i_instrument = p1
          i_time = p2
          i_duration = p3
          i_midi_key = p4
          i_midi_dynamic_range = i(gk_Phaser_midi_dynamic_range)
          i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
          k_space_front_to_back = p6
          k_space_left_to_right = p7
          k_space_bottom_to_top = p8
          i_phase = p9
          i_frequency = cpsmidinn(i_midi_key)
          ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
          i_level_correction = 81
          i_normalization = ampdb(-i_level_correction) / 2
          i_amplitude = ampdb(i_midi_velocity) * i_normalization
          k_gain = ampdb(gk_Phaser_level)
          i_attack = i(gk_Phaser_attack)
          i_release = i(gk_Phaser_release)
          i_sustain = 1000
          xtratim i_attack + i_release
          a_envelope transegr 0.0, i_attack / 2.0, 1.5, i_amplitude / 2.0, i_attack / 2.0, -1.5, i_amplitude, i_sustain, 0.0, i_amplitude, i_release / 2.0, 1.5, i_amplitude / 2.0, i_release / 2.0, -1.5, 0
          a1,a2 crosspm gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, i_frequency, gi_Phaser_sine, gi_Phaser_sine
          a_signal = (a1 + a2) * k_gain * a_envelope
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          ;printks "Phaser         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(aleft)), dbamp(rms(aright))
          endin
          
          gk_Droner_partial1 chnexport "gk_Droner_partial1", 3
          gk_Droner_partial2 chnexport "gk_Droner_partial2", 3
          gk_Droner_partial3 chnexport "gk_Droner_partial3", 3
          gk_Droner_partial4 chnexport "gk_Droner_partial4", 3
          gk_Droner_partial5 chnexport "gk_Droner_partial5", 3
          gk_Droner_partial6 chnexport "gk_Droner_partial6", 3
          gk_Droner_partial7 chnexport "gk_Droner_partial7", 3
          gk_Droner_partial8 chnexport "gk_Droner_partial8", 3
          gk_Droner_partial9 chnexport "gk_Droner_partial9", 3
          gk_Droner_partial10 chnexport "gk_Droner_partial10", 3
          gk_Droner_level chnexport "gk_Droner_level", 3
          gi_Droner_waveform chnexport "gi_Droner_waveform", 3
          gk_Droner_partial1 init .5
          gk_Droner_partial2 init .05
          gk_Droner_partial3 init .1
          gk_Droner_partial4 init .2
          gk_Droner_partial5 init .1
          gk_Droner_partial6 init 0
          gk_Droner_partial7 init 0
          gk_Droner_partial8 init 0
          gk_Droner_partial9 init 0
          gk_Droner_partial10 init 0
          gk_Droner_level init 0
          gi_Droner_waveform init 0
          gk_Droner_space_left_to_right chnexport "gk_Droner_space_left_to_right", 3
          gk_Droner_space_left_to_right init .5
          gi_Droner_sine ftgen 0, 0, 65537, 10, 1, 0, .02
          instr Droner
          i_instrument = p1
          i_time = p2
          ; Make indefinite notes last no longer than the physical decay.
          i_physical_decay = 200000
          if p3 == -1 then
          i_duration = i_physical_decay
          else
          i_duration = p3
          endif
          i_midi_key = p4
          i_midi_velocity = p5
          k_space_front_to_back = p6
          if p7 ==0 then
          k_space_left_to_right = gk_Droner_space_left_to_right
          else
          k_space_left_to_right = p7
          endif
          k_space_bottom_to_top = p8
          i_phase = p9
          i_frequency = cpsmidinn(i_midi_key)
          ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
          i_overall_amps = 19
          i_normalization = ampdb(-i_overall_amps) / 2
          i_amplitude = ampdb(i_midi_velocity) * i_normalization
          k_gain = ampdb(gk_Droner_level)
          k1 = gk_Droner_partial1
          k2 = gk_Droner_partial2
          k3 = gk_Droner_partial3
          k4 = gk_Droner_partial4
          k5 = gk_Droner_partial5
          k6 = gk_Droner_partial6
          k7 = gk_Droner_partial7
          k8 = gk_Droner_partial8
          k9 = gk_Droner_partial9
          k10 = gk_Droner_partial10
          iwaveform = gi_Droner_waveform
          iattack = .5
          idecay = .5
          isustain = p3
          aenvelope transegr 0.0, iattack / 2.0, 1.5, 1 / 2.0, iattack / 2.0, -1.5, 1, isustain, 0.0, 1, idecay / 2.0, 1.5, 1 / 2.0, idecay / 2.0, -1.5, 0
          ihertz = cpsmidinn(i_midi_key)
          if iwaveform == 0 goto i_waveform_0
          if iwaveform == 1 goto i_waveform_1
          if iwaveform == 2 goto i_waveform_2
          i_waveform_0:
          asignal poscil3 1, ihertz, gi_Droner_sine
          goto i_waveform_endif
          i_waveform_1:
          asignal vco2 1, ihertz, 8 ; integrated saw
          goto i_waveform_endif
          i_waveform_2:
          asignal vco2 1, ihertz, 12 ; triangle
          i_waveform_endif:
          a_signal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
          ;adeclicking linsegr 0, .004, 1, p3 - .014, 1, .1, 0
          ;a_signal = asignal * adeclicking
          ;
          ; The de-clicking envelope must have attack and release segments that damp 
          ; artifacts in the signal. The duration of these segments depends on 
          ; the behavior of the instrument, and may vary as a function of frequency.
          i_declick_attack = .005
          i_declick_release = .01
          ; The end of the note must be extended _past_ the end of the release segment.
          xtratim 1
          a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
          ; The envelope of the instrument is the product of the physical envelope times 
          ; the declicking envelope. 
          a_envelope = aenvelope * a_declicking_envelope
          ; That envelope is then low-pass filtered to remove most discontinuities.
          a_filtered_envelope tonex a_envelope, 40, 4
          a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          endin
            
          gk_Sweeper_midi_dynamic_range chnexport "gk_Sweeper_midi_dynamic_range", 3 ;  127
          gk_Sweeper_attack chnexport "gk_Sweeper_attack", 3 ;  .125
          gk_Sweeper_release chnexport "gk_Sweeper_release", 3 ;  .25
          gk_Sweeper_britel chnexport "gk_Sweeper_britel", 3 ;  0.1
          gk_Sweeper_briteh chnexport "gk_Sweeper_briteh", 3 ;  2.9
          gk_Sweeper_britels chnexport "gk_Sweeper_britels", 3 ;  2
          gk_Sweeper_britehs chnexport "gk_Sweeper_britehs", 3 ;  1
          gk_Sweeper_level chnexport "gk_Sweeper_level", 3 ;  0
          gk_Sweeper_midi_dynamic_range init 20
          gk_Sweeper_attack init .125
          gk_Sweeper_release init .25
          gk_Sweeper_britel init .01
          gk_Sweeper_briteh init 5
          gk_Sweeper_britels init .5
          gk_Sweeper_britehs init 1.75
          gk_Sweeper_level init 0
          gk_Sweeper_space_left_to_right chnexport "gk_Sweeper_space_left_to_right", 3
          gk_Sweeper_space_left_to_right init .5
          gi_Sweeper_sine ftgen 0, 0, 65537, 10, 1
          gi_Sweeper_octfn ftgen 0, 0, 65537, -19, 1, 0.5, 270, 0.5
          instr Sweeper
          //////////////////////////////////////////////
          // Original by Iain McCurdy.
          // Adapted by Anonymous.
          //////////////////////////////////////////////
          i_instrument = p1
          i_time = p2
          i_duration = p3
          i_midi_key = p4
          i_midi_dynamic_range = i(gk_Sweeper_midi_dynamic_range)
          i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
          k_space_front_to_back = p6
          if p7 ==0 then
          k_space_left_to_right = gk_Sweeper_space_left_to_right
          else
          k_space_left_to_right = p7
          endif
          k_space_bottom_to_top = p8
          i_phase = p9
          i_frequency = cpsmidinn(i_midi_key)
          ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
          i_level_correction = 34.2
          i_normalization = ampdb(-i_level_correction) / 2
          i_amplitude = ampdb(i_midi_velocity) * i_normalization
          k_gain = ampdb(gk_Sweeper_level)
          iattack = i(gk_Sweeper_attack)
          irelease = i(gk_Sweeper_release)
          isustain = p3
          kenvelope transegr 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, irelease / 2.0, 1.5, i_amplitude / 2.0, irelease / 2.0, -1.5, 0
          ihertz = i_frequency
          icps = ihertz
          kamp expseg 0.001,0.02,0.2,p3-0.01,0.001
          ktonemoddep jspline 0.01,0.05,0.2
          ktonemodrte jspline 6,0.1,0.2
          ktone poscil3 ktonemoddep, ktonemodrte, gi_Sweeper_sine
          ; kres rspline krangeMin, krangeMax, kcpsMin, kcpsMax
          kbrite rspline gk_Sweeper_britel, gk_Sweeper_briteh, gk_Sweeper_britels, gk_Sweeper_britehs
          ibasfreq init icps
          ioctcnt init 3
          iphs init 0
          a1 hsboscil kenvelope, ktone, kbrite, ibasfreq, gi_Sweeper_sine, gi_Sweeper_octfn, ioctcnt, iphs
          amod poscil3 0.25, ibasfreq*(1/3), gi_Sweeper_sine
          arm = a1*amod
          kmix expseg 0.001, 0.01, rnd(1), rnd(3)+0.3, 0.001
          kmix=.25
          a1 ntrpol a1, arm, kmix
          kpanrte jspline 5, 0.05, 0.1
          kpandep jspline 0.9, 0.2, 0.4
          kpan poscil3 kpandep, kpanrte, gi_Sweeper_sine
          ;a1,a2 pan2 a1, kpan
          a1,a2 pan2 a1, k_space_left_to_right
          aleft delay a1, rnd(0.1)
          aright delay a2, rnd(0.11)
          a_signal = (aleft + aright)
          ; As with most software instruments that are modeled on an impulse exciting a 
          ; resonator, there should be two envelopes. The "physical" envelope must have a 
          ; fixed decay ending at zero.
          i_declick_minimum = .003
          i_attack = .001 / i_frequency + i_declick_minimum
          i_declick_attack = i_attack
          i_declick_release = i_declick_minimum * 2
          ; The end of the note must be extended _past_ the end of the release segment.
          xtratim 1
          a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
          ; The envelope of the instrument is the product of the physical envelope times 
          ; the declicking envelope. 
          a_envelope = a_declicking_envelope
          ; That envelope is then low-pass filtered to remove most discontinuities.
          a_filtered_envelope tonex a_envelope, 40, 4
          a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          outs a_out_left, a_out_right
          endin
            
          gk_Buzzer_attack chnexport "gk_Buzzer_attack", 3
          gk_Buzzer_release chnexport "gk_Buzzer_release", 3
          gk_Buzzer_harmonics chnexport "gk_Buzzer_harmonics", 3
          gk_Buzzer_level chnexport "gk_Buzzer_level", 3
          gk_Buzzer_midi_dynamic_range chnexport "gk_Buzzer_midi_dynamic_range", 3
          gk_Buzzer_attack init .125
          gk_Buzzer_release init .25
          gk_Buzzer_harmonics init 8
          gk_Buzzer_level init 0
          gk_Buzzer_midi_dynamic_range init 20
          gi_Buzzer_sine ftgen 0, 0, 65537, 10, 1
          instr Buzzer
          i_instrument = p1
          i_time = p2
          i_duration = p3
          i_midi_key = p4
          i_midi_dynamic_range = i(gk_Buzzer_midi_dynamic_range)
          i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
          k_space_front_to_back = p6
          k_space_left_to_right = p7
          k_space_bottom_to_top = p8
          i_phase = p9
          i_frequency = cpsmidinn(i_midi_key)
          ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
          i_level_correction = 75
          i_normalization = ampdb(-i_level_correction) / 2
          i_amplitude = ampdb(i_midi_velocity) * i_normalization
          k_gain = ampdb(gk_Buzzer_level)
          i_attack = i(gk_Buzzer_attack)
          i_release = i(gk_Buzzer_release)
          i_sustain = p3
          xtratim 1
          a_envelope transegr 0.0, i_attack / 2.0, 1.5, i_amplitude / 2.0, i_attack / 2.0, -1.5, i_amplitude, i_sustain, 0.0, i_amplitude, i_release / 2.0, 1.5, i_amplitude / 2.0, i_release / 2.0, -1.5, 0
          a_signal buzz a_envelope, i_frequency, gk_Buzzer_harmonics, gi_Buzzer_sine
          a_signal = a_signal * k_gain
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          ;printks "Buzzer         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
          endin
            
        gk_Shiner_midi_dynamic_range chnexport "gk_Shiner_midi_dynamic_range", 3 ;  127
        gk_Shiner_attack chnexport "gk_Shiner_attack", 3 ;  .0125
        gk_Shiner_release chnexport "gk_Shiner_release", 3 ;  .0125
        gk_Shiner_level chnexport "gk_Shiner_level", 3 ;  0.5
        gk_Shiner_midi_dynamic_range init 20
        gk_Shiner_attack init .0125
        gk_Shiner_release init .0125
        gk_Shiner_level init -23
        gk_Shiner_front_to_back chnexport "gk_Shiner_front_to_back", 3 ;  0
        gk_Shiner_left_to_right chnexport "gk_Shiner_left_to_right", 3 ;  0.5
        gk_Shiner_bottom_to_top chnexport "gk_Shiner_bottom_to_top", 3 ;  0
        gk_Shiner_front_to_back init 0
        gk_Shiner_left_to_right init 0.5
        gk_Shiner_bottom_to_top init 0
        instr Shiner
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_physical_decay = 20
        if p3 == -1 then
        i_duration = i_physical_decay
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Shiner_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        if p7 ==0 then
        k_space_left_to_right = gk_Shiner_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 42.5
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Shiner_level)
        iattack = i(gk_Shiner_attack)
        idecay = i(gk_Shiner_release)
        isustain = i_duration
        a_physical_envelope transeg 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, idecay / 2.0, 1.5, i_amplitude / 2.0, idecay / 2.0, -1.5, 0
        ihertz = cpsmidinn(i_midi_key)
        gk_Harmonics = 1 * 20
        a_signal vco2 4, ihertz, 12
        kgain = ampdb(gk_Shiner_level) * .5
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 1
        a_declicking_envelope cossegr 0, .005, 1,  i_duration, 1,  .01, 0
        ; The envelope of the instrument is the product of the physical envelope times 
        ; the declicking envelope. 
        a_envelope = a_physical_envelope * a_declicking_envelope
        ; That envelope is then low-pass filtered to remove most discontinuities.
        a_filtered_envelope tonex a_envelope, 40, 4
        a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        endin
        
        gk_Blower_grainDensity chnexport "gk_Blower_grainDensity", 3
        gk_Blower_grainDuration chnexport "gk_Blower_grainDuration", 3
        gk_Blower_grainAmplitudeRange chnexport "gk_Blower_grainAmplitudeRange", 3
        gk_Blower_grainFrequencyRange chnexport "gk_Blower_grainFrequencyRange", 3
        gk_Blower_attack chnexport "gk_Blower_attack", 3
        gk_Blower_release chnexport "gk_Blower_release", 3
        gk_Blower_level chnexport "gk_Blower_level", 3
        gk_Blower_midi_dynamic_range chnexport "gk_Blower_midi_dynamic_range", 3
        gk_Blower_grainDensity init 40
        gk_Blower_grainDuration init 0.2
        gk_Blower_grainAmplitudeRange init 100
        gk_Blower_grainFrequencyRange init 3
        gk_Blower_attack init 1.5 
        gk_Blower_release init 2
        gk_Blower_level init 0
        gk_Blower_midi_dynamic_range init 20
        gk_Blower_space_left_to_right chnexport "gk_Blower_space_left_to_right", 3
        gk_Blower_space_left_to_right init .5
        gi_Blower_grtab ftgen 0, 0, 65537, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
        gi_Blower_wintab ftgen 0, 0, 65537, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
        instr Blower
        //////////////////////////////////////////////
        // Original by Hans Mikelson.
        // Adapted by Anonymous.
        //////////////////////////////////////////////
        i_instrument = p1
        i_time = p2
        i_duration = p3
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Blower_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        if p7 ==0 then
        k_space_left_to_right = gk_Blower_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 123
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Blower_level)
        iHz = i_frequency
        ihertz = iHz
        ip4 = i_amplitude
        ip5 = iHz
        ip6 = gi_Blower_grtab
        ip7 = gi_Blower_wintab
        ip8 = 0.033
        ip8 = .002
        ip9 = 150
        ip9 = 100
        ip10 = 1.6
        ip10 = 3
        idur = p3
        iamp = i_amplitude ; p4
        ifqc = iHz ; cpspch(p5)
        igrtab = ip6
        iwintab = ip7
        ifrng = ip8
        idens = ip9
        ifade = ip10
        igdur = 0.2
        iattack = i(gk_Blower_attack)
        i_sustain = p3
        idecay = i(gk_Blower_release)
        xtratim iattack + idecay
        kenvelope transegr 0.0, iattack / 2.0, 1.5, .5, iattack / 2.0, -1.5, 1, i_sustain, 0.0, 1, idecay / 2.0, 1.5, .5, idecay / 2.0, -1.5, 0
        ; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
        // Maybe frequency range should really be pitch range?
        aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
        aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
        a_signal = aoutl + aoutr
        i_attack = .002
        i_release = 0.01
        ; xtratim i_attack + i_release
        a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
        ; print iattack, idecay
        a_signal = a_signal * i_amplitude * k_gain * kenvelope
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        ;printks "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
        endin
          
          gk_ZakianFlute_midi_dynamic_range chnexport "gk_ZakianFlute_midi_dynamic_range", 3 ;  20
          gk_ZakianFlute_level chnexport "gk_ZakianFlute_level", 3 ;  0
          gk_ZakianFlute_pan chnexport "gk_ZakianFlute_pan", 3 ;  .5
          gi_ZakianFLute_seed chnexport "gi_ZakianFLute_seed", 3 ;  .5
          gi_ZakianFLute_space_left_to_front chnexport "gi_ZakianFLute_space_left_to_front", 3 ;  .5
          gk_ZakianFlute_midi_dynamic_range init 20
          gk_ZakianFlute_level init 0
          gk_ZakianFlute_pan init .5
          gi_ZakianFLute_seed init .5
          gi_ZakianFLute_space_left_to_front init .5
          gi_ZakianFLute_f2  ftgen 0, 0, 16, -2, 40, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 10240
          gi_ZakianFlute_f26 ftgen 0, 0, 65537, -10, 2000, 489, 74, 219, 125, 9, 33, 5, 5
          gi_ZakianFlute_f27 ftgen 0, 0, 65537, -10, 2729, 1926, 346, 662, 537, 110, 61, 29, 7
          gi_ZakianFlute_f28 ftgen 0, 0, 65537, -10, 2558, 2012, 390, 361, 534, 139, 53, 22, 10, 13, 10
          gi_ZakianFlute_f29 ftgen 0, 0, 65537, -10, 12318, 8844, 1841, 1636, 256, 150, 60, 46, 11
          gi_ZakianFlute_f30 ftgen 0, 0, 65537, -10, 1229, 16, 34, 57, 32
          gi_ZakianFlute_f31 ftgen 0, 0, 65537, -10, 163, 31, 1, 50, 31
          gi_ZakianFlute_f32 ftgen 0, 0, 65537, -10, 4128, 883, 354, 79, 59, 23
          gi_ZakianFlute_f33 ftgen 0, 0, 65537, -10, 1924, 930, 251, 50, 25, 14
          gi_ZakianFlute_f34 ftgen 0, 0, 65537, -10, 94, 6, 22, 8
          gi_ZakianFlute_f35 ftgen 0, 0, 65537, -10, 2661, 87, 33, 18
          gi_ZakianFlute_f36 ftgen 0, 0, 65537, -10, 174, 12
          gi_ZakianFlute_f37 ftgen 0, 0, 65537, -10, 314, 13
          gi_ZakianFlute_wtsin ftgen 0, 0, 65537, 10, 1
          instr ZakianFlute
          ; Author: Lee Zakian
          ; Adapted by: Anonymous
          i_instrument = p1
          i_time = p2
          if p3 == -1 then
          i_duration = 1000
          else
          i_duration = p3
          endif
          i_midi_key = p4
          i_midi_velocity = p5
          k_space_front_to_back = p6
          if p7 == 0 then
          k_space_left_to_right = gi_ZakianFLute_space_left_to_front
          else
          k_space_left_to_right = p7
          endif
          k_space_bottom_to_top = p8
          i_phase = p9
          i_overall_amps = 65.2
          i_normalization = ampdb(-i_overall_amps) / 2
          i_midi_dynamic_range = i(gk_ZakianFlute_midi_dynamic_range)
          i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
          i_amplitude = ampdb(i_midi_velocity) * i_normalization
          k_gain = ampdb(gk_ZakianFlute_level)
          ;;;xtratim iattack + irelease
          iHz = cpsmidinn(i_midi_key)
          kHz = k(iHz)
          // Bug?
          aenvelope transeg 1.0, 20.0, -10.0, 0.05
          ///aenvelope transegr 1.0, 20.0, -10.0, 0.05
          ip3 = 3;;; (p3 < 3.0 ? p3 : 3.0)
          ; parameters
          ; p4 overall amplitude scaling factor
          ip4 init i_amplitude
          ; p5 pitch in Hertz (normal pitch range: C4-C7)
          ip5 init iHz
          ; p6 percent vibrato depth, recommended values in range [-1., +1.]
          ip6 init 0.5
          ; 0.0 -> no vibrato
          ; +1. -> 1% vibrato depth, where vibrato rate increases slightly
          ; -1. -> 1% vibrato depth, where vibrato rate decreases slightly
          ; p7 attack time in seconds
          ; recommended value: .12 for slurred notes, .06 for tongued notes
          ; (.03 for short notes)
          ip7 init .08
          ; p8 decay time in seconds
          ; recommended value: .1 (.05 for short notes)
          ip8 init .08
          ; p9 overall brightness / filter cutoff factor
          ; 1 -> least bright / minimum filter cutoff frequency (40 Hz)
          ; 9 -> brightest / maximum filter cutoff frequency (10,240Hz)
          ip9 init 5
          ; initial variables
          iampscale = ip4 ; overall amplitude scaling factor
          ifreq = ip5 ; pitch in Hertz
          ivibdepth = abs(ip6*ifreq/100.0) ; vibrato depth relative to fundamental frequency
          iattack = ip7 * (1.1 - .2*gi_ZakianFLute_seed) ; attack time with up to +-10% random deviation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947) ; reset gi_ZakianFLute_seed
          idecay = ip8 * (1.1 - .2*gi_ZakianFLute_seed) ; decay time with up to +-10% random deviation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          ifiltcut tablei ip9, gi_ZakianFLute_f2 ; lowpass filter cutoff frequency
          iattack = (iattack < 6/kr ? 6/kr : iattack) ; minimal attack length
          idecay = (idecay < 6/kr ? 6/kr : idecay) ; minimal decay length
          isustain = i_duration - iattack - idecay
          ;;;p3 = (isustain < 5/kr ? iattack+idecay+5/kr : i_duration) ; minimal sustain length
          isustain = (isustain < 5/kr ? 5/kr : isustain)
          iatt = iattack/6
          isus = isustain/4
          idec = idecay/6
          iphase = gi_ZakianFLute_seed ; use same phase for all wavetables
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          ; vibrato block
          ; kvibdepth linseg .1, .8*p3, 1, .2*p3, .7
          kvibdepth linseg .1, .8*ip3, 1, isustain, 1, .2*ip3, .7
          kvibdepth = kvibdepth* ivibdepth ; vibrato depth
          kvibdepthr randi .1*kvibdepth, 5, gi_ZakianFLute_seed ; up to 10% vibrato depth variation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kvibdepth = kvibdepth + kvibdepthr
          ivibr1 = gi_ZakianFLute_seed ; vibrato rate
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          ivibr2 = gi_ZakianFLute_seed
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          if ip6 < 0 goto vibrato1
          kvibrate linseg 2.5+ivibr1, isustain, 4.5+ivibr2 ; if p6 positive vibrato gets faster
          goto vibrato2
          vibrato1:
          ivibr3 = gi_ZakianFLute_seed
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kvibrate linseg 3.5+ivibr1, .1, 4.5+ivibr2,isustain-.1, 2.5+ivibr3 ; if p6 negative vibrato gets slower
          vibrato2:
          kvibrater randi .1*kvibrate, 5, gi_ZakianFLute_seed ; up to 10% vibrato rate variation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kvibrate = kvibrate + kvibrater
          kvib oscili kvibdepth, kvibrate, gi_ZakianFlute_wtsin
          ifdev1 = -.03 * gi_ZakianFLute_seed ; frequency deviation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          ifdev2 = .003 * gi_ZakianFLute_seed
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          ifdev3 = -.0015 * gi_ZakianFLute_seed
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          ifdev4 = .012 * gi_ZakianFLute_seed
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kfreqr linseg ifdev1, iattack, ifdev2, isustain, ifdev3, idecay, ifdev4
          kfreq = kHz * (1 + kfreqr) + kvib
          if ifreq < 427.28 goto range1 ; (cpspch(8.08) + cpspch(8.09))/2
          if ifreq < 608.22 goto range2 ; (cpspch(9.02) + cpspch(9.03))/2
          if ifreq < 1013.7 goto range3 ; (cpspch(9.11) + cpspch(10.00))/2
          goto range4
          ; wavetable amplitude envelopes
          range1: ; for low range tones
          kamp1 linseg 0, iatt, 0.002, iatt, 0.045, iatt, 0.146, iatt, \
          0.272, iatt, 0.072, iatt, 0.043, isus, 0.230, isus, 0.000, isus, \
          0.118, isus, 0.923, idec, 1.191, idec, 0.794, idec, 0.418, idec, \
          0.172, idec, 0.053, idec, 0
          kamp2 linseg 0, iatt, 0.009, iatt, 0.022, iatt, -0.049, iatt, \
          -0.120, iatt, 0.297, iatt, 1.890, isus, 1.543, isus, 0.000, isus, \
          0.546, isus, 0.690, idec, -0.318, idec, -0.326, idec, -0.116, idec, \
          -0.035, idec, -0.020, idec, 0
          kamp3 linseg 0, iatt, 0.005, iatt, -0.026, iatt, 0.023, iatt, \
          0.133, iatt, 0.060, iatt, -1.245, isus, -0.760, isus, 1.000, isus, \
          0.360, isus, -0.526, idec, 0.165, idec, 0.184, idec, 0.060, idec, \
          0.010, idec, 0.013, idec, 0
          iwt1 = gi_ZakianFlute_f26 ; wavetable numbers
          iwt2 = gi_ZakianFlute_f27
          iwt3 = gi_ZakianFlute_f28
          inorm = 3949
          goto end
          range2: ; for low mid-range tones
          kamp1 linseg 0, iatt, 0.000, iatt, -0.005, iatt, 0.000, iatt, \
          0.030, iatt, 0.198, iatt, 0.664, isus, 1.451, isus, 1.782, isus, \
          1.316, isus, 0.817, idec, 0.284, idec, 0.171, idec, 0.082, idec, \
          0.037, idec, 0.012, idec, 0
          kamp2 linseg 0, iatt, 0.000, iatt, 0.320, iatt, 0.882, iatt, \
          1.863, iatt, 4.175, iatt, 4.355, isus, -5.329, isus, -8.303, isus, \
          -1.480, isus, -0.472, idec, 1.819, idec, -0.135, idec, -0.082, idec, \
          -0.170, idec, -0.065, idec, 0
          kamp3 linseg 0, iatt, 1.000, iatt, 0.520, iatt, -0.303, iatt, \
          0.059, iatt, -4.103, iatt, -6.784, isus, 7.006, isus, 11, isus, \
          12.495, isus, -0.562, idec, -4.946, idec, -0.587, idec, 0.440, idec, \
          0.174, idec, -0.027, idec, 0
          iwt1 = gi_ZakianFlute_f29
          iwt2 = gi_ZakianFlute_f30
          iwt3 = gi_ZakianFlute_f31
          inorm = 27668.2
          goto end
          range3: ; for high mid-range tones
          kamp1 linseg 0, iatt, 0.005, iatt, 0.000, iatt, -0.082, iatt, \
          0.36, iatt, 0.581, iatt, 0.416, isus, 1.073, isus, 0.000, isus, \
          0.356, isus, .86, idec, 0.532, idec, 0.162, idec, 0.076, idec, 0.064, \
          idec, 0.031, idec, 0
          kamp2 linseg 0, iatt, -0.005, iatt, 0.000, iatt, 0.205, iatt, \
          -0.284, iatt, -0.208, iatt, 0.326, isus, -0.401, isus, 1.540, isus, \
          0.589, isus, -0.486, idec, -0.016, idec, 0.141, idec, 0.105, idec, \
          -0.003, idec, -0.023, idec, 0
          kamp3 linseg 0, iatt, 0.722, iatt, 1.500, iatt, 3.697, iatt, \
          0.080, iatt, -2.327, iatt, -0.684, isus, -2.638, isus, 0.000, isus, \
          1.347, isus, 0.485, idec, -0.419, idec, -.700, idec, -0.278, idec, \
          0.167, idec, -0.059, idec, 0
          iwt1 = gi_ZakianFlute_f32
          iwt2 = gi_ZakianFlute_f33
          iwt3 = gi_ZakianFlute_f34
          inorm = 3775
          goto end
          range4: ; for high range tones
          kamp1 linseg 0, iatt, 0.000, iatt, 0.000, iatt, 0.211, iatt, \
          0.526, iatt, 0.989, iatt, 1.216, isus, 1.727, isus, 1.881, isus, \
          1.462, isus, 1.28, idec, 0.75, idec, 0.34, idec, 0.154, idec, 0.122, \
          idec, 0.028, idec, 0
          kamp2 linseg 0, iatt, 0.500, iatt, 0.000, iatt, 0.181, iatt, \
          0.859, iatt, -0.205, iatt, -0.430, isus, -0.725, isus, -0.544, isus, \
          -0.436, isus, -0.109, idec, -0.03, idec, -0.022, idec, -0.046, idec, \
          -0.071, idec, -0.019, idec, 0
          kamp3 linseg 0, iatt, 0.000, iatt, 1.000, iatt, 0.426, iatt, \
          0.222, iatt, 0.175, iatt, -0.153, isus, 0.355, isus, 0.175, isus, \
          0.16, isus, -0.246, idec, -0.045, idec, -0.072, idec, 0.057, idec, \
          -0.024, idec, 0.002, idec, 0
          iwt1 = gi_ZakianFlute_f35
          iwt2 = gi_ZakianFlute_f36
          iwt3 = gi_ZakianFlute_f37
          inorm = 4909.05
          goto end
          end:
          kampr1 randi .02*kamp1, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kamp1 = kamp1 + kampr1
          kampr2 randi .02*kamp2, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kamp2 = kamp2 + kampr2
          kampr3 randi .02*kamp3, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
          gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
          kamp3 = kamp3 + kampr3
          awt1 poscil kamp1, kfreq, iwt1, iphase ; wavetable lookup
          awt2 poscil kamp2, kfreq, iwt2, iphase
          awt3 poscil kamp3, kfreq, iwt3, iphase
          asig = awt1 + awt2 + awt3
          asig = asig*(iampscale/inorm)
          kcut linseg 0, iattack, ifiltcut, isustain, ifiltcut, idecay, 0 ; lowpass filter for brightness control
          afilt tone asig, kcut
          a_signal balance afilt, asig
          i_attack = .002
          i_sustain = i_duration
          i_release = 0.01
          i_declick_attack = i_attack
          i_declick_release = i_declick_attack * 2
          ; The end of the note must be extended _past_ the end of the release segment.
          xtratim 1
          a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
          ; That envelope is then low-pass filtered to remove most discontinuities.
          a_filtered_envelope tonex a_declicking_envelope, 40, 4
          a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          a_signal *= .7
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          endin
            
        
          gk_Bower_midi_dynamic_range chnexport "gk_Bower_midi_dynamic_range", 3
          gk_Bower_attack chnexport "gk_Bower_attack", 3
          gk_Bower_release chnexport "gk_Bower_release", 3
          gk_Bower_level chnexport "gk_Bower_level", 3
          gk_Bower_pressure chnexport "gk_Bower_pressure", 3
          gk_Bower_space_left_to_right chnexport "gk_Bower_space_left_to_right", 3
          gk_Bower_midi_dynamic_range init 20
          gk_Bower_attack init .125
          gk_Bower_release init .125
          gk_Bower_level init 0
          gk_Bower_pressure init 0.25
          gk_Bower_space_left_to_right init 0.75
          gi_Bower_sine ftgen 0,0,65537,10,1
          instr Bower
          i_instrument = p1
          i_time = p2
          i_duration = p3
          i_midi_key = p4
          i_midi_dynamic_range = i(gk_Bower_midi_dynamic_range)
          i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
          k_space_front_to_back = p6
          if p7 == 0 then
          k_space_left_to_right = gk_Bower_space_left_to_right
          else
          k_space_left_to_right = p7
          endif
          k_space_bottom_to_top = p8
          k_space_bottom_to_top = p8
          i_phase = p9
          i_frequency = cpsmidinn(i_midi_key)
          ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
          i_level_correction = 66
          i_normalization = ampdb(-i_level_correction) / 2
          i_amplitude = ampdb(i_midi_velocity) * i_normalization
          k_gain = ampdb(gk_Bower_level)
          iattack = i(gk_Bower_attack)
          idecay = i(gk_Bower_release)
          isustain = p3
          iamp = i_amplitude
          xtratim iattack + idecay
          kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
          ihertz = cpsmidinn(i_midi_key)
          kamp = kenvelope
          kfreq = ihertz
          kpres = 0.25
          krat rspline 0.006,0.988,1,4
          kvibf = 4.5
          kvibamp = 0
          iminfreq = i(kfreq) / 2
          aSig wgbow kamp,kfreq,gk_Bower_pressure,krat,kvibf,kvibamp,gi_Bower_sine,iminfreq
          a_signal = aSig * kenvelope * k_gain
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
          outleta "outleft", a_out_left
          outleta "outright", a_out_right
          ;printks "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
          endin
            
          gk_FilteredSines_level chnexport "gk_FilteredSines_level", 3
        gi_FilteredSines_attack chnexport "gi_FilteredSines_attack", 3
        gi_FilteredSines_release chnexport "gi_FilteredSines_release", 3
        
        gk_FilteredSines_level init 0
        gi_FilteredSines_attack init 1
          gi_FilteredSines_release init 1
        
        gi_FilteredSines_bergeman ftgen 0, 0, 65537, 10, .28, 1, .74, .66, .78, .48, .05, .33, 0.12, .08, .01, .54, 0.19, .08, .05, 0.16, .01, 0.11, .3, .02, 0.2 ; Bergeman f1
        
        instr FilteredSines
        ; Author: Michael Bergeman
        ; Modified by: Anonymous
        xtratim gi_FilteredSines_attack + gi_FilteredSines_release
        i_instrument = p1
        i_time = p2
        i_duration = p3
        i_midi_key = p4
        i_midi_velocity = p5
        k_space_front_to_back = p6
        k_space_left_to_right = p7
        k_space_bottom_to_top = p8
        i_phase = p9
        i_overall_amps = 166
        i_normalization = ampdb(-i_overall_amps) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        i_frequency = cpsmidinn(i_midi_key)
        k_gain = ampdb(gk_FilteredSines_level)
        kHz = k(i_frequency)
        koctave = octcps(kHz)
        iattack init gi_FilteredSines_attack
        isustain init p3
        irelease init gi_FilteredSines_release
        idb = 1.5
        ip5 = gi_FilteredSines_bergeman
        ip3 = 5.0
        ip6 = 0.9
        ip7 = 1.4
        kp8 = cpsoct(koctave - .01)
        kp9 = cpsoct(koctave + .01)
        isc = idb * .333
        k1 linseg 40, ip3, 800, p3, 800, 0.06, 0.0
        k2 linseg 440, ip3, 220, p3, 220, 0.06, 0.0
        k3 linseg 0.0, ip6, 800, ip7, 200.0, p3, 200, 0.06, 0.0
        k4 linseg 800, ip3, 40, p3, 40, 0.06, 0.0
        k5 linseg 220, ip3, 440, p3, 440, 0.06, 0.0
        k6 linseg isc, ip6, p3, ip7, p3, 0.06, 0.0
        k7 linseg 0.0, ip6, 1, ip7, .3, p3, .1, 0.06, 0.0
        a5 poscil k3, kp8, ip5
        a6 poscil k3, kp8 * 0.999, ip5
        a7 poscil k3, kp8 * 1.001, ip5
        a1 = a5 + a6 + a7
        a8 poscil k6, kp9, ip5
        a9 poscil k6, kp9 * 0.999, ip5
        a10 poscil k6, kp9 * 1.001, ip5
        a11 = a8 + a9 + a10
        a2 butterbp a1, k1, 40
        a3 butterbp a2, k5, k2 * 0.8
        a4 balance a3, a1
        a12 butterbp a11, k4, 40
        a13 butterbp a12, k2, k5 * 0.8
        a14 balance a13, a11
        a15 reverb2 a4, 5, 0.3
        a16 reverb2 a4, 4, 0.2
        a17 = (a15 + a4) * k7
        a18 = (a16 + a4) * k7
        a_signal = (a17 + a18)
        i_attack = .002
        i_sustain = p3
        i_release = 0.01
        xtratim (i_attack + i_release)
        a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
        a_signal = a_signal * i_amplitude * a_declicking * k_gain * 1.88
        
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
          prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
          endin
          
          gk_Guitar_midi_dynamic_range chnexport "gk_Guitar_midi_dynamic_range", 3 ; 127
        gk_Guitar_midi_dynamic_range init 30
        gk_Guitar_level chnexport "gk_Guitar_level", 3
        gk_Guitar_level init 0
        gk_Guitar_space_left_to_right chnexport "gk_Guitar_space_left_to_right", 3
        gk_Guitar_space_left_to_right init .5
        
        instr Guitar
        ; Anonymous
        ; Simple emulation of a Spanish guitar.
        ; Considerably cleaned up after close listening and systematic testing. 
        ; But I think the plain `pluck` opcode is inherently a bit noisy. The 
        ; waveform is just jagged at first.
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_physical_decay = 20
        if p3 == -1 then
        i_duration = i_physical_decay
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Guitar_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        if p7 ==0 then
        k_space_left_to_right = gk_Guitar_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 73
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Guitar_level)
        i_frequency2 = i_frequency
        a_signal pluck 1.0, i_frequency, i_frequency2, 0, 6
        a_top_body reson a_signal, 110, 80
        a_bottom_body reson a_signal, 220, 100
        a_whole_body reson a_signal, 440, 80
        a_signal = (.6 * a_top_body + .8 * a_bottom_body + .6 * a_whole_body + .4 * a_signal) 
        ; For testing envelopes with a simple signal that lacks confounding artifacts.
        ; a_signal oscils .1, i_frequency2, 0
        ; For testing envelopes with a DC signal (shows only the envelope).
        ; a_signal = .25
        
        ; As with most software instruments that are modeled on an impulse exciting a 
        ; resonator, there should be two envelopes. The "physical" envelope must have a 
        ; fixed decay ending at zero.
        i_declick_minimum = .003
        i_attack = .001 / i_frequency + i_declick_minimum
        i_exponent = 7
        a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
        ; The de-clicking envelope must have attack and release segments that damp 
        ; artifacts in the signal. The duration of these segments depends on 
        ; the behavior of the instrument, and may vary as a function of frequency.
        i_declick_attack = i_attack
        i_declick_release = i_declick_minimum * 2
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 1
        a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
        ; The envelope of the instrument is the product of the physical envelope times 
        ; the declicking envelope. 
        a_envelope = a_physical_envelope * a_declicking_envelope
        ; That envelope is then low-pass filtered to remove most discontinuities.
        a_filtered_envelope tonex a_envelope, 40, 4
        a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
        
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        
        gk_Harpsichord_level chnexport "gk_Harpsichord_level", 3
        gk_Harpsichord_pick chnexport "gk_Harpsichord_pick", 3
        gk_Harpsichord_reflection chnexport "gk_Harpsichord_reflection", 3
        gk_Harpsichord_pluck chnexport "gk_Harpsichord_pluck", 3
        gk_Harpsichord_midi_dynamic_range chnexport "gk_Harpsichord_midi_dynamic_range", 3
        gk_Harpsichord_space_left_to_right chnexport "gk_Harpsichord_space_left_to_right", 3
        
        gk_Harpsichord_level init 0
        gk_Harpsichord_pick init .075
        gk_Harpsichord_reflection init .5
        gk_Harpsichord_pluck init .75
        gk_Harpsichord_midi_dynamic_range init 20
        gk_Harpsichord_space_left_to_right init .5
        
        gi_Harpsichord_harptable ftgen 0, 0, 65537, 7, -1, 1024, 1, 1024, -1
        
        instr 1000
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_physical_decay = 40
        if p3 == -1 then
        i_duration = i_physical_decay
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Harpsichord_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        if p7 == 0 then
        k_space_left_to_right = gk_Harpsichord_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 66
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Harpsichord_level)
        iHz = cpsmidinn(i_midi_key)
        kHz = k(iHz)
        a_physical_envelope transeg 1.0, i_physical_decay, -25.0, 0.0
        apluck pluck i_amplitude * k_gain, kHz, iHz, 0, 1
        aharp poscil a_physical_envelope, kHz, gi_Harpsichord_harptable
        aharp2 balance apluck, aharp
        a_signal	= (apluck + aharp2)
        i_attack = .0005
        i_sustain = p3
        i_release = 0.01
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 1
        i_declick_attack init .0008
        i_declick_release init .01
        a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
        a_envelope = a_declicking_envelope
        a_filtered_envelope tonex a_envelope, 40, 4
        a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 
        
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        ;printks "Harpsichord      %9.4f   %9.4f\n", 0.5, a_out_left, a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        /**
         * This is yet another attempt to adapt this beautiful sound for use in 
         * wider contexts. 
         *
         * In its original form this could not work without artifacts because of the 
         * k-rate frequency modulation of the pluck opcode.
         */
        gi_Kung2_detune_cents chnexport "gk_Kung2_detune_cents", 3
        gi_Kung2_detune_cents init 8
        gk_Kung2_level chnexport "gk_Kung2_level", 3
        gk_Kung2_level init 0
        gk_Kung2_midi_dynamic_range chnexport "gk_Kung2_midi_dynamic_range", 3
        gk_Kung2_midi_dynamic_range init 30
        gk_Kung2_space_left_to_right chnexport "gk_Kung2_space_left_to_right", 3
        gk_Kung2_space_left_to_right init .5
        gi_Kung2_sine ftgen 0, 0, 65537, 10, 1
        opcode Kung2_, aa, 0
        setksmps 1
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_instrument_duration = 999999
        if p3 == -1 then
        i_duration = i_instrument_duration
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Kung2_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        if p7 ==0 then
        k_space_left_to_right = gk_Kung2_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 21 + 51 + 7
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Kung2_level)
        ishift = gi_Kung2_detune_cents/12000
        ipch = cpsmidinn(i_midi_key)
        ioct = octmidinn(i_midi_key)
        i_vibrato_frequency = (i_midi_key / 127) * 2
        kvib poscil3 1/120, i_vibrato_frequency, gi_Kung2_sine
        ag pluck 1, cpsoct(ioct+kvib), 1000, gi_Kung2_sine, 1
        agleft pluck 1, cpsoct(ioct+ishift), 1000, gi_Kung2_sine, 1
        agright pluck 1, cpsoct(ioct-ishift), 1000, gi_Kung2_sine, 1
        i_physical_decay = 20
        ; As with most software instruments that are modeled on an impulse exciting a 
        ; resonator, there should be two envelopes. The "physical" envelope must have a 
        ; fixed decay ending at zero.
        i_declick_minimum = .003
        i_attack = .001 / i_frequency + i_declick_minimum
        i_exponent = 3
        a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
        a_declicking_envelope cossegr 0, .006, 1, i_instrument_duration, 1,  .06, 0
        a_envelope = a_physical_envelope * a_declicking_envelope
        a_filtered_envelope tonex a_envelope, 30, 3
        xtratim 3
        ag = a_declicking_envelope * ag
        agleft = a_declicking_envelope * agleft
        agright = a_declicking_envelope * agright
        adump delayr 0.3
        ad1 deltap3 0.1
        ad2 deltap3 0.2
        delayw ag
        a_out_left = agleft + ad1
        a_out_right = agright + ad2
        a_filtered_declicking tonex a_declicking_envelope, 30, 4
        a_out_left = a_out_left * k_gain * i_amplitude * a_filtered_declicking
        a_out_right = a_out_right * k_gain * i_amplitude * a_filtered_declicking 
        xout a_out_left, a_out_right
        endop
        
        instr Kung2
        a_out_left, a_out_right Kung2_
        outleta "outleft", a_out_left 
        outleta "outright", a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        
        gi_Kung4_detune_cents chnexport "gk_Kung4_detune_cents", 3
        gi_Kung4_detune_cents init 8
        gk_Kung4_level chnexport "gk_Kung4_level", 3
        gk_Kung4_level init 0
        gk_Kung4_midi_dynamic_range chnexport "gk_Kung4_midi_dynamic_range", 3
        gk_Kung4_midi_dynamic_range init 30
        gk_Kung4_space_left_to_right chnexport "gk_Kung4_space_left_to_right", 3
        gk_Kung4_space_left_to_right init .5
        gi_Kung4_modulation_ratio_start chnexport "gi_Kung4_modulation_ratio_start", 3
        gi_Kung4_modulation_ratio_start init 1.7
        gi_Kung4_modulation_ratio_end chnexport "gi_Kung4_modulation_ratio_end", 3
        gi_Kung4_modulation_ratio_end init .5
        
        gi_Kung4_sine ftgen 0, 0, 65537, 10, 1
        gi_Kung4_cosine ftgen 0, 0, 65537, 11, 1
        gi_Kung4_ln ftgen 0, 9, 65537, -12, 20.0  ;unscaled ln(I(x)) from 0 to 20.0
        /**
         * This is yet another attempt to adapt this beautiful sound for use in 
         * wider contexts.
         */
        instr Kung4
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_instrument_duration = 999999
        if p3 == -1 then
        i_duration = i_instrument_duration
        else
        i_duration = p3
        endif
        ;print i_duration
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Kung4_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        if p7 ==0 then
        k_space_left_to_right = gk_Kung4_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 130 + 8 + 6
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Kung4_level)
        ishift = gi_Kung4_detune_cents/12000
        ipch = cpsmidinn(i_midi_key)
        ioct = octmidinn(i_midi_key)
        kvib poscil 1/120, ipch/50, gi_Kung4_sine
        ; The instrument envelope should observe limits.
        if (i_duration > 10) then
        i_instrument_attack = 10 / 3
        elseif (i_duration < 1) then
        i_instrument_attack = 1 / 3
        else
        i_instrument_attack = i_duration / 3
        endif
        ;print i_instrument_attack
        ;i_instrument_duration -= (2 * i_instrument_attack)
        aadsr linsegr 0, i_instrument_attack, 1.0, i_duration, 1.0, i_instrument_attack, 0 ;ADSR envelope
        amodi linseg 0, i_instrument_attack, 5, i_duration, 3, i_instrument_attack, 0 ;ADSR envelope for I
        amodr linseg gi_Kung4_modulation_ratio_start, i_duration, gi_Kung4_modulation_ratio_end ;r moves from p6->p7 in p3 sec.
        a1 = amodi*(amodr-1/amodr)/2
        a1ndx = abs(a1*2/20) ;a1*2 is normalized from 0-1.
        a2 = amodi*(amodr+1/amodr)/2
        a3 tablei a1ndx, gi_Kung4_ln, 1 ;lookup tbl in f3, normal index
        ao1 poscil a1, ipch, gi_Kung4_cosine ;cosine
        a4 = exp(-0.5*a3+ao1)
        ao2 poscil a2*ipch, ipch, gi_Kung4_cosine ;cosine
        a_out_left poscil 1000*aadsr*a4, ao2+cpsoct(ioct+ishift), gi_Kung4_sine ;fnl outleft
        a_out_right poscil 1000*aadsr*a4, ao2+cpsoct(ioct-ishift), gi_Kung4_sine ;fnl outright
        i_declick_minimum = .003
        i_attack = .001 / i_frequency + i_declick_minimum
        i_exponent = 7
        a_physical_envelope = aadsr ;  transeg 0,   i_attack, i_exponent,  1,   i_duration, -i_exponent,  0
        ; The de-clicking envelope must have attack and release segments that damp 
        ; artifacts in the signal. The duration of these segments depends on 
        ; the behavior of the instrument, and may vary as a function of frequency.
        i_declick_attack = i_attack
        i_declick_release = i_declick_minimum * 2
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 5
        ;print i_declick_attack
        ;print i_declick_release
        ;print i_duration
        a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
        ; The envelope of the instrument is the product of the physical envelope times 
        ; the declicking envelope. 
        a_envelope = a_physical_envelope * a_declicking_envelope
        ; That envelope is then low-pass filtered to remove most discontinuities.
        a_filtered_envelope tonex a_envelope, 40, 4
        a_out_left = a_out_left * i_amplitude * a_filtered_envelope * k_gain 
        a_out_right = a_out_right * i_amplitude * a_filtered_envelope * k_gain 
        
        outleta "outleft", a_out_left 
        outleta "outright", a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        gk_Plucked_midi_dynamic_range chnexport "gk_Plucked_midi_dynamic_range", 3
        gk_Plucked_midi_dynamic_range init 30
        gk_Plucked_space_left_to_right chnexport "gk_Plucked_space_left_to_right", 3
        gk_Plucked_space_left_to_right init .5
        gk_Plucked_level chnexport "gk_Plucked_level", 3
        gk_Plucked_level init 0
        
        gi_Plucked_sine ftgen 0, 0, 65537, 10, 1
        
        instr Plucked
        ; Author: Anonymous
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_physical_decay = 20
        if p3 == -1 then
        i_duration = i_physical_decay
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_Plucked_midi_dynamic_range)
        i_midi_velocity = p5 ;* i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        i_midi_velocity ampmidid i_midi_velocity, i_midi_dynamic_range
        k_space_front_to_back = p6
        if p7 == 0 then
        k_space_left_to_right = gk_Plucked_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_detune_cents = 1.5
        i_detune = i_detune_cents / 100
        i_frequency1 = cpsmidinn(i_midi_key - i_detune)
        i_frequency2 = cpsmidinn(i_midi_key)
        i_frequency3 = cpsmidinn(i_midi_key + i_detune)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_overall_amps = 26
        i_normalization = ampdb(-(i_overall_amps)) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_Plucked_level)
        asignal1 wgpluck2 0.1, 1.0, i_frequency1, 0.25, 0.222
        asignal2 wgpluck2 0.1, 1.0, i_frequency2, 0.20, 0.223
        asignal3 wgpluck2 0.1, 1.0, i_frequency3, 0.23, 0.225
        a_signal = (asignal1 + asignal2 + asignal3)
        ; As with most instruments that are based upon an impulse delivered to a 
        ; resonator, there are two envelopes, one for the physical decay with a 
        ; fixed release ending at zero, and one with a release segment to remove 
        ; clicks from the attack and release.
        ;
        ; As with most software instruments that are modeled on an impulse exciting a 
        ; resonator, there should be two envelopes. The "physical" envelope must have a 
        ; fixed decay ending at zero.
        i_declick_minimum = .001
        i_attack = .001 / i_frequency2 + i_declick_minimum
        i_exponent = 7
        a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
        ; The de-clicking envelope must have attack and release segments that damp 
        ; artifacts in the signal. The duration of these segments depends on 
        ; the behavior of the instrument, and may vary as a function of frequency.
        i_declick_attack = i_attack
        i_declick_release = i_declick_minimum * 2
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 1
        a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
        ; The envelope of the instrument is the product of the physical envelope times 
        ; the declicking envelope. 
        a_envelope = a_physical_envelope * a_declicking_envelope
        ; That envelope is then low-pass filtered to remove most discontinuities.
        a_filtered_envelope tonex a_envelope, 40, 4
        a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.05
        
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        gi_SeidelHarmOsc_tabsz init 2^16
        
        gi_SeidelHarmOsc_Sin     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0
        gi_SeidelHarmOsc_Tri     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0,  3,0.333,180,  5,0.2,0,  7,0.143,180, 9,0.111,0, 11,0.091,180, 13,0.077,0, 15,0.067,180, 17,0.059,0, 19,0.053,180, 21,0.048,0, 23,0.043,180, 25,0.04,0, 27,0.037,180, 29,0.034,0, 31,0.032,180
        gi_SeidelHarmOsc_Saw     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 7, 0, gi_SeidelHarmOsc_tabsz/2, 1, 0, -1, gi_SeidelHarmOsc_tabsz/2, 0
        gi_SeidelHarmOsc_Square  ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 7, 1, gi_SeidelHarmOsc_tabsz/2, 1, 0, -1, gi_SeidelHarmOsc_tabsz/2, -1
        gi_SeidelHarmOsc_Prime   ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0,  2,0.5,0,  3,0.3333,0,  5,0.2,0,   7,0.143,0,  11,0.0909,0,  13,0.077,0,   17,0.0588,0,  19,0.0526,0, 23,0.0435,0, 27,0.037,0, 31,0.032,180
        gi_SeidelHarmOsc_Fib     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0,  2,0.5,0,  3,0.3333,0,  5,0.2,0,   8,0.125,0,  13,0.0769,0,  21,0.0476,0,  34,0.0294,0 ;,  55,0.0182,0,  89,0.0112,0, 144,0.0069,0
        
        gi_SeidelHarmOsc_NumTables = 5
        gi_SeidelHarmOsc_List ftgen 1000, 0, gi_SeidelHarmOsc_NumTables, -2, gi_SeidelHarmOsc_Tri, gi_SeidelHarmOsc_Saw, gi_SeidelHarmOsc_Square, gi_SeidelHarmOsc_Prime, gi_SeidelHarmOsc_Fib, gi_SeidelHarmOsc_Sin
        gi_SeidelHarmOsc_Morf ftgen 1001, 0, gi_SeidelHarmOsc_tabsz, 10, 1
        
        gi_SeidelHarmOsc_lforabsz init 2^13
        gi_SeidelHarmOsc_LfoTri ftgen 0, 0, gi_SeidelHarmOsc_lforabsz, 7, 0, gi_SeidelHarmOsc_lforabsz/4, 1, gi_SeidelHarmOsc_lforabsz/2, -1, gi_SeidelHarmOsc_lforabsz/4, 0
        
        gk_SeidelHarmOsc_level chnexport "gk_SeidelHarmOsc_level", 3 ;  0
        gi_SeidelHarmOsc_attack chnexport "gi_SeidelHarmOsc_attack", 3 ;  0.003
        gi_SeidelHarmOsc_petals chnexport "gi_SeidelHarmOsc_petals", 3 ;  2.99
        gi_SeidelHarmOsc_release chnexport "gi_SeidelHarmOsc_release", 3 ;  0.01
        gk_SeidelHarmOsc_midi_dynamic_range chnexport "gk_SeidelHarmOsc_midi_dynamic_range", 3 ;  20
        
        gk_SeidelHarmOsc_level init 0
        gi_SeidelHarmOsc_attack init 0.003
        gi_SeidelHarmOsc_petals init 2.99
        gi_SeidelHarmOsc_release init 0.01
        gk_SeidelHarmOsc_midi_dynamic_range init 20
        
        gk_SeidelHarmOsc_P1 chnexport "gk_SeidelHarmOsc_P1", 3
        gk_SeidelHarmOsc_IN1CON chnexport "gk_SeidelHarmOsc_IN1CON", 3
        gk_SeidelHarmOsc_IN1C1 chnexport "gk_SeidelHarmOsc_IN1C1", 3
        
        gk_SeidelHarmOsc_P1 init 0.1
        gk_SeidelHarmOsc_IN1CON init 0.1
        gk_SeidelHarmOsc_IN1C1 init 1
        
        gk_SeidelHarmOsc_P2 chnexport "gk_SeidelHarmOsc_P2", 3
        gk_SeidelHarmOsc_IN2C1 chnexport "gk_SeidelHarmOsc_IN2C1", 3
        gk_SeidelHarmOsc_IN2CON chnexport "gk_SeidelHarmOsc_IN2CON", 3
        
        gk_SeidelHarmOsc_P2 init 0.1
        gk_SeidelHarmOsc_IN2C1 init 1
        gk_SeidelHarmOsc_IN2CON init 0.1
        
        gk_SeidelHarmOsc_P3 chnexport "gk_SeidelHarmOsc_P3", 3
        gk_SeidelHarmOsc_IN3C1 chnexport "gk_SeidelHarmOsc_IN3C1", 3
        gk_SeidelHarmOsc_IN3CON chnexport "gk_SeidelHarmOsc_IN3CON", 3
        
        gk_SeidelHarmOsc_P3 init 0.1
        gk_SeidelHarmOsc_IN3C1 init 1
        gk_SeidelHarmOsc_IN3CON init 0.1
        
        gk_SeidelHarmOsc_P4 chnexport "gk_SeidelHarmOsc_P4", 3
        gk_SeidelHarmOsc_IN4C1 chnexport "gk_SeidelHarmOsc_IN4C1", 3
        gk_SeidelHarmOsc_IN4CON chnexport "gk_SeidelHarmOsc_IN4CON", 3
        
        gk_SeidelHarmOsc_P4 init 0.1
        gk_SeidelHarmOsc_IN4C1 init 1
        gk_SeidelHarmOsc_IN4CON init 0.1
        
        gi_SeidelHarmOsc_pitch_bend_table ftgen 0, 0, 1024, -7, 1, 1024, 1 
        gi_SeidelHarmOsc_sine ftgen 0, 0, 65537, 10, 1
        
        instr SeidelHarmOsc
        i_instrument = p1
        i_time = p2
        i_sustain = p3
        xtratim gi_SeidelHarmOsc_attack + gi_SeidelHarmOsc_release
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_SeidelHarmOsc_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
        // Spatial location is specified in Ambisonic coordinates.
        k_space_front_to_back = p6
        // AKA stereo pan.
        k_space_left_to_right = p7
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        // Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 87
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_SeidelHarmOsc_level)
        ; prints("p1=%f, p2=%f, p3=%f, p4=%f\n", p1, p2, p3, p4)
        ;;;kfreq chnget sprintf("FREQ%d", p4)
        kfreq init i_frequency
        
        kin1con init 0
        kin2con init 0
        kin3con init 0
        kin4con init 0
        
        koff  init 0.001
        koff1 init 0.001
        koff2 init 2 * 0.001
        koff3 init 3 * 0.001
        koff4 init 5 * 0.001
        koffa = scale2(gk_SeidelHarmOsc_P1, 0.001, 0.1, -10, 10)
        if (gk_SeidelHarmOsc_IN1CON == 1) then
        koffb = scale2(gk_SeidelHarmOsc_IN1C1, 0.001, 0.1, 0, 10)
        koff = koffa + koffb
        else
        koff = koffa
        endif
        koff1 = koff
        koff2 = 2 * koff
        koff3 = 3 * koff
        koff4 = 5 * koff
        
        itbl = gi_SeidelHarmOsc_Morf
        kndx init 0
        kndxa = scale2(gk_SeidelHarmOsc_P2, 0, gi_SeidelHarmOsc_NumTables-1.01, -10, 10)
        if (gk_SeidelHarmOsc_IN2CON == 1) then
        kndxb = scale2(gk_SeidelHarmOsc_IN2C1, 0, gi_SeidelHarmOsc_NumTables-1.01, 0, 10)
        kndx = kndxa + kndxb
        else
        kndx = kndxa
        endif
        ftmorf kndx, gi_SeidelHarmOsc_List, gi_SeidelHarmOsc_Morf
        
        kamp init 0.8/9
        
        ; a1 oscil3 kamp, kfreq, itbl
        a2 oscil3 kamp, kfreq+koff1, itbl
        a3 oscil3 kamp, kfreq+koff2, itbl
        a4 oscil3 kamp, kfreq+koff3, itbl
        a5 oscil3 kamp, kfreq+koff4, itbl
        a6 oscil3 kamp, kfreq-koff1, itbl
        a7 oscil3 kamp, kfreq-koff2, itbl
        a8 oscil3 kamp, kfreq-koff3, itbl
        a9 oscil3 kamp, kfreq-koff4, itbl
        
        kdst init 0
        kdsta = scale2(gk_SeidelHarmOsc_P3, 0, 10, -10, 10)
        if (gk_SeidelHarmOsc_IN3CON == 1) then
        kdstb = scale2(gk_SeidelHarmOsc_IN3C1, 0, 10, 0, 10)
        kdst = kdsta + kdstb
        else
        kdst = kdsta
        endif
        
        aL = a2+a4+a6+a8
        aR = a3+a5+a7+a9
        aoutL = aL + distort1(aL, kdst, 0.1, 0, 0)
        aoutR = aR + distort1(aR, kdst, 0.1, 0, 0)
        
        kpana = scale2(gk_SeidelHarmOsc_P4, 0, 7, -10, 10)
        if (gk_SeidelHarmOsc_IN4CON == 1) then
        kpanb = scale2(gk_SeidelHarmOsc_IN4C1, 0, 5, 0, 10)
        kpan = kpana + kpanb
        else
        kpan = kpana
        endif
        if (kpan == 0) then
        kext = 0
        else
        kext = 0.1
        endif
        klfoL oscili 0.49, kpan-kext, gi_SeidelHarmOsc_LfoTri, 90
        klfoR oscili 0.49, kpan+kext, gi_SeidelHarmOsc_LfoTri, 270
        klfoL += 0.5
        klfoR += 0.5
        aoutL1, aoutR1 pan2 aoutL, klfoL
        aoutL2, aoutR2 pan2 aoutR, klfoR
        aoutL = aoutL1+aoutL2
        aoutR = aoutR1+aoutR2
        
        aenv madsr 0.07,0,1,0.7
        a_out_left = aoutL * aenv * k_gain * i_amplitude
        a_out_right = aoutR * aenv * k_gain * i_amplitude
        ;;; outs aoutL*aenv, aoutR*aenv
        ;;; a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        ;printks "WGPluck      %9.4f   %9.4f\n", 0.5, a_out_left, a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        
        gk_TubularBell_level chnexport "gk_TubularBell_level", 3
        gi_TubularBell_crossfade chnexport "gi_TubularBell_crossfade", 3
        gi_TubularBell_vibrato_depth chnexport "gi_TubularBell_vibrato_depth", 3
        gi_TubularBell_vibrato_rate chnexport "gi_TubularBell_vibrato_rate", 3
        
        gk_TubularBell_level init 0
        gi_TubularBell_crossfade init 2
        gi_TubularBell_vibrato_depth init .1
        gi_TubularBell_vibrato_rate init 5
        gk_TubularBell_midi_dynamic_range chnexport "gk_TubularBell_midi_dynamic_range", 3 ; 127
        gk_TubularBell_midi_dynamic_range init 30
        
        gk_TubularBell_space_left_to_right chnexport "gk_TubularBell_space_left_to_right", 3
        gk_TubularBell_space_left_to_right init .5
        
        gi_TubularBell_isine ftgen 0, 0, 65537, 10, 1
        gi_TubularBell_icosine ftgen 0, 0, 65537, 11, 1
        gi_TubularBell_icook3 ftgen 0, 0, 65537, 10, 1, .4, 0.2, 0.1, 0.1, .05
        
        instr TubularBell
        ; Authors: Perry Cook, John ffitch, Anonymous
        i_instrument = p1
        i_time = p2
        i_physical_decay = 5
        if p3 == -1 then
        i_duration = i_physical_decay
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_velocity = p5
        k_space_front_to_back = p6
        if p7 ==0 then
        k_space_left_to_right = gk_TubularBell_space_left_to_right
        else
        k_space_left_to_right = p7
        endif
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_overall_amps = 12.5
        i_normalization = ampdb(-i_overall_amps) / 2
        i_midi_dynamic_range = i(gk_TubularBell_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_TubularBell_level)
        iattack = 0.002
        isustain = p3
        irelease = 0.05
        iindex = 1
        ifn1 = gi_TubularBell_isine
        ifn2 = gi_TubularBell_icook3
        ifn3 = gi_TubularBell_isine
        ifn4 = gi_TubularBell_isine
        ivibefn = gi_TubularBell_icosine
        a_signal fmbell 1, i_frequency, iindex, gi_TubularBell_crossfade, gi_TubularBell_vibrato_depth, gi_TubularBell_vibrato_rate, ifn1, ifn2, ifn3, ifn4, ivibefn
        i_attack = .002
        i_sustain = i_duration
        i_release = 0.01
        ; As with most software instruments that are modeled on an impulse exciting a 
        ; resonator, there should be two envelopes. The "physical" envelope must have a 
        ; fixed decay ending at zero.
        i_declick_minimum = .001
        i_attack = .001 / i_frequency + i_declick_minimum
        i_exponent = 7
        a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
        ; The de-clicking envelope must have attack and release segments that damp 
        ; artifacts in the signal. The duration of these segments depends on 
        ; the behavior of the instrument, and may vary as a function of frequency.
        i_declick_attack = .004
        i_declick_release = i_declick_minimum * 2
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 1
        a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
        ; The envelope of the instrument is the product of the physical envelope times 
        ; the declicking envelope. 
        a_envelope = a_physical_envelope * a_declicking_envelope
        ; That envelope is then low-pass filtered to remove most discontinuities.
        a_filtered_envelope tonex a_envelope, 120, 4
        a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
        
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        
        gk_YiString_midi_dynamic_range chnexport "gk_YiString_midi_dynamic_range", 3 ;  127
        gk_YiString_level chnexport "gk_YiString_level", 3 ;  0
        gk_YiString_reverb_send chnexport "gk_YiString_reverb_send", 3 ;  .5
        gk_YiString_chorus_send chnexport "gk_YiString_chorus_send", 3 ;  .5
        gi_YiString_overlap chnexport "gi_YiString_overlap", 3 ;  .1
        
        gk_YiString_midi_dynamic_range init 20
        gk_YiString_level init 0
        gk_YiString_reverb_send init .5
        gk_YiString_chorus_send init .5
        gi_YiString_overlap init .1
        
        gk_YiString_space_left_to_right chnexport "gk_YiString_space_left_to_right", 3
        gk_YiString_space_left_to_right init .5
        
        instr YiString
        //////////////////////////////////////////////
        // Original by Steven Yi.
        // Adapted by Anonymous.
        //////////////////////////////////////////////
        i_instrument = p1
        i_time = p2
        ; Make indefinite notes last no longer than the physical decay.
        i_physical_duration = 20000
        if p3 == -1 then
        i_duration = i_physical_duration
        else
        i_duration = p3
        endif
        i_midi_key = p4
        i_midi_dynamic_range = i(gk_YiString_midi_dynamic_range)
        i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
        k_space_front_to_back = p6
        k_space_left_to_right = p7
        k_space_bottom_to_top = p8
        i_phase = p9
        i_frequency = cpsmidinn(i_midi_key)
        ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
        i_level_correction = 62.25
        i_normalization = ampdb(-i_level_correction) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        k_gain = ampdb(gk_YiString_level)
        iattack = gi_YiString_overlap
        isustain = i_duration
        idecay = gi_YiString_overlap
        xtratim 1
        a_physical_envelope transeg 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, idecay / 2.0, 1.5, i_amplitude / 2.0, idecay / 2.0, -1.5, 0
        ;ampenv = madsr:a(1, 0.1, 0.95, 0.5)
        a_signal = vco2(1, i_frequency)
        a_signal = moogladder(a_signal, 6000, 0.1)
        
        ; The de-clicking envelope must have attack and release segments that damp 
        ; artifacts in the signal. The duration of these segments depends on 
        ; the behavior of the instrument, and may vary as a function of frequency.
        i_declick_attack = iattack
        i_declick_release = i_declick_attack * 2
        ; The end of the note must be extended _past_ the end of the release segment.
        xtratim 1
        a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
        ; The envelope of the instrument is the product of the physical envelope times 
        ; the declicking envelope. 
        a_envelope = a_physical_envelope * a_declicking_envelope
        ; That envelope is then low-pass filtered to remove most discontinuities.
        a_filtered_envelope tonex a_envelope, 40, 4
        a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
        
        a_signal_reverb = a_signal * gk_YiString_reverb_send
        a_signal_chorus = a_signal * gk_YiString_chorus_send
        a_out_left, a_out_right pan2 a_signal_reverb, p7
        outleta "outleft", a_out_left
        outleta "outright",  a_out_right
        a_out_left, a_out_right pan2 a_signal_chorus, p7
        outleta "chorusleft", a_out_left 
        outleta "chorusright", a_out_right 
        ;printks "YiString         %9.4f  %9.4f\n", 0.5, a_out_left, a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        gk_Xing_level chnexport "gk_Xing_level", 3
        
        gk_Xing_level init 0
        
        gi_Xing_isine ftgen 0, 0, 65537, 10, 1
        
        instr Xing
        ; Author: Andrew Horner
        i_instrument = p1
        i_time = p2
        i_duration = p3
        i_midi_key = p4
        i_midi_velocity = p5
        k_space_front_to_back = p6
        k_space_left_to_right = p7
        k_space_bottom_to_top = p8
        i_phase = p9
        i_overall_amps = 75
        i_normalization = ampdb(-i_overall_amps) / 2
        i_amplitude = ampdb(i_midi_velocity) * i_normalization
        i_frequency = cpsmidinn(i_midi_key)
        k_gain = ampdb(gk_Xing_level)
        iinstrument = p1
        istarttime = p2
        ioctave = p4
        idur = p3
        kfreq = k(i_frequency)
        iamp = 1
        inorm = 32310
        aamp1 linseg 0,.001,5200,.001,800,.001,3000,.0025,1100,.002,2800,.0015,1500,.001,2100,.011,1600,.03,1400,.95,700,1,320,1,180,1,90,1,40,1,20,1,12,1,6,1,3,1,0,1,0
        adevamp1 linseg 0, .05, .3, idur - .05, 0
        adev1 poscil adevamp1, 6.7, gi_Xing_isine, .8
        amp1 = aamp1 * (1 + adev1)
        aamp2 linseg 0,.0009,22000,.0005,7300,.0009,11000,.0004,5500,.0006,15000,.0004,5500,.0008,2200,.055,7300,.02,8500,.38,5000,.5,300,.5,73,.5,5.,5,0,1,1
        adevamp2 linseg 0,.12,.5,idur-.12,0
        adev2 poscil adevamp2, 10.5, gi_Xing_isine, 0
        amp2 = aamp2 * (1 + adev2)
        aamp3 linseg 0,.001,3000,.001,1000,.0017,12000,.0013,3700,.001,12500,.0018,3000,.0012,1200,.001,1400,.0017,6000,.0023,200,.001,3000,.001,1200,.0015,8000,.001,1800,.0015,6000,.08,1200,.2,200,.2,40,.2,10,.4,0,1,0
        adevamp3 linseg 0, .02, .8, idur - .02, 0
        adev3 poscil adevamp3, 70, gi_Xing_isine ,0
        amp3 = aamp3 * (1 + adev3)
        awt1 poscil amp1, i_frequency, gi_Xing_isine
        awt2 poscil amp2, 2.7 * i_frequency, gi_Xing_isine
        awt3 poscil amp3, 4.95 * i_frequency, gi_Xing_isine
        asig = awt1 + awt2 + awt3
        arel linenr 1,0, idur, .06
        a_signal = asig * arel * (iamp / inorm)
        i_attack = .002
        i_sustain = p3
        i_release = 0.01
        xtratim i_attack + i_release
        a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
        a_signal = a_signal * i_amplitude * a_declicking * k_gain
        
        a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
        outleta "outleft", a_out_left
        outleta "outright", a_out_right
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
        
        gk_ReverbSC_feedback chnexport "gk_ReverbSC_feedback", 3
        gk_ReverbSC_wet chnexport "gk_ReverbSC_wet", 3
        gi_ReverbSC_delay_modulation chnexport "gi_ReverbSC_delay_modulation", 3
        gk_ReverbSC_frequency_cutoff chnexport "gk_ReverbSC_frequency_cutoff", 3
        
        gk_ReverbSC_feedback init 0.875
        gk_ReverbSC_wet init 0.5
        gi_ReverbSC_delay_modulation init 0.0075
        gk_ReverbSC_frequency_cutoff init 15000
        
        instr ReverbSC
        gk_ReverbSC_dry = 1.0 - gk_ReverbSC_wet
        aleftin init 0
        arightin init 0
        aleftout init 0
        arightout init 0
        aleftin inleta "inleft"
        arightin inleta "inright"
        aleftout, arightout reverbsc aleftin, arightin, gk_ReverbSC_feedback, gk_ReverbSC_frequency_cutoff, sr, gi_ReverbSC_delay_modulation
        aleftoutmix = aleftin * gk_ReverbSC_dry + aleftout * gk_ReverbSC_wet
        arightoutmix = arightin * gk_ReverbSC_dry + arightout * gk_ReverbSC_wet
        outleta "outleft", aleftoutmix
        outleta "outright", arightoutmix
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        endin
    
        gk_MasterOutput_level chnexport "gk_MasterOutput_level", 3 ; 0
        gk_Performance_seconds chnexport "gk_Performance_seconds", 3 ; 0
        gS_MasterOutput_filename chnexport "gS_MasterOutput_filename", 3 ; ""
        
        gk_MasterOutput_level init 0
        gk_Performance_seconds init 30
        gS_MasterOutput_filename init "2024-ICSC.wav"
    
        chn_k "gk_MasterOutput_output_level_left", 3
        chn_k "gk_MasterOutput_output_level_right", 3
        gk_record init 0

        instr MasterOutputOff
        i_MasterOutput_insno nstrnum "MasterOutput"
        k_triggered init 0
        if gk_Performance_seconds > 0 && k_triggered == 0 then
        k_time times
        if k_time >= gk_Performance_seconds then
        turnoff2 i_MasterOutput_insno, 0, 1
        k_triggered = 1
        printks "Turning off insno: %d  gk_Performance_seconds: %9.4f  k_time: %9.4f...\n", 1, i_MasterOutput_insno, gk_Performance_seconds, k_time
        endif
        endif
        endin
    
        instr MasterOutput
        aleft inleta "inleft"
        aright inleta "inright"
        k_gain = ampdb(gk_MasterOutput_level)
        printks2 "Master gain: %f\n", k_gain
        iamp init 1
        aleft butterlp aleft, 18000
        aright butterlp aright, 18000
        a_out_left = aleft * k_gain
        a_out_right = aright * k_gain
        i_duration = p3

        ; We need a toggle for recording/pausing.
    
        gk_record chnget "gk_record"
        
        if gk_record == 1 then 
        prints sprintf("Recording to output filename: %s\n", gS_MasterOutput_filename)
        fout gS_MasterOutput_filename, 19, a_out_left, a_out_right
        else 
        prints "Not recording.\n"
        endif
        
        prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
        gk_MasterOutput_output_level_left = dbfsamp(rms(a_out_left))
        gk_MasterOutput_output_level_right = dbfsamp(rms(a_out_right))
        chnset gk_MasterOutput_output_level_left, "gk_MasterOutput_output_level_left"
        chnset gk_MasterOutput_output_level_right, "gk_MasterOutput_output_level_right"
        // printks "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), gk_MasterOutput_output_level_left, gk_MasterOutput_output_level_right
        // Use a fade-in, fade-out envelope.
        // kres cossegr ia, idur1, ib [, idur2] [, ic] [...], irel, iz
        k_envelope linsegr 0, 6, 1, 1000000000, 1, 6, 0
        outs a_out_left * k_envelope, a_out_right * k_envelope
        endin

          </CsInstruments>
          <CsScore>
          f 0 [ 3 * 60 + 45]
          </CsScore>
        </CsoundSynthesizer>
    </textarea>
    <script id="draw-shader-fs" type="x-shader/x-fragment">#version 300 es
        #line 1881
        precision highp float;
        /**
         * These are all of the standard ShaderToy inputs. If any of these are 
         * used in this shader, they must be created and initialized in the 
         * JavaScript code.
         */
        uniform vec3 iResolution;
        // viewport resolution (in pixels)
        uniform float iTime;
        // shader playback time (in seconds)
        uniform float iTimeDelta;
        // render time (in seconds)
        uniform int iFrame;
        // shader playback frame
        uniform float iChannelTime[4];
        // channel playback time (in seconds)
        uniform vec3 iChannelResolution[4];
        // channel resolution (in pixels)
        uniform vec4 iMouse;
        // mouse pixel coords. xy: current (if MLB down), zw: click
        uniform sampler2D iChannel0;
        // input channel. XX = 2D/Cube
        uniform sampler2D iChannel1;
        // input channel. XX = 2D/Cube
        uniform sampler2D iChannel2;
        // input channel. XX = 2D/Cube
        uniform sampler2D iChannel3;
        // input channel. XX = 2D/Cube
        uniform vec4 iDate;
        // (year, month, day, time in seconds)
        uniform float iSampleRate;
        // sound sample rate (i.e., 44100)

        uniform float GraphicsTempo;
        uniform float GraphicsHue;
        uniform float GraphicsValue;
        
        /**
         * Theoretically, any fragment shader copied from the ShaderToy 
         * editor can replace the body of the mainImage function below, 
         * if all inputs actually used in the shader are defined and bound.
         */

        void mainImage(out vec4 _ufragColor, in vec2 _ufragCoord);
        out vec4 _ushadertoy_out_color;
        void main(){
          (_ushadertoy_out_color = vec4(0.0, 0.0, 0.0, 0.0));
          (_ushadertoy_out_color = vec4(1.0, 1.0, 1.0, 1.0));
          vec4 _ucolor = vec4(0.0, 0.0, 0.0, 1.0);
          mainImage(_ucolor, gl_FragCoord.xy);
          if ((_ushadertoy_out_color.x < 0.0))
          {
            (_ucolor = vec4(1.0, 0.0, 0.0, 1.0));
          }
          if ((_ushadertoy_out_color.y < 0.0))
          {
            (_ucolor = vec4(0.0, 1.0, 0.0, 1.0));
          }
          if ((_ushadertoy_out_color.z < 0.0))
          {
            (_ucolor = vec4(0.0, 0.0, 1.0, 1.0));
          }
          if ((_ushadertoy_out_color.w < 0.0))
          {
            (_ucolor = vec4(1.0, 1.0, 0.0, 1.0));
          }
          (_ushadertoy_out_color = vec4(_ucolor.xyz, 1.0));
        }
        float hash(int x) { return fract(sin(float(x))*7.847); } 

        float dSegment(vec2 a, vec2 b, vec2 c)
        {
            vec2 ab = b-a;
            vec2 ac = c-a;
            float h = clamp(dot(ab, ac)/dot(ab, ab), 0., 1.);
            vec2 point = a+ab*h;
            return length(c-point);
        }

vec2 triangle_wave(vec2 a){
    ///return abs(fract((a+vec2(1.,0.5))*1.5)-.5);
    return abs(fract((a*.9+vec2(1.,0.75))*1.75)-.325);
}

vec3 rgb2hsv(vec3 c){
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c){
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 palette(float t)
{
    // A less bilious palette?
    vec3 a = vec3(0.938, 0.328, 0.718);
    vec3 b = vec3(0.659, 0.438, 0.328);
    vec3 c = vec3(0.388, 0.388, 0.296);
    vec3 d = vec3(2.538, 2.478, 0.168);
    ////vec3 a = vec3(0.75, 0.528, 0.718);
    ////vec3 b = vec3(0.659, .438, 1.328);
    ////vec3 c = vec3(0.388, 0.788, 0.5);
    ////vec3 d = vec3(2.538, 2.478, 0.168);
    return a + b*cos( 6.28318*(c*t+d) );
}

vec2 rotateUV(vec2 uv, float rotation){
    float mid = 0.5;
    ////float mid = 0.25;
    return vec2(
        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,
        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid
    );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ){
    vec2 uv = (fragCoord * 1.0 - iResolution.xy) / iResolution.y;
    vec2 uv0 = uv;
    vec3 finalColour = vec3(0.);

    // Slow it down...
    // Put a control on speed.
    float GraphicsTempo_ = iTime * GraphicsTempo;
    
    // It would be nice to put a control on overall rotation or tilt.
    ///for (float i = 0.; i < 36.; i++)
    for (float i = 0.; i < 72.; i++)
    {
        uv = rotateUV(uv, GraphicsTempo_*.1);
        uv = fract(uv*1.1)-.5;
        uv = rotateUV(uv, GraphicsTempo_*.1);
        float d = length(uv);
        vec3 col = palette(length(uv0) + i*.1 + d + GraphicsTempo_);
        d = sin(d*4.+GraphicsTempo_)/4.;
        d = abs(d);            
        d = .02/d;
        ////d = .01/d;
        finalColour += col * d * .1 - (i*.0002);
    }
    vec3 hsv_ = rgb2hsv(finalColour);
    // Put controls on value and hue.
    hsv_[2] = hsv_[2] * GraphicsValue;
    hsv_[0] = hsv_[0] * GraphicsHue;
    finalColour = hsv2rgb(hsv_);
    fragColor = vec4(finalColour,1.0);
    //fragColor = vec4(uv.x,uv.y,0.,1.0);
}

    </script>
    <cloud5-piece></cloud5-piece>
    <cloud5-strudel></cloud5-strudel>
    <cloud5-shadertoy></cloud5-shadertoy>
    <cloud5-log></cloud5-log>
    <cloud5-about>
        <div>
            <h1 style="font-size: 15px;">cloud5-example-visual-music</h1>
            <h2 style="font-size: 13px">Anonymous<br>
                March 2024</h2>

            <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img
                    alt="Creative Commons License" style="border-width:0;" src="cc-by-nc-sa.png" /></a>
            <p>This work is licensed under a <a rel="license"
                    href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons
                    Attribution-NonCommercial-ShareAlike 3.0 Unported License.</a>

            <p>This is an online piece of electroacoustic music, rendered in your Web
                browser using high-resolution audio. It will play indefinitely, never ending,
                always changing.

            <p>The notes are played by a Csound orchestra that is embedded in this Web page using a <a
                    href="https://github.com/gogins/csound-wasm">WebAssembly build of Csound</a>. This in turn includes
                the
                <a href="https://github.com/gogins/csound-ac">CsoundAC</a> library for algorithmic composition, used in
                this
                piece to generate randomly selected but (I hope) musically sensible chord progressions and modulations
                that
                are applied to the generated notes.

            <p>The music is generated by sampling the bottom row of pixels from the moving image, downsampling that row
                into
                fewer pixels, and translating those pixels into musical notes from left (lowest) to right (highest). Hue
                is
                mapped to instrument, saturation is mapped to duration, and value is mapped to loudness. Generally
                speaking,
                when a bright ring moves to the bottom of the the display, you should hear some notes generated by that
                event.

            <p>The viewer may exercise a certain amount of control over the piece by opening the <i>Controls</i>.
                Changing
                the hue will change the arrangement of instruments. The tempo of both note generation and the visuals
                may be controlled.

            <p>When the user clicks on the <i>Record</i> button, the "fout" opcode is used to record the live audio
                to memory in the browser. When the user clicks on <i>Pause</i>, the recorded
                audio will automatically be downloaded to the user's downloads directory. Such recording may be
                restarted
                and paused again any number of times. This can be used in place of an audio loopback interface to make
                a soundfile from a performance.

            <p>This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
                License
                (https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en)

            <p>Feel free to use this piece as a template for creating new pieces of this type... as long as it doesn't
                sound
                too much like this one!

            <ul>
                <li>To view the source code of this piece, use your browser menu to view the page source.
                <li>To inspect or debug the code of this piece as it runs, use your browser menu to open the developer
                    tools.
            </ul>

            <h2 style="font-size: 13px;">Credits</h2>

            <p>I created the visuals for this piece by adapting Scruffy's
                <a href="https://www.shadertoy.com/view/4fXSRn"><i>TestShader09012024</i></a>,
                which has an open-source license compatible with the license of this piece.

            <p>My code in CsoundAC for working with chords, scales, and voice-leading implements basic ideas from <a
                    href="http://dmitri.tymoczko.com/">Dmitri Tymoczko's work in music theory</a>.

            <p>Code for compiling and controlling shaders is adapted from <a
                    href="https://www.shadertoy.com">ShaderToy.com</a>.

            <p>The algorithm for downsampling the video canvas is from <a
                    href="https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf">Sveinn Steinarsson's MS thesis</a>
                with
                code from <a
                    href="https://github.com/pingec/downsample-lttb">https://github.com/pingec/downsample-lttb</a>.

            <p>Csound instruments are adapted from <a href="https://kunstmusik.com/">Steven Yi</a> (YiString and
                FMWaterBell), Joseph T. Kung (Kung2 and Kung4), <a href="http://www.jlpublishing.com/">Lee Zakian</a>
                (ZakianFlute), and others.

            <p>

    </cloud5-about>
    <script>
        let cloud5_piece = document.querySelector('cloud5-piece');
        let host = cloud5_piece;
        // #region Csound Code
        cloud5_piece.csound_code_addon = document.querySelector('#csd').value;
        // #endregion
        // #region Strudel
cloud5_piece.strudel_overlay = document.querySelector('cloud5-strudel');
cloud5_piece.strudel_overlay.strudel_code_addon = `
const csac = await import('../csoundac.mjs');
csac.diagnostic_level(csac.INFORMATION);
let hue = new csac.Cloud5('GraphicsHue');
pure(0)
  .control(hue, "<.1 .8>".slow(8))
    `;
        // #endregion
        // #region Controls 
        cloud5_piece.control_parameters_addon = {
            "NoteTempo": 15,
            "VelocityThreshold": 50,
            "NoteDurationFactor": 6,
            "GraphicsTempo": 0.24234484175914509,
            "GraphicsHue": 0.2722975750102754,
            "GraphicsValue": 0.035552815454171806,
            "CanonDelay": 0,
            "CanonTranspose": 0,
            "gk_Duration_factor": 0.8682696259761612,
            "gk_Performance_seconds": 600,
            "gk_Iterations": 4,
            "gk_MasterOutput_level": 2.882540335011818,
            "gk_ReverbSC_wet": 0.5,
            "gk_ReverbSC_feedback": 0.85,
            "gk_ReverbSC_delay_modulation": 0.0075,
            "gk_ReverbSC_frequency_cutoff": 9000,
            "gk_Blower_level": -29.344363374781626,
            "gk_Blower_attack": 1.5,
            "gk_Blower_release": 2,
            "gk_Blower_grainDensity": 245.730140787175,
            "gk_Blower_grainDuration": 0.03750899188161545,
            "gk_Blower_grainAmplitudeRange": 119.4532935977803,
            "gk_Blower_grainFrequencyRange": 50.251772685232766,
            "gk_Bower_level": -10.271297913883465,
            "gk_Bower_pressure": 4.715856540951598,
            "gk_Bower_rat": 0.4518548967218169,
            "gk_Buzzer_level": -26.71359572500257,
            "gk_Buzzer_harmonics": 1.3688212927756656,
            "gk_Droner_level": -14.217449388552048,
            "gk_Droner_partial1": 0.12105641763436441,
            "gk_Droner_partial2": 0.22628712362552666,
            "gk_Droner_partial3": 0.6406330284657281,
            "gk_Droner_partial4": 0.11447949850991676,
            "gk_Droner_partial5": 0,
            "gk_FilteredSines_level": -3.6943787894358238,
            "gk_ZakianFlute_level": -22.767444250333984,
            "gk_FMWaterBell_level": 0.9094645976775197,
            "gi_FMWaterBell_attack": 0.002,
            "gi_FMWaterBell_release": 0.01,
            "gi_FMWaterBell_exponent": 15,
            "gi_FMWaterBell_sustain": 20,
            "gi_FMWaterBell_sustain_level": 0.1,
            "gk_FMWaterBell_crossfade": 0.5,
            "gk_FMWaterBell_index": 0.5,
            "gk_FMWaterBell_vibrato_depth": 0.05,
            "gk_FMWaterBell_vibrato_rate": 6,
            "gk_Guitar_level": 0,
            "gk_Kung2_level": 3.534730785039045,
            "gk_Kung4_level": -16.19052512588634,
            "gk_Phaser_level": -21.452060425444458,
            "gk_Phaser_ratio1": 2,
            "gk_Phaser_ratio2": 3,
            "gk_Phaser_index1": 1.0266159695817492,
            "gk_Phaser_index2": 0.533347035248176,
            "gk_Plucked_level": 35.10944404480526,
            "gk_Shiner_level": -16.848217038331107,
            "gk_Shiner_attack": 0.125,
            "gk_Shiner_release": 0.5,
            "gk_SeidelHarmonicOsc_level": 0,
            "gk_Sweeper_level": -15.532833213441577,
            "gk_Sweeper_britel": 0.22114890555955194,
            "gk_Sweeper_briteh": 2.4309937313739596,
            "gk_Sweeper_britels": 0.3526872880485048,
            "gk_Sweeper_britehs": 0.7473024355153632,
            "gk_TubularBell_level": -6.982838351659645,
            "gk_YiString_level": 0,
            "gk_Xing_level": 0
        };

        let Composition = cloud5_piece.menu_folder_addon('Composition');
        cloud5_piece.menu_slider_addon(Composition, "gk_Performance_seconds", -1., 1200., .0001, "Duration");
        cloud5_piece.menu_slider_addon(Composition, "NoteTempo", 0, 200, .0001, "Music tempo [Ctl-Alt-T]");
        cloud5_piece.menu_slider_addon(Composition, "VelocityThreshold", 5, 200, .0001, "Velocity cutoff [Ctl-Alt-C]");
        cloud5_piece.menu_slider_addon(Composition, "NoteDurationFactor", 0., 5., .0001, "Note duration factor [Ctl-Alt-F]");
        cloud5_piece.menu_slider_addon(Composition, "GraphicsTempo", .0, .25, .0001, "Visual tempo [Ctl-Alt-V]");
        cloud5_piece.menu_slider_addon(Composition, "GraphicsHue", 0., 1., .0001, "Hue [Ctl-Alt-H]");
        cloud5_piece.menu_slider_addon(Composition, "GraphicsValue", 0., 1., .0001, "Brightness [Ctl-Alt-B]");
        cloud5_piece.menu_slider_addon(Composition, "CanonDelay", 0., 5., .001, "Canon delay [Ctl-Alt-D]");
        cloud5_piece.menu_slider_addon(Composition, "CanonTranspose", -12., 12., 1, "Canon interval [Ctl-Alt-I]");
        let Master = cloud5_piece.menu_folder_addon('Master'); .2
        cloud5_piece.menu_slider_addon(Master, 'gk_MasterOutput_level', -50, 50);
        cloud5_piece.menu_slider_addon(Master, 'gk_Iterations', 2., 9., 1.);
        cloud5_piece.menu_slider_addon(Master, 'gk_Duration_factor', 0., 5.);
        cloud5_piece.menu_slider_addon(Master, 'gk_ReverbSC_feedback', 0., 1.);
        cloud5_piece.menu_slider_addon(Master, 'gk_ReverbSC_wet', 0., 1.);
        cloud5_piece.menu_slider_addon(Master, 'gk_ReverbSC_delay_modulation', 0., 1.);
        cloud5_piece.menu_slider_addon(Master, 'gk_ReverbSC_frequency_cutoff', 0., 20000.);
        var Blower = cloud5_piece.menu_folder_addon('Blower');
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_level', -50, 50);
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_attack', 0, 2);
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_release', 0, 4);
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_grainDensity', 0, 400);
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_grainDuration', 0, .5);
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_grainAmplitudeRange', 0, 400);
        cloud5_piece.menu_slider_addon(Blower, 'gk_Blower_grainFrequencyRange', 0, 100);
        var Bower = cloud5_piece.menu_folder_addon('Bower');
        cloud5_piece.menu_slider_addon(Bower, 'gk_Bower_level', -50, 50);
        cloud5_piece.menu_slider_addon(Bower, 'gk_Bower_pressure', 0, 5);
        cloud5_piece.menu_slider_addon(Bower, 'gk_Bower_rat', 0, .5);
        var Buzzer = cloud5_piece.menu_folder_addon('Buzzer');
        cloud5_piece.menu_slider_addon(Buzzer, 'gk_Buzzer_level', -50, 50);
        cloud5_piece.menu_slider_addon(Buzzer, 'gk_Buzzer_harmonics', 0, 20);
        var Droner = cloud5_piece.menu_folder_addon('Droner');
        cloud5_piece.menu_slider_addon(Droner, 'gk_Droner_level', -50, 50);
        cloud5_piece.menu_slider_addon(Droner, 'gk_Droner_partial1', 0, 1);
        cloud5_piece.menu_slider_addon(Droner, 'gk_Droner_partial2', 0, 1);
        cloud5_piece.menu_slider_addon(Droner, 'gk_Droner_partial3', 0, 1);
        cloud5_piece.menu_slider_addon(Droner, 'gk_Droner_partial4', 0, 1);
        cloud5_piece.menu_slider_addon(Droner, 'gk_Droner_partial5', 0, 1);
        var FilteredSines = cloud5_piece.menu_folder_addon('Filtered Sines');
        cloud5_piece.menu_slider_addon(FilteredSines, 'gk_FilteredSines_level', -50, 50);
        var Flute = cloud5_piece.menu_folder_addon('Zakian Flute');
        cloud5_piece.menu_slider_addon(Flute, 'gk_ZakianFlute_level', -50, 50);
        var FMWaterBell = cloud5_piece.menu_folder_addon('FMWaterBell');
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gk_FMWaterBell_level', -50, 50);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gi_FMWaterBell_attack', 0, .1);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gi_FMWaterBell_release', 0, .1);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gi_FMWaterBell_exponent', -30, 30);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gi_FMWaterBell_sustain', 0, 20);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gi_FMWaterBell_sustain_level', 0, 1);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 1);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gk_FMWaterBell_index', 0, 15);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gk_FMWaterBell_vibrato_depth', 0, 10);
        cloud5_piece.menu_slider_addon(FMWaterBell, 'gk_FMWaterBell_vibrato_rate', 0, 10);
        var Guitar = cloud5_piece.menu_folder_addon('Guitar');
        cloud5_piece.menu_slider_addon(Guitar, 'gk_Guitar_level', -50, 50);
        var Kung2 = cloud5_piece.menu_folder_addon('Kung2');
        cloud5_piece.menu_slider_addon(Kung2, 'gk_Kung2_level', -50, 50);
        var Kung4 = cloud5_piece.menu_folder_addon('Kung4');
        cloud5_piece.menu_slider_addon(Kung4, 'gk_Kung4_level', -50, 50);
        var Phaser = cloud5_piece.menu_folder_addon('Phaser');
        cloud5_piece.menu_slider_addon(Phaser, 'gk_Phaser_level', -50, 50);
        cloud5_piece.menu_slider_addon(Phaser, 'gk_Phaser_ratio1', 0, 5);
        cloud5_piece.menu_slider_addon(Phaser, 'gk_Phaser_ratio2', 0, 5);
        cloud5_piece.menu_slider_addon(Phaser, 'gk_Phaser_index1', 0, 15);
        cloud5_piece.menu_slider_addon(Phaser, 'gk_Phaser_index2', 0, 15);
        var Plucked = cloud5_piece.menu_folder_addon('Plucked');
        cloud5_piece.menu_slider_addon(Plucked, 'gk_Plucked_level', -50, 50);
        var Shiner = cloud5_piece.menu_folder_addon('Shiner');
        cloud5_piece.menu_slider_addon(Shiner, 'gk_Shiner_level', -50, 50);
        cloud5_piece.menu_slider_addon(Shiner, 'gk_Shiner_attack', 0, 1);
        cloud5_piece.menu_slider_addon(Shiner, 'gk_Shiner_release', 0, 4);
        var SeidelHarmonicOsc = cloud5_piece.menu_folder_addon('SeidelHarmonicOsc');
        cloud5_piece.menu_slider_addon(SeidelHarmonicOsc, 'gk_SeidelHarmonicOsc_level', -50, 50);
        var Sweeper = cloud5_piece.menu_folder_addon('Sweeper');
        cloud5_piece.menu_slider_addon(Sweeper, 'gk_Sweeper_level', -50, 50);
        cloud5_piece.menu_slider_addon(Sweeper, 'gk_Sweeper_britel', 0, 4);
        cloud5_piece.menu_slider_addon(Sweeper, 'gk_Sweeper_briteh', 0, 4);
        cloud5_piece.menu_slider_addon(Sweeper, 'gk_Sweeper_britels', 0, 4);
        cloud5_piece.menu_slider_addon(Sweeper, 'gk_Sweeper_britehs', 0, 4);
        var TubularBell = cloud5_piece.menu_folder_addon('TubularBell');
        cloud5_piece.menu_slider_addon(TubularBell, 'gk_TubularBell_level', -50, 50);
        var YiString = cloud5_piece.menu_folder_addon('YiString');
        cloud5_piece.menu_slider_addon(YiString, 'gk_YiString_level', -50, 50);
        var Xing = cloud5_piece.menu_folder_addon('Xing');
        cloud5_piece.menu_slider_addon(Xing, 'gk_Xing_level', -50, 50);
        // Override default width of controls.
        cloud5_piece.gui.domElement.style.width="500px";
        cloud5_piece.strudel_overlay.control_parameters_addon = cloud5_piece.control_parameters_addon;

        // #endregion
        // #region Shader
        let cloud5_shader = document.querySelector('cloud5-shadertoy');
        // The basic method here is to extend just this one instance of 
        // Cloud5ShaderToy with new class member veriables and functions 
        // for turning video samples into notes. Of course, the custom 
        // <cloud5-shader-toy> element could simply be subclassed.
        cloud5_shader.current_time = 0;
        cloud5_shader.prior_time = 0;
        cloud5_shader.next_time = 0;
        cloud5_shader.instrument_count = 8;
        cloud5_shader.sampled_events = new Array();
        cloud5_shader.playlist = new Map();
        // Put a control on this.
        cloud5_shader.gi_Composition_tempo = 25;
        cloud5_shader.frame_translation_count = 0;
        cloud5_shader.midi_key_begin = 36;
        cloud5_shader.midi_key_range = 60;
        cloud5_shader.maximum_voices = 8;
        // Put a control on this.
        cloud5_shader.event_velocity_threshold = 100;
        cloud5_shader.midi_key_end = this.midi_key_begin + this.midi_key_range;
        cloud5_shader.sample_count = 0;
        cloud5_shader.root_progression = 0;
        cloud5_shader.on_events = new Array();
        cloud5_shader.off_events = new Array();
        cloud5_shader.playing_events = new Map();
        cloud5_shader.event_tag = 0;
        // cloud5_shader.root_progressions = [2, 3, -4, 5, -1, 3];
        // Maybe try a list of lists?
        cloud5_shader.root_progressions = [-3, 2, 1, 5];
        cloud5_shader.translate_sample_to_csound_events = async function translate_sample_to_csound_events(maximum_events, threshold, parent_rendering_frame) {
            if (this.cloud5_piece.csound) {
            } else {
                return;
            }
            if (this.CsoundAC) {
            } else {
                this.CsoundAC = await createCsoundAC();
                this.score = new this.CsoundAC.Score();
                this.scale = new this.CsoundAC.Scale('F major');
                this.chord = this.scale.chord(1, 4, 3);
            }
            if (this.cloud5_piece.csound.GetScoreTime() <= 0) {
                return;
            }
            let x = 0;
            // y is zero at the bottom of the canvas.
            let y = 0;
            let width = this.canvas.width;
            let height = 1;
            let format = this.gl.RGBA;
            let type = this.gl.UNSIGNED_BYTE;
            read_pixels_async(this.gl, x, y, width, height, format, type, this.image_sample_buffer);
            // Translate the sample format from byte RGBA to float HSV.
            // The the raw bytes in the buffer are transformed to [[sample index, value, hsv],...].
            let hsv_image_sample = [];
            for (let byte_i = 0; byte_i < this.image_sample_buffer.length; byte_i = byte_i + 4) {
                let rgb = this.image_sample_buffer.slice(byte_i, byte_i + 3);
                let hsv = rgb_to_hsv(rgb);
                hsv_image_sample.push([hsv_image_sample.length + 1, hsv[2], hsv]);
            }
            // Downsample the HSV samples.
            // hsv_image_sample is [[column, value, [h,s,v]]],...]; 
            // downsampled_pixels is the error-minimizing piecewise 
            // approimation of the sample with N buckets in the 
            // same layout, thus only a subset of the columns.
            let downsampled_pixels = downsample_lttb(hsv_image_sample, this.midi_key_range);
            this.sampled_events.length = 0;
            this.on_events.length = 0;
            this.off_events.length = 0;
            this.score.clear();
            // Translate the HSV samples to Csound event vectors.
            // 0 is p1 insno (hsv[0](, tagged by downsampled pixel, 
            //   positive for on or negative for off.
            // 1 is p2 time always 0.
            // 2 is p3 duration (either hsv[1] or -1, must be 0 for off
            //   events).
            // 3 is p4 MIDI key (bucket index).
            // 4 is p5 MIDI velocity (hsv[2]).
            for (let downsampled_pixel_i = 0; downsampled_pixel_i < downsampled_pixels.length; downsampled_pixel_i++) {
                let hsv = downsampled_pixels[downsampled_pixel_i][2];
                let instrument_number = 1 + (hsv[0] * this.instrument_count);
                let time = 0;
                // Maybe arpeggiate off NoteTempo.
                // Better yet, canons at intervals and rhythms.
                // let duration = (.25 + (60 / this.cloud5_piece.control_parameters_addon.NoteTempo * hsv[1] * 2)) * this.cloud5_piece.control_parameters_addon.NoteDurationFactor;
                let duration = (.25 + this.cloud5_piece.control_parameters_addon.NoteDurationFactor);
                // The instrument number must have a unique fractional tag.
                let midi_key = Math.floor(this.midi_key_begin + downsampled_pixel_i);
                //instrument_number = 4;
                let insno = sprintf("%d.%d", Math.floor(instrument_number), midi_key);
                instrument_number = parseFloat(insno);
                let midi_velocity = hsv[2] * 128;
                let event_for_pixel = [instrument_number, time, duration, midi_key, midi_velocity];
                this.sampled_events.push(event_for_pixel);
            }
            console.info(sprintf("sampled_events.length: %d\n", this.sampled_events.length));
            // Events that are playing but not loud enough, are turned off.
            for (let sampled_event_i = 0; sampled_event_i < this.sampled_events.length; sampled_event_i++) {
                let sampled_event = this.sampled_events[sampled_event_i];
                let key = sampled_event[0];
                if (this.playing_events.has(key) == true) {
                    let off_event = this.playing_events.get(key);
                    let instrument_number = off_event[0];
                    if (sampled_event[4] < threshold) {
                        this.cloud5_piece.csound.KillInstance(instrument_number, "", 4, true);
                        console.info("Turned off instrument number: " + instrument_number + ".");
                        this.playing_events.delete(key);
                    }
                }
            }
            console.info(sprintf("playing_events.size:   %d\n", this.playing_events.size));
            // Events that are loud enough but not playing, are turned on.
            for (let sampled_event_i = 0; sampled_event_i < this.sampled_events.length; sampled_event_i++) {
                let sampled_event = this.sampled_events[sampled_event_i];
                let key = sampled_event[0];
                if (this.playing_events.has(key) == false) {
                    if (sampled_event[4] >= threshold) {
                        this.playing_events.set(key, sampled_event);
                        this.on_events.push(sampled_event);
                    }
                }
            }
            console.info(sprintf("playing_events.size:   %d\n", this.playing_events.size));
            console.info(sprintf("on_events.length:      %d\n", this.on_events.length));
            this.CsoundAC.setCorrectNegativeDurations(false);
            // Limit number of on events, play N loudest only. Could also pick at random.
            this.on_events.sort(function (a, b) {
                if (a[5] < b[5]) {
                    return 1;
                }
                if (b[5] < a[5]) {
                    return -1;
                }
                return 0;
            });
            let voices = Math.min(this.on_events.length, this.maximum_voices);
            for (let i = 0; i < voices; i++) {
                let on_event = this.on_events[i];
                let time = 0;
                let duration = on_event[2];
                let status = 144;
                let instrument_number = on_event[0];
                ///let instrument_number = 8;
                let key = on_event[3];
                let velocity = on_event[4];
                velocity = 60 + (velocity / 7);
                let phase = 0;
                let pan = .01 + Math.random() * .8;
                let depth = 0;
                let height = 0;
                let pitches = 4095;
                this.score.add(time, duration, status, instrument_number, key, velocity, phase, pan, depth, height, pitches);
            }
            if (this.score.size() > 0) {
                if (this.sample_count % 4 == 0) {
                    if (this.sample_count % 12 == 0) {
                        let scales = this.scale.modulations(this.chord);
                        if (scales.size() > 1) {
                            this.scale = scales.get(Math.floor(Math.random() * scales.size()));
                            this.cloud5_piece.log(sprintf("\nScale: %s\n", this.scale.name()));
                        }
                    }
                    let root_progression = this.root_progressions[Math.floor(Math.random() * this.root_progressions.length)];
                    let chord_name = this.chord.eOP().name();
                    if (chord_name.length == 0) {
                        chord_name = this.chord.eOP().toString();
                    }
                    this.cloud5_piece.log(sprintf("\nChord: %s => ", chord_name));
                    this.chord = this.scale.transpose_degrees(this.chord, root_progression, 3)
                    chord_name = this.chord.eOP().name();
                    if (chord_name.length == 0) {
                        chord_name = this.chord.eOP().toString();
                    }
                    this.cloud5_piece.log(sprintf("%s\n\n", chord_name));
                }
                let score_text;
                if (this.cloud5_piece.control_parameters_addon.CanonDelay > 0) {
                    this.cloud5_piece.log("Current: " + this.score.getCsoundScore(12., true) + "\n")
                    this.score = canon(this.CsoundAC, this.score, this.cloud5_piece.control_parameters_addon.CanonDelay, this.cloud5_piece.control_parameters_addon.CanonTranspose, this.scale);
                    this.CsoundAC.apply(this.score, this.chord, 0, 1000000, true);
                    score_text = this.score.getCsoundScore(12., true);
                    this.cloud5_piece.log("Canon:  " + score_text + "\n\n")
                } else {
                    this.CsoundAC.apply(this.score, this.chord, 0, 1000000, true);
                    score_text = this.score.getCsoundScore(12., true);
                }
                this.cloud5_piece.csound.ReadScore(score_text);
            }
            this.sample_count++;
        }.bind(cloud5_shader);
        cloud5_shader['sample_canvas'] = async function (current_rendering_frame) {
            /** 
             * As the last step in rendering the scene, this function reads 
             * the bottommost row of the canvas (the sample) into an array of 
             * pixels, then translates that row into a set of Csound events, 
             * the mapping determined by a separate function. An attempt is 
             * made to avoid stalling the WebGL rendering pipeline by reading 
             * the pixels from the canvas only when a memory fence around the 
             * GPU pipeline becomes passable.
             */
            //console.info("frame_sample_to_score.");
            let parameters = this.cloud5_piece.control_parameters_addon;
            let gi_Composition_tempo = Math.floor(parseFloat(parameters.NoteTempo));
            let event_velocity_threshold = parseFloat(parameters.VelocityThreshold);
            await this.translate_sample_to_csound_events(16, event_velocity_threshold, current_rendering_frame);
        }.bind(cloud5_shader);
        let fragment_shader = document.getElementById('draw-shader-fs').textContent;
        cloud5_shader.shader_parameters_addon = {
            fragment_shader_code_addon: fragment_shader,
            pre_draw_frame_function_addon: (function () {
                if (this.analyser) {
                    let spectral_tilt = 0;
                    let total_loudness = 0;
                    this.analyser.getByteFrequencyData(this.frequency_domain_data);
                    for (let i = 0; i < this.frequency_domain_data.length; ++i) {
                        let sample = this.frequency_domain_data[i];
                        // Map frequency domain magnitudes from [0, 255] to [0, 1].
                        sample = sample / 255.;
                        // Reddest is 0, violet is 1.
                        let blueness = i / this.frequency_domain_data.length;
                        spectral_tilt += (sample * blueness);
                        total_loudness += sample;
                    }
                    // Spectral tilt is normalized by loudness.
                    spectral_tilt /= total_loudness;
                    total_loudness /= 100.;
                    /// console.info(`tilt: ${spectral_tilt} loudness: ${total_loudness}`);
                    // Set the uniforms.
                    let spectral_tilt_location = this.uniform_locations['spectral_tilt'];
                    this.gl.uniform1f(spectral_tilt_location, spectral_tilt);
                    let total_loudness_location = this.uniform_locations['total_loudness'];
                    this.gl.uniform1f(total_loudness_location, total_loudness);
                }
                let parameters = this.cloud5_piece.control_parameters_addon;
                let GraphicsTempo_location = this.uniform_locations['GraphicsTempo'];
                this.gl.uniform1f(GraphicsTempo_location, parameters.GraphicsTempo);
                let GraphicsHue_location = this.uniform_locations['GraphicsHue'];
                this.gl.uniform1f(GraphicsHue_location, parameters.GraphicsHue);
                let GraphicsValue_location = this.uniform_locations['GraphicsValue'];
                this.gl.uniform1f(GraphicsValue_location, parameters.GraphicsValue);
            }).bind(cloud5_shader),
            post_draw_frame_function_addon: (function () {
                this.prior_time = this.current_time;
                this.current_time = performance.now() / 1000;
                if (this.current_time >= this.next_time) {
                    this.next_time = this.current_time + (60 / this.cloud5_piece.control_parameters_addon.NoteTempo);
                    this.sample_canvas(this.rendering_frame);
                }
            }).bind(cloud5_shader),
        };
        cloud5_piece.shader_overlay = cloud5_shader;
        // #endregion
        // #region Log
        let cloud5_log = document.querySelector('cloud5-log');
        cloud5_piece.log_overlay = cloud5_log;
        // #endregion
        // #region About
        let cloud5_about = document.querySelector('cloud5-about');
        cloud5_piece.about_overlay = cloud5_about;
        // #endregion
        /**
         * Enable the user to control compositional parameters using keys only, 
         * especially when in full screen mode.
        cloud5_piece.menu_slider_addon(Composition, "gk_Performance_seconds", -1., 1200., .0001, "Duration");
        cloud5_piece.menu_slider_addon(Composition, "NoteTempo", 0, 200, .0001, "Music tempo [Ctl-Alt-T]");
        cloud5_piece.menu_slider_addon(Composition, "VelocityThreshold", 5, 200, .0001, "Velocity cutoff [Ctl-Alt-C]");
        cloud5_piece.menu_slider_addon(Composition, "NoteDurationFactor", 0., 5., .0001, "Note duration factor [Ctl-Alt-F]");
        cloud5_piece.menu_slider_addon(Composition, "GraphicsTempo", .0, .25, .0001, "Visual tempo [Ctl-Alt-V]");
        cloud5_piece.menu_slider_addon(Composition, "GraphicsHue", 0., 1., .0001, "Hue [Ctl-Alt-H]");
        cloud5_piece.menu_slider_addon(Composition, "GraphicsValue", 0., 1., .0001, "Brightness [Ctl-Alt-B]");
        cloud5_piece.menu_slider_addon(Composition, "CanonDelay", 0., 5., .001, "Canon delay [Ctl-Alt-D]");
        cloud5_piece.menu_slider_addon(Composition, "CanonTranspose", -12., 12., 1, "Canon interval [Ctl-Alt-I]");
         */
        const composition_keys_handler = function (event) {
            console.info(event);
            const coarseness = 100;
            if (event.ctrlKey && event.altKey) {
                let sign = 1;
                if (event.shiftKey) {
                    sign = -1;
                }
                if (event.metaKey) {
                    sign *= 10;
                }
                if        (event.code === 'KeyT') {
                    let step = (200 - 0) / coarseness;
                    this.control_parameters_addon.NoteTempo += (step * sign);
                } else if (event.code === 'KeyC') {
                    let step = (127 - 5) / coarseness;
                    this.control_parameters_addon.VelocityThreshold += (step * sign);
                } else if (event.code === 'KeyF') {
                    let step = (5 - 0) / coarseness;
                    this.control_parameters_addon.NoteDurationFactor += (step * sign);
                } else if (event.code === 'KeyV') {
                    let step = (.25 - 0) / coarseness;
                    this.control_parameters_addon.GraphicsTempo += (step * sign);
                } else if (event.code === 'KeyH') {
                    let step = (1 - 0) / coarseness;
                    this.control_parameters_addon.GraphicsHue += (step * sign);
                } else if (event.code === 'KeyB') {
                    let step = (1 - 0) / coarseness;
                    this.control_parameters_addon.GraphicsValue += (step * sign);
                } else if (event.code === 'KeyD') {
                    let step = (5 - 0) / coarseness;
                    this.control_parameters_addon.CanonDelay += (step * sign);
                } else if (event.code === 'KeyI') {
                    let step = (12 - 0) / coarseness;
                    this.control_parameters_addon.CanonTranspose += (step * sign);
                } else if (event.code === 'KeyT') {
                    let step = (100 - 0) / coarseness;
                    this.control_parameters_addon.NoteTempo += (step * sign);
                }
            }
        };
        document.addEventListener("keydown", composition_keys_handler.bind(cloud5_piece));
    </script>
</body>

</html>