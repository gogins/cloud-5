<!DOCTYPE html>
<html>

<head>
    <meta http-equiv='cache-control' content='no-cache'>
    <meta http-equiv='expires' content='0'>
    <meta http-equiv='pragma' content='no-cache'>
    <title>cloud_music_no_1</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="dat.gui.js"></script>
    <script src="jquery.js"></script>
    <script src="p5.js"></script>
    <script src="sprintf.js"></script>
    <script src="three.js"></script>
    <script src="ace.js"></script>
    <script src="tinycolor.js"></script>
    <script>
        try {
            var fs = require("fs");
            var __dirname = fs.realpathSync.native(".");
        } catch (e) {
            console.log(e);
        }
    </script>
    <script src="CsoundAudioNode.js"></script>
    <script src="CsoundAC.js"></script>
    <script src='Silencio.js'></script>
    <script src='ChordSpace.js'></script>
    <script src="TrackballControls.js"></script>
    <script defer src="global-menu.js"></script>
    <link rel="stylesheet" href="w3.css">
    <style>
        .w3-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .w3-bar {
            z-index: 1;
        }

        .dg {
            font: 12px 'Verdana', sans-serif;
        }

        .dg .c {
            background: transparent;
        }

        .dg.main .close-button {
            background: transparent;
            font: 15px 'Verdana', sans-serif;
        }

        .dg.main .close-button:hover {
            background: transparent;
        }

        input {
            font: 1em/1.25em Verdana, sans-serif;
            background: transparent;
        }
    </style>
    <script src="global-menu.js"></script>
</head>

<body id="body" class="w3-medium w3-text-sand" style="height:100vh;">

    <!-- #region Canvas -->

    <canvas id="display" class="w3-container" style="background-color:black;height:100%;margin:0;padding:0;z-index:0;">
    </canvas>

    <!-- endregion-->

    <!-- #region About -->

    <div id="about_view" class="w3-container "
        style="font-size:11px;position:absolute;top:70px;z-index:5;background:transparent;color:rgb(255, 255, 200, 67%);max-height: calc(100vh - 70px);overflow-y:auto;">

        <h1 style="font-size: 15px;">Cloud Music No. 1</h1>
        <h2 style="font-size: 13px;">Michael Gogins<br>
            October 2022</h2>

        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License"
                style="border-width:0;" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
        <p>This work is licensed under a <a rel="license"
                href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons
                Attribution-NonCommercial-ShareAlike 3.0 Unported License.</a>

        <p>This is an online piece of electroacoustic music, rendered in your Web
            browser using high-resolution audio. It will play indefinitely, never ending,
            always changing.

        <p>The notes are played by a Csound orchestra that is embedded in this Web page using my <a
                href="https://github.com/gogins/csound-wasm">WebAssembly build of Csound</a>. This in turn includes my
            <a href="https://github.com/gogins/csound-ac">CsoundAC</a> library for algorithmic composition, used in this
            piece to generate randomly selected but (I hope) musically sensible chord progressions and modulations that
            are applied to the generated notes.

        <p>The music is generated by sampling the bottom row of pixels from the moving image, downsampling that row into
            fewer pixels, and translating those pixels into musical notes from left (lowest) to right (highest). Hue is
            mapped to instrument, saturation is mapped to duration, and value is mapped to loudness,

        <p>Feel free to use this piece as a template for creating new pieces of this type... as long as it doesn't sound
            too much like this one!

        <p>Please report any problems you have playing this piece, or any ideas for enhancements, at <a
                href="https://github.com/gogins/cloud-music/issues">cloud-music issues</a>.

        <ul>
            <li>To view the source code of this piece, use your browser menu to view the page source.
            <li>To inspect or debug the code of this piece as it runs, use your browser menu to open the developer
                tools.
        </ul>

        <h2 style="font-size: 13px;">Credits</h2>

        <p>I created this piece by adapting Jarble's <a href="https://www.shadertoy.com/view/Nl3BWn"><i>Fractal mosaic
                    16</i></a>, which has an open-source license compatible with the license of this piece.

        <p>My code in CsoundAC for working with chords, scales, and voice-leading implements basic ideas from <a
                href="http://dmitri.tymoczko.com/">Dmitri Tymoczko's work in music theory</a>.

        <p>Code for compiling and controlling shaders is adapted from <a
                href="https://www.shadertoy.com">ShaderToy.com</a>.

        <p>The algorithm for downsampling the video canvas is from <a
                href="https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf">Sveinn Steinarsson's MS thesis</a> with
            code from <a href="https://github.com/pingec/downsample-lttb">https://github.com/pingec/downsample-lttb</a>.

        <p>Csound instruments are adapted from <a href="https://kunstmusik.com/">Steven Yi</a> (YiString and
            FMWaterBell), Joseph T. Kung (Kung2 and Kung4), <a href="http://www.jlpublishing.com/">Lee Zakian</a>
            (ZakianFlute), and others.

        <p>

            <a href="http://michaelgogins.tumblr.com">
                <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                <svg version="1.1" id="Calque_1" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="36" height="36"
                    viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
                    <g>
                        <g>
                            <g>
                                <rect x="0.24" y="0.167" fill="#314358" width="255.52" height="256" />
                            </g>
                        </g>
                        <g>
                            <path fill="#FFFFFF"
                                d="M168.08,170.918c-2.969,1.416-8.647,2.648-12.881,2.754c-12.783,0.342-15.264-8.979-15.367-15.736v-49.705
                h32.065V84.055h-31.954V43.382c0,0-23.008,0-23.383,0c-0.385,0-1.057,0.337-1.152,1.192c-1.368,12.448-7.192,34.296-31.416,43.032
                v20.624h16.16v52.167c0,17.863,13.176,43.24,47.959,42.641c11.736-0.201,24.77-5.113,27.648-9.354L168.08,170.918" />
                        </g>
                    </g>
                </svg>
            </a>

            <a href="https://github.com/gogins">
                <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                <svg version="1.1" id="Calque_1" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="36" height="36"
                    viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
                    <g>
                        <path
                            d="M128.00106,0 C57.3172926,0 0,57.3066942 0,128.00106 C0,184.555281 36.6761997,232.535542 87.534937,249.460899 C93.9320223,250.645779 96.280588,246.684165 96.280588,243.303333 C96.280588,240.251045 96.1618878,230.167899 96.106777,219.472176 C60.4967585,227.215235 52.9826207,204.369712 52.9826207,204.369712 C47.1599584,189.574598 38.770408,185.640538 38.770408,185.640538 C27.1568785,177.696113 39.6458206,177.859325 39.6458206,177.859325 C52.4993419,178.762293 59.267365,191.04987 59.267365,191.04987 C70.6837675,210.618423 89.2115753,204.961093 96.5158685,201.690482 C97.6647155,193.417512 100.981959,187.77078 104.642583,184.574357 C76.211799,181.33766 46.324819,170.362144 46.324819,121.315702 C46.324819,107.340889 51.3250588,95.9223682 59.5132437,86.9583937 C58.1842268,83.7344152 53.8029229,70.715562 60.7532354,53.0843636 C60.7532354,53.0843636 71.5019501,49.6441813 95.9626412,66.2049595 C106.172967,63.368876 117.123047,61.9465949 128.00106,61.8978432 C138.879073,61.9465949 149.837632,63.368876 160.067033,66.2049595 C184.49805,49.6441813 195.231926,53.0843636 195.231926,53.0843636 C202.199197,70.715562 197.815773,83.7344152 196.486756,86.9583937 C204.694018,95.9223682 209.660343,107.340889 209.660343,121.315702 C209.660343,170.478725 179.716133,181.303747 151.213281,184.472614 C155.80443,188.444828 159.895342,196.234518 159.895342,208.176593 C159.895342,225.303317 159.746968,239.087361 159.746968,243.303333 C159.746968,246.709601 162.05102,250.70089 168.53925,249.443941 C219.370432,232.499507 256,184.536204 256,128.00106 C256,57.3066942 198.691187,0 128.00106,0 Z M47.9405593,182.340212 C47.6586465,182.976105 46.6581745,183.166873 45.7467277,182.730227 C44.8183235,182.312656 44.2968914,181.445722 44.5978808,180.80771 C44.8734344,180.152739 45.876026,179.97045 46.8023103,180.409216 C47.7328342,180.826786 48.2627451,181.702199 47.9405593,182.340212 Z M54.2367892,187.958254 C53.6263318,188.524199 52.4329723,188.261363 51.6232682,187.366874 C50.7860088,186.474504 50.6291553,185.281144 51.2480912,184.70672 C51.8776254,184.140775 53.0349512,184.405731 53.8743302,185.298101 C54.7115892,186.201069 54.8748019,187.38595 54.2367892,187.958254 Z M58.5562413,195.146347 C57.7719732,195.691096 56.4895886,195.180261 55.6968417,194.042013 C54.9125733,192.903764 54.9125733,191.538713 55.713799,190.991845 C56.5086651,190.444977 57.7719732,190.936735 58.5753181,192.066505 C59.3574669,193.22383 59.3574669,194.58888 58.5562413,195.146347 Z M65.8613592,203.471174 C65.1597571,204.244846 63.6654083,204.03712 62.5716717,202.981538 C61.4524999,201.94927 61.1409122,200.484596 61.8446341,199.710926 C62.5547146,198.935137 64.0575422,199.15346 65.1597571,200.200564 C66.2704506,201.230712 66.6095936,202.705984 65.8613592,203.471174 Z M75.3025151,206.281542 C74.9930474,207.284134 73.553809,207.739857 72.1039724,207.313809 C70.6562556,206.875043 69.7087748,205.700761 70.0012857,204.687571 C70.302275,203.678621 71.7478721,203.20382 73.2083069,203.659543 C74.6539041,204.09619 75.6035048,205.261994 75.3025151,206.281542 Z M86.046947,207.473627 C86.0829806,208.529209 84.8535871,209.404622 83.3316829,209.4237 C81.8013,209.457614 80.563428,208.603398 80.5464708,207.564772 C80.5464708,206.498591 81.7483088,205.631657 83.2786917,205.606221 C84.8005962,205.576546 86.046947,206.424403 86.046947,207.473627 Z M96.6021471,207.069023 C96.7844366,208.099171 95.7267341,209.156872 94.215428,209.438785 C92.7295577,209.710099 91.3539086,209.074206 91.1652603,208.052538 C90.9808515,206.996955 92.0576306,205.939253 93.5413813,205.66582 C95.054807,205.402984 96.4092596,206.021919 96.6021471,207.069023 Z"
                            fill="#161614"></path>
                    </g>
                </svg>
            </a>

    </div>

    <!-- endregion -->

    <!-- #region Visuals to Music -->

    <script id="draw-shader-fs" type="x-shader/x-fragment">#version 300 es
            #line 1160
            precision highp float;
            /**
             * These are all of the standard ShaderToy inputs. If any of these are 
             * used in this shader, they must be created and initialized in the 
             * JavaScript code.
             */
            uniform vec3 iResolution;
            // viewport resolution (in pixels)
            uniform float iTime;
            // shader playback time (in seconds)
            uniform float iTimeDelta;
            // render time (in seconds)
            uniform int iFrame;
            // shader playback frame
            uniform float iChannelTime[4];
            // channel playback time (in seconds)
            uniform vec3 iChannelResolution[4];
            // channel resolution (in pixels)
            uniform vec4 iMouse;
            // mouse pixel coords. xy: current (if MLB down), zw: click
            uniform sampler2D iChannel0;
            // input channel. XX = 2D/Cube
            uniform sampler2D iChannel1;
            // input channel. XX = 2D/Cube
            uniform sampler2D iChannel2;
            // input channel. XX = 2D/Cube
            uniform sampler2D iChannel3;
            // input channel. XX = 2D/Cube
            uniform vec4 iDate;
            // (year, month, day, time in seconds)
            uniform float iSampleRate;
            // sound sample rate (i.e., 44100)
            
            /**
             * Theoretically, any fragment shader copied from the ShaderToy 
             * editor can replace the body of the mainImage function below, 
             * if all inputs actually used in the shader are defined and bound.
             */
    
            void mainImage(out vec4 _ufragColor, in vec2 _ufragCoord);
            out vec4 _ushadertoy_out_color;
            void main(){
              (_ushadertoy_out_color = vec4(0.0, 0.0, 0.0, 0.0));
              (_ushadertoy_out_color = vec4(1.0, 1.0, 1.0, 1.0));
              vec4 _ucolor = vec4(0.0, 0.0, 0.0, 1.0);
              mainImage(_ucolor, gl_FragCoord.xy);
              if ((_ushadertoy_out_color.x < 0.0))
              {
                (_ucolor = vec4(1.0, 0.0, 0.0, 1.0));
              }
              if ((_ushadertoy_out_color.y < 0.0))
              {
                (_ucolor = vec4(0.0, 1.0, 0.0, 1.0));
              }
              if ((_ushadertoy_out_color.z < 0.0))
              {
                (_ucolor = vec4(0.0, 0.0, 1.0, 1.0));
              }
              if ((_ushadertoy_out_color.w < 0.0))
              {
                (_ucolor = vec4(1.0, 1.0, 0.0, 1.0));
              }
              (_ushadertoy_out_color = vec4(_ucolor.xyz, 1.0));
            }
            float hash(int x) { return fract(sin(float(x))*7.847); } 
    
            float dSegment(vec2 a, vec2 b, vec2 c)
            {
                vec2 ab = b-a;
                vec2 ac = c-a;
                float h = clamp(dot(ab, ac)/dot(ab, ab), 0., 1.);
                vec2 point = a+ab*h;
                return length(c-point);
            }
    
    vec2 triangle_wave(vec2 a){
        ///return abs(fract((a+vec2(1.,0.5))*1.5)-.5);
        return abs(fract((a*.9+vec2(1.,0.75))*1.75)-.325);
    }
    
    void mainImage( out vec4 fragColor, in vec2 fragCoord )
    {
        fragColor = vec4(0.0);
        vec3 col = vec3(0.);
        float t1 = 8.*7.;
        vec2 uv = (fragCoord)/iResolution.y/t1/2.0;
        ////uv.y += iTime/t1/12.0;
        uv.y += iTime/t1/256.0;
        float scale = 1.5;
        vec2 t2 = vec2(0.);
        vec3 col1 = col;
    
        for(int k = 0; k < 12; k++){
            bool c1 = t2.x < uv.x;
            uv = (uv+t2)/scale;
            t2 = triangle_wave(uv-.5);
            uv = t2-triangle_wave(uv.yx);
            float z1 =
                //Several interesting variants here:
                abs(uv.x-uv.y)-t2.x-t2.y;
                //length(uv-t2);
                ///max(abs(t2.y),abs(uv.y));
                ///max(abs(t2.x),abs(uv.x));
                //abs(uv.y)-t2.y;
                //abs(uv.x)-t2.x;
                ///max(abs(uv.x-t2.x),abs(uv.y-t2.y));
                //uv.x-t2.x;
                //t2.y;
                //abs(uv.x+uv.y)-t2.x-t2.y;
                ///t2.x+uv.x;
                //uv.x+t2.x;
                
                //max(abs(t2.y-uv.y),abs(t2.x-uv.x));
    
                ///max(abs(uv.y),abs(uv.x));
    
            col.x = max((abs(z1))/3.,col.x);
            col =
                abs(col-(1.-col.x));
                //abs(col.yzx-(1.-col.x));
            col1 =
                abs(col1-col-1.).yzx;
                //col1 = abs(abs(col1-1.)-col).yzx;
    
            //if(c1) col =
                //col.yzx;
                //abs(col.yzx-col);
        }
        //~ if (int(fragCoord.y) == 100) {
            //~ fragColor = vec4(0.0, 1.0, 0.0, 1.0);
        //~ } else {
            //~ fragColor = vec4(col1/2.,1.0);
        //~ }
        fragColor = vec4(col1/2.,1.0);
    }
                  
    </script>

    <script id="draw-shader-vs" type="x-shader/x-vertex">#version 300 es
            in vec2 inPos;
            void main() {
                gl_Position = vec4(inPos.xy, 0.0, 1.0);
            }
    </script>

    <script>

        var shader_program = null;
        var analyser = null;
        // Set up for high-resolution displays.
        var devicePixelRatio_ = window.devicePixelRatio || 1
        var canvas = document.getElementById("display");
        canvas.width = canvas.clientWidth * devicePixelRatio_;
        canvas.height = canvas.clientHeight * devicePixelRatio_;
        console.log("canvas.height: " + canvas.height);
        console.log("canvas.width:  " + canvas.width);
        var gl = canvas.getContext("webgl2", { antialias: true });
        if (!gl) {
            alert("Could not create webgl2 context.");
        }
        let extensions = gl.getSupportedExtensions();
        console.log("Supported extensions:\n" + extensions);
        if ("gpu" in navigator) {
            var gpu_adapter = navigator.gpu.requestAdapter();
            console.log("WebGPU adapter: " + gpu_adapter);
        } else {
            console.warn("WebGPU is not available on this platform.");
        }
        var EXT_color_buffer_float = gl.getExtension("EXT_color_buffer_float");
        if (!EXT_color_buffer_float) {
            alert("EXT_color_buffer_float is not available on this platform.");
        }
        var WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders");
        const audio_texture_level = 0;
        const audio_texture_internalFormat = gl.R32F;
        const audio_texture_width = 512;
        const audio_texture_height = 2;
        const audio_texture_border = 0;
        const audio_texture_srcFormat = gl.RED;
        const audio_texture_srcType = gl.FLOAT;
        var frequency_domain_data = new Uint8Array(audio_texture_width * 2);
        var time_domain_data = new Uint8Array(audio_texture_width * 2);
        var audio_data = new Float32Array(audio_texture_width * 2);
        var image_sample_buffer = new Uint8ClampedArray();

        var channel0_texture_unit = 0;
        var channel0_texture = gl.createTexture();
        channel0_texture.name = "channel0_texture";
        var channel0_sampler = gl.createSampler();
        channel0_sampler.name - "channel0_sampler";

        var current_events = new Map();
        var prior_events = current_events;
        var rendering_frame = 0;

        function write_audio_texture(analyser, texture_unit, texture, sampler) {
            if (analyser != null) {
                analyser.getByteFrequencyData(frequency_domain_data);
                analyser.getByteTimeDomainData(time_domain_data);
                for (let i = 0; i < audio_texture_width; ++i) {
                    // Map frequency domain magnitudes to [0, 1].
                    let sample = frequency_domain_data[i];
                    sample = sample / 255.;
                    audio_data[i] = sample;
                }
                let audio_data_width = audio_texture_width * 2;
                for (let j = 0; j < audio_texture_width; ++j) {
                    // Map time domain amplitudes to [-1, 1].
                    let sample = time_domain_data[j];
                    sample = sample / 255.;
                    audio_data[audio_texture_width + j] = sample;
                }
            }
            gl.activeTexture(gl.TEXTURE0 + texture_unit);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.bindSampler(texture_unit, sampler);
            gl.texImage2D(gl.TEXTURE_2D, audio_texture_level, audio_texture_internalFormat, audio_texture_width, audio_texture_height, audio_texture_border, audio_texture_srcFormat, audio_texture_srcType, audio_data);
            gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
            gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_MODE, gl.NONE);
            gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
            if (false && analyser) { // For debugging.
                let is_texture = gl.isTexture(texture);
                let uniform_count = gl.getProgramParameter(shader_program, gl.ACTIVE_UNIFORMS);
                let uniform_index;
                for (let uniform_index = 0; uniform_index < uniform_count; ++uniform_index) {
                    uniform_info = gl.getActiveUniform(shader_program, uniform_index);
                    console.log(uniform_info);
                    const location = gl.getUniformLocation(shader_program, uniform_info.name);
                    const value = gl.getUniform(shader_program, location);
                    console.log("Uniform location: " + location);
                    console.log("Uniform value: " + value);
                }
                const unit = gl.getUniform(shader_program, shader_program.iChannel0);
                console.log("Sampler texture unit: " + unit);
                console.log("Texture unit: " + texture_unit);
                gl.activeTexture(gl.TEXTURE0 + texture_unit);
                let texture2D = gl.getParameter(gl.TEXTURE_BINDING_2D);
                console.log("Texture binding 2D " + texture2D);
                var debug_framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, debug_framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2D, 0);
                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                    console.log("These attachments don't work.");
                }
                // Read the contents of the debug_framebuffer (data stores the pixel data).
                var data = new Float32Array(1024);
                // What comes out, should be what went in.
                gl.readPixels(0, 0, 512, 2, gl.RED, gl.FLOAT, data);
                //console.log("\nfrequency domain: \n" + data.slice(0, 512));
                //console.log("time domain: \n" + data.slice(512));
                gl.deleteFramebuffer(debug_framebuffer);
            }
        }

        function load_scene() {
            var webgl_viewport_size;
            var webgl_buffers = {};
            var mouse_position = [0, 0, 0, 0];
            function create_scene() {
                canvas.addEventListener('mousemove', (e) => {
                    mouse_position = [e.clientX, e.clientY];
                });
                shader_program = gl.createProgram();
                for (let i = 0; i < 2; ++i) {
                    let shader_code = document.getElementById(i == 0 ? "draw-shader-vs" : "draw-shader-fs").text;
                    let shader_object = gl.createShader(i == 0 ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
                    gl.shaderSource(shader_object, shader_code);
                    gl.compileShader(shader_object);
                    let status = gl.getShaderParameter(shader_object, gl.COMPILE_STATUS);
                    if (!status) {
                        console.warn(gl.getShaderInfoLog(shader_object));
                    }
                    gl.attachShader(shader_program, shader_object);
                    gl.linkProgram(shader_program);
                    console.log("shader:" + WEBGL_debug_shaders.getTranslatedShaderSource(shader_object));
                }
                status = gl.getProgramParameter(shader_program, gl.LINK_STATUS);
                if (!status) {
                    console.warn(gl.getProgramInfoLog(shader_program));
                }
                shader_program.inPos = gl.getAttribLocation(shader_program, "inPos");
                shader_program.iMouse = gl.getUniformLocation(shader_program, "iMouse");
                shader_program.iResolution = gl.getUniformLocation(shader_program, "iResolution");
                shader_program.iTime = gl.getUniformLocation(shader_program, "iTime");
                shader_program.iTimeDelta = gl.getUniformLocation(shader_program, "iTimeDelta");
                shader_program.iFrame = gl.getUniformLocation(shader_program, "iFrame");
                shader_program.iChannel0 = gl.getUniformLocation(shader_program, "iChannel0");
                shader_program.iChannel1 = gl.getUniformLocation(shader_program, "iChannel1");
                shader_program.iChannel2 = gl.getUniformLocation(shader_program, "iChannel2");
                shader_program.iChannel3 = gl.getUniformLocation(shader_program, "iChannel3");
                shader_program.iSampleRate = gl.getUniformLocation(shader_program, "iSampleRate");
                gl.useProgram(shader_program);

                gl.uniform1f(shader_program.iSampleRate, 48000.);
                var pos = [-1, -1,
                    1, -1,
                    1, 1,
                -1, 1];
                var inx = [0, 1, 2, 0, 2, 3];
                webgl_buffers.pos = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_buffers.pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
                webgl_buffers.inx = gl.createBuffer();
                webgl_buffers.inx.len = inx.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webgl_buffers.inx);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(inx), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(shader_program.inPos);
                gl.vertexAttribPointer(shader_program.inPos, 2, gl.FLOAT, false, 0, 0);
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                write_audio_texture(analyser, channel0_texture_unit, channel0_texture, channel0_sampler);
                window.onresize = resize;
                resize();
                requestAnimationFrame(render_scene);
            }

            function resize() {
                webgl_viewport_size = [window.innerWidth, window.innerHeight];
                canvas.width = webgl_viewport_size[0] * window.devicePixelRatio;
                canvas.height = webgl_viewport_size[1] * window.devicePixelRatio;
                image_sample_buffer = new Uint8ClampedArray(canvas.width * 4);
                prior_image_sample_buffer = new Uint8ClampedArray(canvas.width * 4);
                console.info("resize: image_sample_buffer.length: " + image_sample_buffer.length);
            }

            function clientWaitAsync(sync, flags, interval_ms) {
                return new Promise((resolve, reject) => {
                    function test() {
                        const result = gl.clientWaitSync(sync, flags, 0);
                        if (result === gl.WAIT_FAILED) {
                            reject();
                            return;
                        }
                        // This is the workaround for platforms where maximum 
                        // timeout is always 0.
                        if (result === gl.TIMEOUT_EXPIRED) {
                            setTimeout(test, interval_ms);
                            return;
                        }
                        resolve();
                    }
                    test();
                });
            }

            async function getBufferSubDataAsync(target, buffer, srcByteOffset, dstBuffer,
                    /* optional */ dstOffset, /* optional */ length) {
                const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                await clientWaitAsync(sync, 0, 10);
                gl.deleteSync(sync);
                gl.bindBuffer(target, buffer);
                gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
                gl.bindBuffer(target, null);
            }

            /**
             * Converts an RGB color value to HSV. The formula is 
             * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
             * Assumes r, g, and b are in [0, 255] and
             * returns h, s, and v are in [0, 1].
             */
            var rgb_to_hsv = function (rgb) {
                r = rgb[0] / 255;
                g = rgb[1] / 255;
                b = rgb[2] / 255;
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                var h, s, v = max;
                var d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max == min) {
                    h = 0;
                } else {
                    // More efficient than switch?
                    if (max == r) {
                        h = (g - b) / d + (g < b ? 6 : 0);
                    } else if (max == g) {
                        h = (b - r) / d + 2;
                    } else if (max == b) {
                        h = (r - g) / d + 4;
                    }
                    h /= 6;
                }
                return [h, s, v];
            }

            async function readPixelsAsync(x, y, w, h, format, type, sample) {
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
                gl.bufferData(gl.PIXEL_PACK_BUFFER, sample.byteLength, gl.STREAM_READ);
                gl.readPixels(x, y, w, h, format, type, 0);
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                await getBufferSubDataAsync(gl.PIXEL_PACK_BUFFER, buffer, 0, sample);
                gl.deleteBuffer(buffer);
            }

            /**
             * Adapts https://github.com/pingec/downsample-lttb from time 
             * series data to vectors of float HSV pixels. Our data is not 
             * [[time, value], [time, value],...], but rather 
             * [[pixel index0, hsv0[2]], [pixel index1, hsv1[2]], ...].
             */
            function downsample_lttb(data, buckets) {
                if (buckets >= data.length || buckets === 0) {
                    return data; // Nothing to do
                }
                let sampled_data = [],
                    sampled_data_index = 0;
                // Bucket size. Leave room for start and end data points
                let bucket_size = (data.length - 2) / (buckets - 2);
                // Triangles are points {a, b, c}.
                let a = 0,  // Initially a is the first point in the triangle
                    max_area_point,
                    max_area,
                    area,
                    next_a;
                sampled_data[sampled_data_index++] = data[a]; // Always add the first point
                for (let i = 0; i < buckets - 2; i++) {
                    // Calculate point average for next bucket (containing c)
                    let avg_x = 0,
                        avg_y = 0,
                        avg_range_start = Math.floor((i + 1) * bucket_size) + 1,
                        avg_range_end = Math.floor((i + 2) * bucket_size) + 1;
                    avg_range_end = avg_range_end < data.length ? avg_range_end : data.length;
                    let avg_range_length = avg_range_end - avg_range_start;
                    for (; avg_range_start < avg_range_end; avg_range_start++) {
                        avg_x += data[avg_range_start][0] * 1; // * 1 enforces Number (value may be Date)
                        avg_y += data[avg_range_start][1] * 1;
                    }
                    avg_x /= avg_range_length;
                    avg_y /= avg_range_length;
                    // Get the range for this bucket
                    let range_offs = Math.floor((i + 0) * bucket_size) + 1,
                        range_to = Math.floor((i + 1) * bucket_size) + 1;
                    // Point a
                    let point_a_x = data[a][0] * 1, // enforce Number (value may be Date)
                        point_a_y = data[a][1] * 1;
                    max_area = area = -1;
                    for (; range_offs < range_to; range_offs++) {
                        // Calculate triangle area over three buckets
                        area = Math.abs((point_a_x - avg_x) * (data[range_offs][1] - point_a_y) -
                            (point_a_x - data[range_offs][0]) * (avg_y - point_a_y)
                        ) * 0.5;
                        if (area > max_area) {
                            max_area = area;
                            max_area_point = data[range_offs];
                            next_a = range_offs; // Next a is this b
                        }
                    }
                    sampled_data[sampled_data_index++] = max_area_point; // Pick this point from the bucket
                    a = next_a; // This a is the next a (chosen b)
                }
                sampled_data[sampled_data_index++] = data[data.length - 1]; // Always add last
                return sampled_data; ///sampled_data;
            }

            /**
             * Translates one row of RGBA pixels, the width of the WebGL 
             * canvas, to Csound events. 
             *
             * https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf
             */
            var instrument_count = 8;
            var sampled_events = new Array();
            var playlist = new Map();
            var gi_Composition_tempo = 25;
            var frame_translation_count = 0;
            var midi_key_begin = 36;
            var midi_key_range = 60;
            var maximum_voices = 8;
            var event_velocity_threshold = 100;
            var midi_key_end = midi_key_begin + midi_key_range;
            var sample_count = 0;
            var root_progression = 0;
            var on_events = new Array();
            var off_events = new Array();
            var playing_events = new Map();
            var event_tag = 0;
            var root_progressions = [2, 3, -4, 5, -1, 3];

            async function translate_sample_to_csound_events(maximum_events, threshold, parent_rendering_frame) {
                if (csound == null) {
                    return;
                }
                if (!csound.is_playing) {
                    return;
                }
                let x = 0;
                // y is zero at the bottom of the canvas.
                let y = 0;
                let width = canvas.width;
                let height = 1;
                let format = gl.RGBA;
                let type = gl.UNSIGNED_BYTE;
                readPixelsAsync(x, y, width, height, format, type, image_sample_buffer);
                // Translate the sample format from byte RGBA to float HSV.
                let hsv_image_sample = [];
                for (let byte_i = 0; byte_i < image_sample_buffer.length; byte_i = byte_i + 4) {
                    let rgb = image_sample_buffer.slice(byte_i, byte_i + 3);
                    let hsv = rgb_to_hsv(rgb);
                    hsv_image_sample.push([hsv_image_sample.length + 1, hsv[2], hsv]);
                }
                // Downsample the HSV samples.
                let downsampled_pixels = downsample_lttb(hsv_image_sample, midi_key_range);
                sampled_events.length = 0;
                on_events.length = 0;
                off_events.length = 0;
                score.clear();
                // Translate the HSV samples to Csound event vectors.
                // 0 is p1 insno (hsv[0](, tagged by downsampled pixel, 
                //   positive for on or negative for off.
                // 1 is p2 time always 0.
                // 2 is p3 duration (either hsv[1] or -1, must be 0 for off
                //   events).
                // 3 is p4 MIDI key (downsampled pixel).
                // 4 is p5 MIDI velocity (hsv[2]).
                for (let downsampled_pixel_i = 0; downsampled_pixel_i < downsampled_pixels.length; downsampled_pixel_i++) {
                    let hsv = downsampled_pixels[downsampled_pixel_i][2];
                    let instrument_number = 1 + (hsv[0] * instrument_count);
                    // The instrument number must have a unique fractional tag.
                    let time = 0;
                    let duration = .25 + (60 / gi_Composition_tempo * hsv[1] * 2);
                    let midi_key = Math.floor(midi_key_begin + downsampled_pixel_i);
                    //instrument_number = 4;
                    let insno = sprintf("%d.%d", Math.floor(instrument_number), midi_key);
                    instrument_number = parseFloat(insno);
                    let midi_velocity = hsv[2] * 128;
                    let event_for_pixel = [instrument_number, time, duration, midi_key, midi_velocity];
                    sampled_events.push(event_for_pixel);
                }
                console.log(sprintf("sampled_events.length: %d\n", sampled_events.length));
                // Events that are playing but not loud enough, are turned off.
                for (let sampled_event_i = 0; sampled_event_i < sampled_events.length; sampled_event_i++) {
                    let sampled_event = sampled_events[sampled_event_i];
                    let key = sampled_event[0];
                    if (playing_events.has(key) == true) {
                        let off_event = playing_events.get(key);
                        let instrument_number = off_event[0];
                        if (threshold > sampled_event[4]) {
                            csound.KillInstance(instrument_number, "", 4, true);
                            console.log("Turned off instrument number: " + instrument_number + ".");
                            playing_events.delete(key);
                        }
                    }
                }
                console.log(sprintf("playing_events.size:   %d\n", playing_events.size));
                // Events that are loud enough but not playing, are turned on.
                for (let sampled_event_i = 0; sampled_event_i < sampled_events.length; sampled_event_i++) {
                    let sampled_event = sampled_events[sampled_event_i];
                    let key = sampled_event[0];
                    if (playing_events.has(key) == false) {
                        if (sampled_event[4] >= threshold) {
                            playing_events.set(key, sampled_event);
                            on_events.push(sampled_event);
                        }
                    }
                }
                console.log(sprintf("playing_events.size:   %d\n", playing_events.size));
                console.log(sprintf("on_events.length:      %d\n", on_events.length));
                CsoundAC.setCorrectNegativeDurations(false);
                // Limit number of on events, play N loudest only. Could also pick at random.
                on_events.sort(function (a, b) {
                    if (a[5] < b[5]) {
                        return 1;
                    }
                    if (b[5] < a[5]) {
                        return -1;
                    }
                    return 0;
                });
                let voices = Math.min(on_events.length, maximum_voices);
                for (let i = 0; i < voices; i++) {
                    let on_event = on_events[i];
                    let time = 0;
                    let duration = on_event[2];
                    let status = 144;
                    let instrument_number = on_event[0];
                    ///let instrument_number = 8;
                    let key = on_event[3];
                    let velocity = on_event[4];
                    velocity = 60 + (velocity / 7);
                    let phase = 0;
                    let pan = .01 + Math.random() * .8;
                    let depth = 0;
                    let height = 0;
                    let pitches = 4095;
                    score.add(time, duration, status, instrument_number, key, velocity, phase, pan, depth, height, pitches);
                }
                if (score.size() > 0) {
                    if (sample_count % 4 == 0) {
                        if (sample_count % 24 == 0) {
                            let scales = scale.modulations(chord);
                            if (scales.size() > 1) {
                                scale = scales.get(Math.floor(Math.random() * scales.size()));
                                csound_message_callback(sprintf("\nScale: %s\n", scale.name()));
                            }
                        }
                        let root_progression = root_progressions[Math.floor(Math.random() * root_progressions.length)];
                        let chord_name = chord.eOP().name();
                        if (chord_name.length == 0) {
                            chord_name = chord.eOP().toString();
                        }
                        csound_message_callback(sprintf("\nChord: %s\n\n", chord_name));
                        chord = scale.transpose_degrees(chord, root_progression, 3)
                    }
                    CsoundAC.apply(score, chord, 0, 1000000, true);
                    let score_text = score.getCsoundScore(12., true);
                    csound.ReadScore(score_text);
                }
                sample_count++;
            }

            /** 
             * As the last step in rendering the scene, this function reads 
             * one row of the canvas (the sample) into an array of pixels, 
             * then translates that row into a set of Csound events, the 
             * mapping determined by a separate function. An attempt is made 
             * to avoid stalling the WebGL rendering pipeline by reading the 
             * pixels from the canvas only when a memory fence around 
             * the GPU pipeline becomes passable.
             */
            async function sample_canvas(current_rendering_frame) {
                //console.info("frame_sample_to_score.");
                gi_Composition_tempo = Math.floor(parseFloat(parameters.gi_Composition_tempo));
                event_velocity_threshold = parseFloat(parameters.gi_Composition_density);
                await translate_sample_to_csound_events(16, event_velocity_threshold, current_rendering_frame);
            }

            /**
             * The graphics rendering loop polls the current time and tempo in 
             * order to compute when to sample notes from the canvas.
             */
            var current_time;
            var next_time = 0;
            function render_scene(milliseconds) {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                let tyme = milliseconds / 1000;
                gl.uniform1f(shader_program.iTime, tyme);
                gl.uniform3f(shader_program.iResolution, canvas.width, canvas.height, 0);
                gl.uniform4f(shader_program.iMouse, mouse_position[0], mouse_position[1], 0, 0);
                //write_audio_texture(analyser, channel0_texture_unit, channel0_texture, channel0_sampler);
                gl.drawElements(gl.TRIANGLES, webgl_buffers.inx.len, gl.UNSIGNED_SHORT, 0);
                current_time = performance.now() / 1000;
                if (current_time >= next_time) {
                    if (typeof parameters !== 'undefined') {
                        next_time = current_time + (60 / parameters.gi_Composition_tempo);
                    }
                    sample_canvas(rendering_frame);
                }
                rendering_frame++;
                requestAnimationFrame(render_scene);
            }
            create_scene();
        };

    </script>

    <script>
        var CsoundAC = null;
        var csound = null;
        var score = null;
        var scale = null;
        var chord = null;
        var message_callback_buffer = "";
        var console_editor = ace.edit("console_view");
        //console_editor.setTheme("ace/theme/gob");
        console_editor.setReadOnly(true);
        console_editor.setShowPrintMargin(false);
        console_editor.setDisplayIndentGuides(false);
        console_editor.renderer.setOption("showGutter", false);
        console_editor.renderer.setOption("showLineNumbers", true);
        (async function () {
            CsoundAC = await createCsoundAC();
            score = new CsoundAC.Score();
            scale = new CsoundAC.Scale("F major");
            chord = scale.chord(1, 5, 3);
            //CsoundAC.CHORD_SPACE_DEBUGGING(false);
            var txt = "\n";
            txt += "Browser CodeName: " + navigator.appCodeName + "\n";
            txt += "Browser Name: " + navigator.appName + "\n";
            txt += "Browser Version: " + navigator.appVersion + "\n";
            txt += "Cookies Enabled: " + navigator.cookieEnabled + "\n";
            txt += "Browser Language: " + navigator.language + "\n";
            txt += "Browser Online: " + navigator.onLine + "\n";
            txt += "Platform: " + navigator.platform + "\n";
            txt += "User-agent header: " + navigator.userAgent + "\n";
            txt += "gl.VENDOR: " + gl.getParameter(gl.VENDOR) + "\n";
            txt += "gl.RENDERER: " + gl.getParameter(gl.RENDERER) + "\n";
            txt += "gl.VERSION: " + gl.getParameter(gl.VERSION) + "\n";
            txt += "gl.SHADING_LANGUAGE_VERSION: " + gl.getParameter(gl.SHADING_LANGUAGE_VERSION) + "\n";
            csound_message_callback(txt);
            csound_message_callback(CsoundAC.chord_space_version() + "\n");
            let CM = CsoundAC.chordForName("CM");
            CM = CM.T(-4.);
            csound_message_callback(CM.information());
            csound_message_callback(CM.information_debug(-1));
        }());

        window.onload = async function () {
            $("#controls_view").css("display", "none");
            $("#about_view").css("display", "none");
            $("#console_view").css("display", "none");
            $("#menu_item_play").click(async function (event) {
                console.log("menu_item_play click...");
                if (csound == null) {
                    try {
                        csound_message_callback("Trying to load CsoundAudioNode...\n");
                        var AudioContext = window.AudioContext || window.webkitAudioContext;
                        var audioContext = new AudioContext();
                        await audioContext.audioWorklet.addModule('CsoundAudioProcessor.js').then(function () {
                            csound_message_callback("Creating CsoundAudioNode...\n");
                            csound = new CsoundAudioNode(audioContext, csound_message_callback);
                            csound_message_callback("CsoundAudioNode (AudioWorklet) is available in this JavaScript context.\n");
                            analyser = new AnalyserNode(audioContext);
                            analyser.fftSize = 2048;
                            console.log("Analyzer buffer size: " + analyser.frequencyBinCount);
                            csound.connect(analyser);
                            console.log("csound: " + csound);
                        }, function (error) {
                            csound_message_callback(error + '\n');
                        });
                        csound_image_player = new CsoundImagePlayer(csound, CsoundAC, canvas);
                    } catch (e) {
                        csound_message_callback(e + '\n');
                    }
                }
                if (csound.is_playing == false) {
                    let csd = await document.getElementById('csd').value;
                    console_editor.setValue("");
                    let result = await csound.CompileCsdText(csd);
                    csound_message_callback("CompileCsdText returned: " + result);
                    await csound.Start();
                    if (localStorage.length > 0) {
                        $('#restore').trigger('click');
                    } else {
                        // Tricky! Otherwise we get _patch_ defaults, probably 
                        // not correct; we need _html_ defaults.
                        $('#default').trigger('click');
                    }
                    await csound.Perform();
                    scale = new CsoundAC.Scale("F major");
                    csound_message_callback("Csound is playing...\n");
                    next_time = 0;
                    $("#menu_item_play").html("Stop");
                } else {
                    await csound.Stop();
                    await csound.Cleanup();
                    csound.Reset();
                    csound_message_callback("Csound is stopping...\n");
                    $("#menu_item_play").html("Play");
                }
            });
            $("#menu_item_fullscreen").click(function (event) {
                console.log("menu_item_fullscreen click...");
                const display = document.getElementById("display");
                if (display.requestFullscreen) {
                    display.requestFullscreen();
                } else if (display.webkitRequestFullscreen) {
                    display.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    display.msRequestFullscreen();
                }
            });
            $("#menu_item_controls").click(function (event) {
                console.log("menu_item_controls click...");
                $("#about_view").hide();
                $("#console_view").hide();
                if ($("#controls_view").is(":visible")) {
                    $("#controls_view").hide();
                } else {
                    $("#controls_view").show();
                }
            });
            $("#menu_item_console").click(function (event) {
                console.log("menu_item_console click...");
                $("#controls_view").hide();
                $("#about_view").hide();
                let v = document.getElementById("console_view");
                if ($("#console_view").is(":visible")) {
                    $("#console_view").hide();
                } else {
                    $("#console_view").show();
                    // Needed to make visible in place.
                    console_editor.resize(true);
                }
            });
            $("#menu_item_about").click(function (event) {
                console.log("menu_item_about click...");
                $("#controls_view").hide();
                $("#console_view").hide();
                if ($("#about_view").is(":visible")) {
                    $("#about_view").hide();
                } else {
                    $("#about_view").show();
                }
            });
            $(document).keydown(function (event) {
                console.log("document keydown...");
                if (event.keyCode === 'F11') {
                    $("#menu_item_fullscreen").trigger("click");
                }
            });
            $('input').on('input', async function (event) {
                var slider_value = parseFloat(event.target.value);
                if (csound) {
                    csound.SetControlChannel(event.target.id, slider_value);
                }
                var output_selector = '#' + event.target.id + '_output';
                $(output_selector).val(slider_value);
            });
            $('#save').on('click', function () {
                $('.persistent-element').each(function () {
                    localStorage.setItem(this.id, this.value);
                });
            });
            $('#restore').on('click', async function () {
                $('.persistent-element').each(function () {
                    this.value = localStorage.getItem(this.id);
                    if (csound) {
                        csound.SetControlChannel(this.id, parseFloat(this.value));
                    }
                    var output_selector = '#' + this.id + '_output';
                    $(output_selector).val(this.value);
                });
            });
            $('#copy').on('click', function () {
                let controls_json = JSON.stringify(localStorage);
                navigator.clipboard.writeText(controls_json);
                csound_message_callback("Copied controls state to system clipboard.\n");
            });
            $('#paste').on('click', async function () {
                navigator.clipboard.readText().then(function (controls_json) {
                    let controls_state = JSON.parse(controls_json);
                    for (let [key, value] of Object.entries(controls_state)) {
                        console.log(key, value);
                    }
                    $('.persistent-element').each(function () {
                        this.value = localStorage.getItem(this.id);
                        if (csound) {
                            csound.SetControlChannel(this.id, parseFloat(this.value));
                        }
                        var output_selector = '#' + this.id + '_output';
                        $(output_selector).val(this.value);
                    });
                    csound_message_callback("Pasted controls state from system clipboard.\n");
                });
            });
            $('#default').on('click', function () {
                $('.persistent-element').each(function () {
                    this.value = this.defaultValue;
                    if (csound) {
                        csound.SetControlChannel(this.id, parseFloat(this.value));
                    }
                    var output_selector = '#' + this.id + '_output';
                    $(output_selector).val(this.value);
                });
            });
            // Reset controls to defaults every time the window loads!
            $("#default")[0].click();
            $("#save")[0].click();
        };
    </script>

    <!-- endregion -->

    <!-- #region Csound Controls -->

    <script>

        /*
        instr Guitar uses instrument number 1
        instr Plucked uses instrument number 2
        instr FMWaterBell uses instrument number 3
        instr YiString uses instrument number 4
        instr Harpsichord uses instrument number 5
        instr ZakianFlute uses instrument number 6
        instr Kung4 uses instrument number 7
        instr Kung2 uses instrument number 8
        instr Bower uses instrument number 9
        instr ReverbSC uses instrument number 10
        instr MasterOutput uses instrument number 11
        */

        var parameters = {
            gi_Composition_tempo: 180,
            gi_Composition_density: 50,
            gk_Guitar_level: 0,
            gk_Plucked_level: 0,
            gk_FMWaterBell_level: 0,
            gi_FMWaterBell_attack: 0.002,
            gi_FMWaterBell_release: 0.01,
            gi_FMWaterBell_exponent: 15,
            gi_FMWaterBell_sustain: 20,
            gi_FMWaterBell_sustain_level: .1,
            gk_FMWaterBell_index: .5,
            gk_FMWaterBell_crossfade: .5,
            gk_FMWaterBell_vibrato_depth: 0.05,
            gk_FMWaterBell_vibrato_rate: 6,
            gk_YiString_level: 0,
            gk_Harpsichord_level: 0,
            gk_ZakianFlute_level: 0,
            gk_Kung4_level: 0,
            gk_Kung2_level: 0,
            gk_Bower_level: 0,
            gk_Bower_pressure: 0.25,
            gk_MasterOutput_level: 0,
            gk_ReverbSC_wet: 0.5,
            gk_ReverbSC_feedback: 0.85,
            gk_ReverbSC_delay_modulation: 0.0075,
            gk_ReverbSC_frequency_cutoff: 9000,
            gk_overlap: 0.05,
        };

        var default_json = {
            "preset": "Default",
            "remembered": {
                "Default": {
                    "0": {
                        "gk_overlap": 4.26222770242499,
                        "gk_MasterOutput_level": -9.272503082614058,
                        "gi_Composition_density": 75.50575421290587,
                        "gi_Composition_tempo": 180,
                        "gk_ReverbSC_wet": 0.5,
                        "gk_ReverbSC_feedback": 0.9167694204685574,
                        "gk_ReverbSC_delay_modulation": 0.0075,
                        "gk_ReverbSC_frequency_cutoff": 9000,
                        "gk_Guitar_level": -9.272503082614058,
                        "gk_Plucked_level": -3.4854089601315223,
                        "gk_FMWaterBell_level": 32.28935470612413,
                        "gi_FMWaterBell_attack": 0.002,
                        "gi_FMWaterBell_release": 0.01,
                        "gi_FMWaterBell_exponent": 15,
                        "gi_FMWaterBell_sustain": 20,
                        "gi_FMWaterBell_sustain_level": 0.1,
                        "gk_FMWaterBell_crossfade": 0.5,
                        "gk_FMWaterBell_index": 0.5,
                        "gk_FMWaterBell_vibrato_depth": 0.05,
                        "gk_FMWaterBell_vibrato_rate": 6,
                        "gk_YiString_level": 42.99219071105631,
                        "gk_Harpsichord_level": 18.660090423345665,
                        "gk_ZakianFlute_level": 43.64981504315659,
                        "gk_Kung4_level": 13.349773941635839,
                        "gk_Kung2_level": 32.28935470612413,
                        "gk_Bower_level": 42.99219071105631,
                        "gk_Bower_pressure": 0.25
                    }
                }
            },
            "closed": true,
            "folders": {
                "Master": {
                    "preset": "Default",
                    "closed": false,
                    "folders": {}
                },
                "Guitar": {
                    "preset": "Default",
                    "closed": true,
                    "folders": {}
                },
                "Plucked": {
                    "preset": "Default",
                    "closed": true,
                    "folders": {}
                },
                "FMWaterBell": {
                    "preset": "Default",
                    "closed": true,
                    "folders": {}
                },
                "YiString": {
                    "preset": "Default",
                    "closed": true,
                    "folders": {}
                },
                "Harpsichord": {
                    "preset": "Default",
                    "closed": false,
                    "folders": {}
                },
                "Zakian Flute": {
                    "preset": "Default",
                    "closed": false,
                    "folders": {}
                },
                "Kung4": {
                    "preset": "Default",
                    "closed": true,
                    "folders": {}
                },
                "Kung2": {
                    "preset": "Default",
                    "closed": true,
                    "folders": {}
                },
                "Bower": {
                    "preset": "Default",
                    "closed": false,
                    "folders": {}
                }
            }
        };

        function build_dat_gui_menu() {
            csound_message_callback("build_dat_gui_menu...\n");
            // Ensure that the dat.gui controls are children of the _Controls_ button.
            let dat_gui_parameters = { autoPlace: false, closeOnTop: true, closed: true, width: 400 };
            gui = new dat.GUI(dat_gui_parameters);
            var dat_gui = document.getElementById('menu_item_dat_gui');
            dat_gui.appendChild(gui.domElement);
            // Ensure that we use remembered parameters, but will  fall back 
            // on the coded defaults if there are no remembered parameters.
            let parameters_ = default_json.remembered.Default[0];
            if (typeof parameters_ !== 'undefined') {
                if (parameters_ !== null) {
                    parameters = parameters_;
                }
            }
            // This updates the dat.gui GUI from the parameters, which are 
            // in global scope, so used by `add_slider` etc.
            gui.remember(parameters);
            var Master = gui.addFolder('Master');
            add_slider(Master, 'gk_overlap', 0, 20);
            add_slider(Master, 'gk_MasterOutput_level', -50, 50);
            add_slider(Master, 'gi_Composition_density', 0, 127);
            add_slider(Master, 'gi_Composition_tempo', 2, 480);
            add_slider(Master, 'gk_MasterOutput_level', -50, 50);
            add_slider(Master, 'gk_ReverbSC_wet', 0, 1);
            add_slider(Master, 'gk_ReverbSC_feedback', 0, 1);
            add_slider(Master, 'gk_ReverbSC_delay_modulation', 0, .01);
            add_slider(Master, 'gk_ReverbSC_frequency_cutoff', 0, 20000);
            var Guitar = gui.addFolder('Guitar');
            add_slider(Guitar, 'gk_Guitar_level', -50, 50);
            var Plucked = gui.addFolder('Plucked');
            add_slider(Plucked, 'gk_Plucked_level', -50, 50);
            var FMWaterBell = gui.addFolder('FMWaterBell');
            add_slider(FMWaterBell, 'gk_FMWaterBell_level', -50, 50);
            add_slider(FMWaterBell, 'gi_FMWaterBell_attack', 0, .1);
            add_slider(FMWaterBell, 'gi_FMWaterBell_release', 0, .1);
            add_slider(FMWaterBell, 'gi_FMWaterBell_exponent', -30, 30);
            add_slider(FMWaterBell, 'gi_FMWaterBell_sustain', 0, 20);
            add_slider(FMWaterBell, 'gi_FMWaterBell_sustain_level', 0, 1);
            add_slider(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 1);
            add_slider(FMWaterBell, 'gk_FMWaterBell_index', 0, 15);
            add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_depth', 0, 10);
            add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_rate', 0, 10);
            var Bower = gui.addFolder('YiString');
            add_slider(Bower, 'gk_YiString_level', -50, 50);
            var Harpsichord = gui.addFolder('Harpsichord');
            add_slider(Harpsichord, 'gk_Harpsichord_level', -50, 50);
            var Flute = gui.addFolder('Zakian Flute');
            add_slider(Flute, 'gk_ZakianFlute_level', -50, 50);
            var Kung4 = gui.addFolder('Kung4');
            add_slider(Kung4, 'gk_Kung4_level', -50, 50);
            var Kung2 = gui.addFolder('Kung2');
            add_slider(Kung2, 'gk_Kung2_level', -50, 50);
            var Bower = gui.addFolder('Bower');
            add_slider(Bower, 'gk_Bower_level', -50, 50);
            add_slider(Bower, 'gk_Bower_pressure', 0, 5);
            document.addEventListener("keydown", function (e) {
                var e_char = String.fromCharCode(e.keyCode || e.charCode);
                if (e.ctrlKey === true) {
                    if (e_char === 'H') {
                        var console = document.getElementById("console");
                        if (console.style.display === "none") {
                            console.style.display = "block";
                        } else {
                            console.style.display = "none";
                        }
                        gui.closed = true;
                        gui.closed = false;
                    } else if (e_char === 'G') {
                        generate();
                    } else if (e_char === 'P') {
                        parameters.play();
                    } else if (e_char === 'S') {
                        parameters.stop();
                    }
                }
            });
        };

        var gk_update = function (name, value) {
            var numberValue = parseFloat(value);
            console.log("gk_update: name: " + name + " value: " + numberValue);
            if (typeof csound !== 'undefined') {
                if (csound !== null) {
                    csound.SetControlChannel(name, numberValue);
                }
            }
        }

        var add_slider = function (gui_folder, token, minimum, maximum, name) {
            var on_parameter_change = function (value) {
                gk_update(token, value);
            };
            gui_folder.add(parameters, token, minimum, maximum).onChange(on_parameter_change);
        };

        window.addEventListener("unload", function (event) {
            nw_window.close();
        });

    </script>

    <!-- endregion -->

    <!-- #region Csound Orchestra -->

    <textarea id="csd" cols=80 rows=24 style="display:none;">

    <CsoundSynthesizer>
    <CsOptions>
    -+msg_color=0 -m162 -d --sample-accurate -f -odac 
    </CsOptions>
    <CsInstruments>
    
    sr = 48000
    ksmps = 128
    nchnls = 2
    0dbfs = 100
    
    gi_ampmidicurve_dynamic_range init .375
    gi_ampmidicurve_exponent init 5
    
    maxalloc 1, 8
    maxalloc 2, 8
    maxalloc 3, 8
    maxalloc 4, 8
    maxalloc 5, 8
    maxalloc 6, 8
    maxalloc 7, 8
    maxalloc 8, 8
    
    connect "Bower", "outleft", "ReverbSC", "inleft"
    connect "Bower", "outright", "ReverbSC", "inright"
    connect "FMWaterBell", "outleft", "ReverbSC", "inleft"
    connect "FMWaterBell", "outright", "ReverbSC", "inright"
    connect "Guitar", "outleft", "ReverbSC", "inleft"
    connect "Guitar", "outleft", "ReverbSC", "inleft"
    connect "Harpsichord", "outleft", "ReverbSC", "inleft"
    connect "Harpsichord", "outright", "ReverbSC", "inright"
    connect "Kung2", "outleft", "ReverbSC", "inleft"
    connect "Kung2", "outright", "ReverbSC", "inright"
    connect "Kung4", "outleft", "ReverbSC", "inleft"
    connect "Kung4", "outright", "ReverbSC", "inright"
    connect "Plucked", "outleft", "ReverbSC", "inleft"
    connect "Plucked", "outright", "ReverbSC", "inright"
    connect "YiString", "outleft", "ReverbSC", "inleft"
    connect "YiString", "outright", "ReverbSC", "inright"
    connect "ZakianFlute", "outleft", "ReverbSC", "inleft"
    connect "ZakianFlute", "outleft", "ReverbSC", "inleft"
    connect "ReverbSC", "outleft", "MasterOutput", "inleft"
    connect "ReverbSC", "outright", "MasterOutput", "inright"
    
    alwayson "ReverbSC"
    alwayson "MasterOutput"
    
    gk_Guitar_midi_dynamic_range chnexport "gk_Guitar_midi_dynamic_range", 3 ; 127
    gk_Guitar_midi_dynamic_range init 30
    gk_Guitar_level chnexport "gk_Guitar_level", 3
    gk_Guitar_level init 0
    gk_Guitar_space_left_to_right chnexport "gk_Guitar_space_left_to_right", 3
    gk_Guitar_space_left_to_right init .5
    
    instr Guitar
    ; Michael Gogins
    ; Simple emulation of a Spanish guitar.
    ; Considerably cleaned up after close listening and systematic testing. 
    ; But I think the plain `pluck` opcode is inherently a bit noisy. The 
    ; waveform is just jagged at first.
    i_instrument = p1
    i_time = p2
    ; Make indefinite notes last no longer than the physical decay.
    i_physical_decay = 20
    if p3 == -1 then
    i_duration = i_physical_decay
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_Guitar_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    if p7 ==0 then
    k_space_left_to_right = gk_Guitar_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 73
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_Guitar_level)
    i_frequency2 = i_frequency
    a_signal pluck 1.0, i_frequency, i_frequency2, 0, 6
    a_top_body reson a_signal, 110, 80
    a_bottom_body reson a_signal, 220, 100
    a_whole_body reson a_signal, 440, 80
    a_signal = (.6 * a_top_body + .8 * a_bottom_body + .6 * a_whole_body + .4 * a_signal) 
    ; For testing envelopes with a simple signal that lacks confounding artifacts.
    ; a_signal oscils .1, i_frequency2, 0
    ; For testing envelopes with a DC signal (shows only the envelope).
    ; a_signal = .25
    
    ; As with most software instruments that are modeled on an impulse exciting a 
    ; resonator, there should be two envelopes. The "physical" envelope must have a 
    ; fixed decay ending at zero.
    i_declick_minimum = .003
    i_attack = .001 / i_frequency + i_declick_minimum
    i_exponent = 7
    a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
    ; The de-clicking envelope must have attack and release segments that damp 
    ; artifacts in the signal. The duration of these segments depends on 
    ; the behavior of the instrument, and may vary as a function of frequency.
    i_declick_attack = i_attack
    i_declick_release = i_declick_minimum * 2
    ; The end of the note must be extended _past_ the end of the release segment.
    xtratim 1
    a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
    ; The envelope of the instrument is the product of the physical envelope times 
    ; the declicking envelope. 
    a_envelope = a_physical_envelope * a_declicking_envelope
    ; That envelope is then low-pass filtered to remove most discontinuities.
    a_filtered_envelope tonex a_envelope, 40, 4
    a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
    
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
    outleta "outleft", a_out_left
    outleta "outright", a_out_right
    #endif
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    gk_Plucked_midi_dynamic_range chnexport "gk_Plucked_midi_dynamic_range", 3 ; 127
    gk_Plucked_midi_dynamic_range init 30
    gk_Plucked_space_left_to_right chnexport "gk_Plucked_space_left_to_right", 3
    gk_Plucked_space_left_to_right init .5
    gk_Plucked_level chnexport "gk_Plucked_level", 3
    gk_Plucked_level init 50
    
    gi_Plucked_sine ftgen 0, 0, 65537, 10, 1
    
    instr Plucked
    ; Author: Michael Gogins
    i_instrument = p1
    i_time = p2
    ; Make indefinite notes last no longer than the physical decay.
    i_physical_decay = 20
    if p3 == -1 then
    i_duration = i_physical_decay
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_Plucked_midi_dynamic_range)
    i_midi_velocity = p5 ;* i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    i_midi_velocity ampmidid i_midi_velocity, i_midi_dynamic_range
    k_space_front_to_back = p6
    if p7 == 0 then
    k_space_left_to_right = gk_Plucked_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_detune_cents = 1.5
    i_detune = i_detune_cents / 100
    i_frequency1 = cpsmidinn(i_midi_key - i_detune)
    i_frequency2 = cpsmidinn(i_midi_key)
    i_frequency3 = cpsmidinn(i_midi_key + i_detune)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_overall_amps = 26
    i_normalization = ampdb(-(i_overall_amps)) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_Plucked_level)
    asignal1 wgpluck2 0.1, 1.0, i_frequency1, 0.25, 0.222
    asignal2 wgpluck2 0.1, 1.0, i_frequency2, 0.20, 0.223
    asignal3 wgpluck2 0.1, 1.0, i_frequency3, 0.23, 0.225
    a_signal = (asignal1 + asignal2 + asignal3)
    ; As with most instruments that are based upon an impulse delivered to a 
    ; resonator, there are two envelopes, one for the physical decay with a 
    ; fixed release ending at zero, and one with a release segment to remove 
    ; clicks from the attack and release.
    ;
    ; As with most software instruments that are modeled on an impulse exciting a 
    ; resonator, there should be two envelopes. The "physical" envelope must have a 
    ; fixed decay ending at zero.
    i_declick_minimum = .001
    i_attack = .001 / i_frequency2 + i_declick_minimum
    i_exponent = 7
    a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
    ; The de-clicking envelope must have attack and release segments that damp 
    ; artifacts in the signal. The duration of these segments depends on 
    ; the behavior of the instrument, and may vary as a function of frequency.
    i_declick_attack = i_attack
    i_declick_release = i_declick_minimum * 2
    ; The end of the note must be extended _past_ the end of the release segment.
    xtratim 1
    a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
    ; The envelope of the instrument is the product of the physical envelope times 
    ; the declicking envelope. 
    a_envelope = a_physical_envelope * a_declicking_envelope
    ; That envelope is then low-pass filtered to remove most discontinuities.
    a_filtered_envelope tonex a_envelope, 40, 4
    a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain
    
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
    outleta "outleft", a_out_left
    outleta "outright", a_out_right
    #endif
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    //////////////////////////////////////////////
    // Original by Steven Yi.
    // Adapted by Michael Gogins.
    //////////////////////////////////////////////
    gk_FMWaterBell_level chnexport "gk_FMWaterBell_level", 3 ; 0
    gi_FMWaterBell_attack chnexport "gi_FMWaterBell_attack", 3 ; 0.002
    gi_FMWaterBell_release chnexport "gi_FMWaterBell_release", 3 ; 0.01
    gi_FMWaterBell_sustain chnexport "gi_FMWaterBell_sustain", 3 ; 20
    gi_FMWaterBell_sustain_level chnexport "gi_FMWaterBell_sustain_level", 3 ; .1
    gk_FMWaterBell_index chnexport "gk_FMWaterBell_index", 3 ; .5
    gk_FMWaterBell_crossfade chnexport "gk_FMWaterBell_crossfade", 3 ; .5
    gk_FMWaterBell_vibrato_depth chnexport "gk_FMWaterBell_vibrato_depth", 3 ; 0.05
    gk_FMWaterBell_vibrato_rate chnexport "gk_FMWaterBell_vibrato_rate", 3 ; 6
    gk_FMWaterBell_midi_dynamic_range chnexport "gk_FMWaterBell_midi_dynamic_range", 3 ; 20
    
    gk_FMWaterBell_level init -8
    gi_FMWaterBell_attack init 0.002
    gi_FMWaterBell_release init 0.01
    gi_FMWaterBell_sustain init 20
    gi_FMWaterBell_sustain_level init .1
    gk_FMWaterBell_index init .5
    gk_FMWaterBell_crossfade init .5
    gk_FMWaterBell_vibrato_depth init 0.05
    gk_FMWaterBell_vibrato_rate init 6
    gk_FMWaterBell_midi_dynamic_range init 20
    
    gk_FMWaterBell_space_left_to_right chnexport "gk_FMWaterBell_space_left_to_right", 3
    gk_FMWaterBell_space_left_to_right init .5
    
    gi_FMWaterBell_cosine ftgen 0, 0, 65537, 11, 1
    
    instr FMWaterBell
    i_instrument = p1
    i_time = p2
    i_duration = p3
    ; One of the envelopes in this instrument should be releasing, and use this:
    i_sustain = 1000
    xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    if p7 ==0 then
    k_space_left_to_right = gk_FMWaterBell_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 80
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization * 1.6
    k_gain = ampdb(gk_FMWaterBell_level)
    i_releasing_attack = 3 / min(i_frequency, 256)
    i_releasing_release = .01
    a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gk_FMWaterBell_crossfade, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine ;, gi_FMWaterBell_sustain
    a_envelope transeg 0, gi_FMWaterBell_attack, 6,  1, gi_FMWaterBell_sustain, -6,  0
    a_declicking cossegr 0, i_releasing_attack, 1, gi_FMWaterBell_sustain - 1, 1, i_releasing_release, 0
    ;;;a_signal = a_signal * i_amplitude * a_envelope * a_declicking * k_gain
    a_signal = a_signal * i_amplitude * a_envelope * a_declicking * k_gain
    
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
    outleta "outleft", a_out_left
    outleta "outright", a_out_right
    #endif
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    gk_YiString_midi_dynamic_range chnexport "gk_YiString_midi_dynamic_range", 3 ;  127
    gk_YiString_level chnexport "gk_YiString_level", 3 ;  0
    gk_YiString_reverb_send chnexport "gk_YiString_reverb_send", 3 ;  .5
    gk_YiString_chorus_send chnexport "gk_YiString_chorus_send", 3 ;  .5
    gi_YiString_overlap chnexport "gi_YiString_overlap", 3 ;  .1
    
    gk_YiString_midi_dynamic_range init 20
    gk_YiString_level init 30
    gk_YiString_reverb_send init .5
    gk_YiString_chorus_send init .5
    gi_YiString_overlap init .1
    
    gk_YiString_space_left_to_right chnexport "gk_YiString_space_left_to_right", 3
    gk_YiString_space_left_to_right init .5
    
    instr YiString
    //////////////////////////////////////////////
    // Original by Steven Yi.
    // Adapted by Michael Gogins.
    //////////////////////////////////////////////
    i_instrument = p1
    i_time = p2
    ; Make indefinite notes last no longer than the physical decay.
    i_physical_duration = 20000
    if p3 == -1 then
    i_duration = i_physical_duration
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_YiString_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    k_space_left_to_right = p7
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 62.25
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_YiString_level)
    iattack = gi_YiString_overlap
    isustain = i_duration
    idecay = gi_YiString_overlap
    xtratim 1
    a_physical_envelope transeg 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, idecay / 2.0, 1.5, i_amplitude / 2.0, idecay / 2.0, -1.5, 0
    ;ampenv = madsr:a(1, 0.1, 0.95, 0.5)
    a_signal = vco2(1, i_frequency)
    a_signal = moogladder(a_signal, 6000, 0.1)
    
    ; The de-clicking envelope must have attack and release segments that damp 
    ; artifacts in the signal. The duration of these segments depends on 
    ; the behavior of the instrument, and may vary as a function of frequency.
    i_declick_attack = iattack
    i_declick_release = i_declick_attack * 2
    ; The end of the note must be extended _past_ the end of the release segment.
    xtratim 1
    a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
    ; The envelope of the instrument is the product of the physical envelope times 
    ; the declicking envelope. 
    a_envelope = a_physical_envelope * a_declicking_envelope
    ; That envelope is then low-pass filtered to remove most discontinuities.
    a_filtered_envelope tonex a_envelope, 40, 4
    a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 
    
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_signal_reverb = a_signal * gk_YiString_reverb_send
    a_signal_chorus = a_signal * gk_YiString_chorus_send
    a_out_left, a_out_right pan2 a_signal_reverb, p7
    outleta "outleft", a_out_left
    outleta "outright",  a_out_right
    a_out_left, a_out_right pan2 a_signal_chorus, p7
    outleta "chorusleft", a_out_left 
    outleta "chorusright", a_out_right 
    ;printks "YiString         %9.4f  %9.4f\n", 0.5, a_out_left, a_out_right
    #endif
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    gk_Harpsichord_level chnexport "gk_Harpsichord_level", 3
    gk_Harpsichord_pick chnexport "gk_Harpsichord_pick", 3
    gk_Harpsichord_reflection chnexport "gk_Harpsichord_reflection", 3
    gk_Harpsichord_pluck chnexport "gk_Harpsichord_pluck", 3
    gk_Harpsichord_midi_dynamic_range chnexport "gk_Harpsichord_midi_dynamic_range", 3
    gk_Harpsichord_space_left_to_right chnexport "gk_Harpsichord_space_left_to_right", 3
    
    gk_Harpsichord_level init 0
    gk_Harpsichord_pick init .075
    gk_Harpsichord_reflection init .5
    gk_Harpsichord_pluck init .75
    gk_Harpsichord_midi_dynamic_range init 20
    gk_Harpsichord_space_left_to_right init .5
    
    gi_Harpsichord_harptable ftgen 0, 0, 65537, 7, -1, 1024, 1, 1024, -1
    
    instr Harpsichord
    i_instrument = p1
    i_time = p2
    ; Make indefinite notes last no longer than the physical decay.
    i_physical_decay = 40
    if p3 == -1 then
    i_duration = i_physical_decay
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_Harpsichord_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    if p7 == 0 then
    k_space_left_to_right = gk_Harpsichord_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 66
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_Harpsichord_level)
    iHz = cpsmidinn(i_midi_key)
    kHz = k(iHz)
    a_physical_envelope transeg 1.0, i_physical_decay, -25.0, 0.0
    apluck pluck i_amplitude * k_gain, kHz, iHz, 0, 1
    aharp poscil a_physical_envelope, kHz, gi_Harpsichord_harptable
    aharp2 balance apluck, aharp
    a_signal	= (apluck + aharp2)
    i_attack = .0005
    i_sustain = p3
    i_release = 0.01
    ; The end of the note must be extended _past_ the end of the release segment.
    xtratim 1
    i_declick_attack init .0008
    i_declick_release init .01
    a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
    a_envelope = a_declicking_envelope
    a_filtered_envelope tonex a_envelope, 40, 4
    a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 
    
    
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
    outleta "outleft", a_out_left
    outleta "outright", a_out_right
    #endif
    ;printks "Harpsichord      %9.4f   %9.4f\n", 0.5, a_out_left, a_out_right
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    gk_ZakianFlute_midi_dynamic_range chnexport "gk_ZakianFlute_midi_dynamic_range", 3 ;  20
    gk_ZakianFlute_level chnexport "gk_ZakianFlute_level", 3 ;  0
    gk_ZakianFlute_pan chnexport "gk_ZakianFlute_pan", 3 ;  .5
    gi_ZakianFLute_seed chnexport "gi_ZakianFLute_seed", 3 ;  .5
    gi_ZakianFLute_space_left_to_front chnexport "gi_ZakianFLute_space_left_to_front", 3 ;  .5
    
    gk_ZakianFlute_midi_dynamic_range init 20
    gk_ZakianFlute_level init -16
    gk_ZakianFlute_pan init .5
    gi_ZakianFLute_seed init .5
    gi_ZakianFLute_space_left_to_front init .5
    
    gi_ZakianFLute_f2  ftgen 0, 0, 16, -2, 40, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 10240
    gi_ZakianFlute_f26 ftgen 0, 0, 65537, -10, 2000, 489, 74, 219, 125, 9, 33, 5, 5
    gi_ZakianFlute_f27 ftgen 0, 0, 65537, -10, 2729, 1926, 346, 662, 537, 110, 61, 29, 7
    gi_ZakianFlute_f28 ftgen 0, 0, 65537, -10, 2558, 2012, 390, 361, 534, 139, 53, 22, 10, 13, 10
    gi_ZakianFlute_f29 ftgen 0, 0, 65537, -10, 12318, 8844, 1841, 1636, 256, 150, 60, 46, 11
    gi_ZakianFlute_f30 ftgen 0, 0, 65537, -10, 1229, 16, 34, 57, 32
    gi_ZakianFlute_f31 ftgen 0, 0, 65537, -10, 163, 31, 1, 50, 31
    gi_ZakianFlute_f32 ftgen 0, 0, 65537, -10, 4128, 883, 354, 79, 59, 23
    gi_ZakianFlute_f33 ftgen 0, 0, 65537, -10, 1924, 930, 251, 50, 25, 14
    gi_ZakianFlute_f34 ftgen 0, 0, 65537, -10, 94, 6, 22, 8
    gi_ZakianFlute_f35 ftgen 0, 0, 65537, -10, 2661, 87, 33, 18
    gi_ZakianFlute_f36 ftgen 0, 0, 65537, -10, 174, 12
    gi_ZakianFlute_f37 ftgen 0, 0, 65537, -10, 314, 13
    gi_ZakianFlute_wtsin ftgen 0, 0, 65537, 10, 1
    
    instr ZakianFlute
    ; Author: Lee Zakian
    ; Adapted by: Michael Gogins
    i_instrument = p1
    i_time = p2
    if p3 == -1 then
    i_duration = 1000
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_velocity = p5
    k_space_front_to_back = p6
    if p7 == 0 then
    k_space_left_to_right = gi_ZakianFLute_space_left_to_front
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_overall_amps = 65.2
    i_normalization = ampdb(-i_overall_amps) / 2
    i_midi_dynamic_range = i(gk_ZakianFlute_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_ZakianFlute_level)
    ;;;xtratim iattack + irelease
    iHz = cpsmidinn(i_midi_key)
    kHz = k(iHz)
    // Bug?
    // aenvelope transeg 1.0, 20.0, -10.0, 0.05
    aenvelope transegr 1.0, 20.0, -10.0, 0.05
    ip3 = 3;;; (p3 < 3.0 ? p3 : 3.0)
    ; parameters
    ; p4 overall amplitude scaling factor
    ip4 init i_amplitude
    ; p5 pitch in Hertz (normal pitch range: C4-C7)
    ip5 init iHz
    ; p6 percent vibrato depth, recommended values in range [-1., +1.]
    ip6 init 0.5
    ; 0.0 -> no vibrato
    ; +1. -> 1% vibrato depth, where vibrato rate increases slightly
    ; -1. -> 1% vibrato depth, where vibrato rate decreases slightly
    ; p7 attack time in seconds
    ; recommended value: .12 for slurred notes, .06 for tongued notes
    ; (.03 for short notes)
    ip7 init .08
    ; p8 decay time in seconds
    ; recommended value: .1 (.05 for short notes)
    ip8 init .08
    ; p9 overall brightness / filter cutoff factor
    ; 1 -> least bright / minimum filter cutoff frequency (40 Hz)
    ; 9 -> brightest / maximum filter cutoff frequency (10,240Hz)
    ip9 init 5
    ; initial variables
    iampscale = ip4 ; overall amplitude scaling factor
    ifreq = ip5 ; pitch in Hertz
    ivibdepth = abs(ip6*ifreq/100.0) ; vibrato depth relative to fundamental frequency
    iattack = ip7 * (1.1 - .2*gi_ZakianFLute_seed) ; attack time with up to +-10% random deviation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947) ; reset gi_ZakianFLute_seed
    idecay = ip8 * (1.1 - .2*gi_ZakianFLute_seed) ; decay time with up to +-10% random deviation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    ifiltcut tablei ip9, gi_ZakianFLute_f2 ; lowpass filter cutoff frequency
    iattack = (iattack < 6/kr ? 6/kr : iattack) ; minimal attack length
    idecay = (idecay < 6/kr ? 6/kr : idecay) ; minimal decay length
    isustain = i_duration - iattack - idecay
    ;;;p3 = (isustain < 5/kr ? iattack+idecay+5/kr : i_duration) ; minimal sustain length
    isustain = (isustain < 5/kr ? 5/kr : isustain)
    iatt = iattack/6
    isus = isustain/4
    idec = idecay/6
    iphase = gi_ZakianFLute_seed ; use same phase for all wavetables
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    ; vibrato block
    ; kvibdepth linseg .1, .8*p3, 1, .2*p3, .7
    kvibdepth linseg .1, .8*ip3, 1, isustain, 1, .2*ip3, .7
    kvibdepth = kvibdepth* ivibdepth ; vibrato depth
    kvibdepthr randi .1*kvibdepth, 5, gi_ZakianFLute_seed ; up to 10% vibrato depth variation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kvibdepth = kvibdepth + kvibdepthr
    ivibr1 = gi_ZakianFLute_seed ; vibrato rate
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    ivibr2 = gi_ZakianFLute_seed
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    if ip6 < 0 goto vibrato1
    kvibrate linseg 2.5+ivibr1, isustain, 4.5+ivibr2 ; if p6 positive vibrato gets faster
    goto vibrato2
    vibrato1:
    ivibr3 = gi_ZakianFLute_seed
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kvibrate linseg 3.5+ivibr1, .1, 4.5+ivibr2,isustain-.1, 2.5+ivibr3 ; if p6 negative vibrato gets slower
    vibrato2:
    kvibrater randi .1*kvibrate, 5, gi_ZakianFLute_seed ; up to 10% vibrato rate variation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kvibrate = kvibrate + kvibrater
    kvib oscili kvibdepth, kvibrate, gi_ZakianFlute_wtsin
    ifdev1 = -.03 * gi_ZakianFLute_seed ; frequency deviation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    ifdev2 = .003 * gi_ZakianFLute_seed
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    ifdev3 = -.0015 * gi_ZakianFLute_seed
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    ifdev4 = .012 * gi_ZakianFLute_seed
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kfreqr linseg ifdev1, iattack, ifdev2, isustain, ifdev3, idecay, ifdev4
    kfreq = kHz * (1 + kfreqr) + kvib
    if ifreq < 427.28 goto range1 ; (cpspch(8.08) + cpspch(8.09))/2
    if ifreq < 608.22 goto range2 ; (cpspch(9.02) + cpspch(9.03))/2
    if ifreq < 1013.7 goto range3 ; (cpspch(9.11) + cpspch(10.00))/2
    goto range4
    ; wavetable amplitude envelopes
    range1: ; for low range tones
    kamp1 linseg 0, iatt, 0.002, iatt, 0.045, iatt, 0.146, iatt, \
    0.272, iatt, 0.072, iatt, 0.043, isus, 0.230, isus, 0.000, isus, \
    0.118, isus, 0.923, idec, 1.191, idec, 0.794, idec, 0.418, idec, \
    0.172, idec, 0.053, idec, 0
    kamp2 linseg 0, iatt, 0.009, iatt, 0.022, iatt, -0.049, iatt, \
    -0.120, iatt, 0.297, iatt, 1.890, isus, 1.543, isus, 0.000, isus, \
    0.546, isus, 0.690, idec, -0.318, idec, -0.326, idec, -0.116, idec, \
    -0.035, idec, -0.020, idec, 0
    kamp3 linseg 0, iatt, 0.005, iatt, -0.026, iatt, 0.023, iatt, \
    0.133, iatt, 0.060, iatt, -1.245, isus, -0.760, isus, 1.000, isus, \
    0.360, isus, -0.526, idec, 0.165, idec, 0.184, idec, 0.060, idec, \
    0.010, idec, 0.013, idec, 0
    iwt1 = gi_ZakianFlute_f26 ; wavetable numbers
    iwt2 = gi_ZakianFlute_f27
    iwt3 = gi_ZakianFlute_f28
    inorm = 3949
    goto end
    range2: ; for low mid-range tones
    kamp1 linseg 0, iatt, 0.000, iatt, -0.005, iatt, 0.000, iatt, \
    0.030, iatt, 0.198, iatt, 0.664, isus, 1.451, isus, 1.782, isus, \
    1.316, isus, 0.817, idec, 0.284, idec, 0.171, idec, 0.082, idec, \
    0.037, idec, 0.012, idec, 0
    kamp2 linseg 0, iatt, 0.000, iatt, 0.320, iatt, 0.882, iatt, \
    1.863, iatt, 4.175, iatt, 4.355, isus, -5.329, isus, -8.303, isus, \
    -1.480, isus, -0.472, idec, 1.819, idec, -0.135, idec, -0.082, idec, \
    -0.170, idec, -0.065, idec, 0
    kamp3 linseg 0, iatt, 1.000, iatt, 0.520, iatt, -0.303, iatt, \
    0.059, iatt, -4.103, iatt, -6.784, isus, 7.006, isus, 11, isus, \
    12.495, isus, -0.562, idec, -4.946, idec, -0.587, idec, 0.440, idec, \
    0.174, idec, -0.027, idec, 0
    iwt1 = gi_ZakianFlute_f29
    iwt2 = gi_ZakianFlute_f30
    iwt3 = gi_ZakianFlute_f31
    inorm = 27668.2
    goto end
    range3: ; for high mid-range tones
    kamp1 linseg 0, iatt, 0.005, iatt, 0.000, iatt, -0.082, iatt, \
    0.36, iatt, 0.581, iatt, 0.416, isus, 1.073, isus, 0.000, isus, \
    0.356, isus, .86, idec, 0.532, idec, 0.162, idec, 0.076, idec, 0.064, \
    idec, 0.031, idec, 0
    kamp2 linseg 0, iatt, -0.005, iatt, 0.000, iatt, 0.205, iatt, \
    -0.284, iatt, -0.208, iatt, 0.326, isus, -0.401, isus, 1.540, isus, \
    0.589, isus, -0.486, idec, -0.016, idec, 0.141, idec, 0.105, idec, \
    -0.003, idec, -0.023, idec, 0
    kamp3 linseg 0, iatt, 0.722, iatt, 1.500, iatt, 3.697, iatt, \
    0.080, iatt, -2.327, iatt, -0.684, isus, -2.638, isus, 0.000, isus, \
    1.347, isus, 0.485, idec, -0.419, idec, -.700, idec, -0.278, idec, \
    0.167, idec, -0.059, idec, 0
    iwt1 = gi_ZakianFlute_f32
    iwt2 = gi_ZakianFlute_f33
    iwt3 = gi_ZakianFlute_f34
    inorm = 3775
    goto end
    range4: ; for high range tones
    kamp1 linseg 0, iatt, 0.000, iatt, 0.000, iatt, 0.211, iatt, \
    0.526, iatt, 0.989, iatt, 1.216, isus, 1.727, isus, 1.881, isus, \
    1.462, isus, 1.28, idec, 0.75, idec, 0.34, idec, 0.154, idec, 0.122, \
    idec, 0.028, idec, 0
    kamp2 linseg 0, iatt, 0.500, iatt, 0.000, iatt, 0.181, iatt, \
    0.859, iatt, -0.205, iatt, -0.430, isus, -0.725, isus, -0.544, isus, \
    -0.436, isus, -0.109, idec, -0.03, idec, -0.022, idec, -0.046, idec, \
    -0.071, idec, -0.019, idec, 0
    kamp3 linseg 0, iatt, 0.000, iatt, 1.000, iatt, 0.426, iatt, \
    0.222, iatt, 0.175, iatt, -0.153, isus, 0.355, isus, 0.175, isus, \
    0.16, isus, -0.246, idec, -0.045, idec, -0.072, idec, 0.057, idec, \
    -0.024, idec, 0.002, idec, 0
    iwt1 = gi_ZakianFlute_f35
    iwt2 = gi_ZakianFlute_f36
    iwt3 = gi_ZakianFlute_f37
    inorm = 4909.05
    goto end
    end:
    kampr1 randi .02*kamp1, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kamp1 = kamp1 + kampr1
    kampr2 randi .02*kamp2, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kamp2 = kamp2 + kampr2
    kampr3 randi .02*kamp3, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
    gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
    kamp3 = kamp3 + kampr3
    awt1 poscil kamp1, kfreq, iwt1, iphase ; wavetable lookup
    awt2 poscil kamp2, kfreq, iwt2, iphase
    awt3 poscil kamp3, kfreq, iwt3, iphase
    asig = awt1 + awt2 + awt3
    asig = asig*(iampscale/inorm)
    kcut linseg 0, iattack, ifiltcut, isustain, ifiltcut, idecay, 0 ; lowpass filter for brightness control
    afilt tone asig, kcut
    a_signal balance afilt, asig
    i_attack = .002
    i_sustain = i_duration
    i_release = 0.01
    i_declick_attack = i_attack
    i_declick_release = i_declick_attack * 2
    ; The end of the note must be extended _past_ the end of the release segment.
    xtratim 1
    a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
    ; That envelope is then low-pass filtered to remove most discontinuities.
    a_filtered_envelope tonex a_declicking_envelope, 40, 4
    a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 
    
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_signal *= .7
    a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
    outleta "outleft", a_out_left
    outleta "outright", a_out_right
    #endif
    endin
    
    gi_Kung4_detune_cents chnexport "gk_Kung4_detune_cents", 3
    gi_Kung4_detune_cents init 8
    gk_Kung4_level chnexport "gk_Kung4_level", 3
    gk_Kung4_level init -20
    gk_Kung4_midi_dynamic_range chnexport "gk_Kung4_midi_dynamic_range", 3
    gk_Kung4_midi_dynamic_range init 30
    gk_Kung4_space_left_to_right chnexport "gk_Kung4_space_left_to_right", 3
    gk_Kung4_space_left_to_right init .5
    gi_Kung4_modulation_ratio_start chnexport "gi_Kung4_modulation_ratio_start", 3
    gi_Kung4_modulation_ratio_start init 1.7
    gi_Kung4_modulation_ratio_end chnexport "gi_Kung4_modulation_ratio_end", 3
    gi_Kung4_modulation_ratio_end init .5
    
    gi_Kung4_sine ftgen 0, 0, 65537, 10, 1
    gi_Kung4_cosine ftgen 0, 0, 65537, 11, 1
    gi_Kung4_ln ftgen 0, 9, 65537, -12, 20.0  ;unscaled ln(I(x)) from 0 to 20.0
    /**
     * This is yet another attempt to adapt this beautiful sound for use in 
     * wider contexts.
     */
    instr Kung4
    i_instrument = p1
    i_time = p2
    ; Make indefinite notes last no longer than the physical decay.
    i_instrument_duration = 999999
    if p3 == -1 then
    i_duration = i_instrument_duration
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_Kung4_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    if p7 ==0 then
    k_space_left_to_right = gk_Kung4_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 130 + 8 + 6
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_Kung4_level)
    ishift = gi_Kung4_detune_cents/12000
    ipch = cpsmidinn(i_midi_key)
    ioct = octmidinn(i_midi_key)
    kvib poscil 1/120, ipch/50, gi_Kung4_sine
    ; The instrument envelope should observe limits.
    if (i_duration > 10) then
    i_instrument_attack = 10 / 3
    elseif (i_duration < 1) then
    i_instrument_attack = 1 / 3
    else
    i_instrument_attack = i_duration / 3
    endif
    ;i_instrument_duration -= (2 * i_instrument_attack)
    aadsr linsegr 0, i_instrument_attack, 1.0, i_duration, 1.0, i_instrument_attack, 0 ;ADSR envelope
    amodi linseg 0, i_instrument_attack, 5, i_duration, 3, i_instrument_attack, 0 ;ADSR envelope for I
    amodr linseg gi_Kung4_modulation_ratio_start, i_duration, gi_Kung4_modulation_ratio_end ;r moves from p6->p7 in p3 sec.
    a1 = amodi*(amodr-1/amodr)/2
    a1ndx = abs(a1*2/20) ;a1*2 is normalized from 0-1.
    a2 = amodi*(amodr+1/amodr)/2
    a3 tablei a1ndx, gi_Kung4_ln, 1 ;lookup tbl in f3, normal index
    ao1 poscil a1, ipch, gi_Kung4_cosine ;cosine
    a4 = exp(-0.5*a3+ao1)
    ao2 poscil a2*ipch, ipch, gi_Kung4_cosine ;cosine
    a_out_left poscil 1000*aadsr*a4, ao2+cpsoct(ioct+ishift), gi_Kung4_sine ;fnl outleft
    a_out_right poscil 1000*aadsr*a4, ao2+cpsoct(ioct-ishift), gi_Kung4_sine ;fnl outright
    i_declick_minimum = .003
    i_attack = .001 / i_frequency + i_declick_minimum
    i_exponent = 7
    a_physical_envelope = aadsr ;  transeg 0,   i_attack, i_exponent,  1,   i_duration, -i_exponent,  0
    ; The de-clicking envelope must have attack and release segments that damp 
    ; artifacts in the signal. The duration of these segments depends on 
    ; the behavior of the instrument, and may vary as a function of frequency.
    i_declick_attack = i_attack
    i_declick_release = i_declick_minimum * 2
    ; The end of the note must be extended _past_ the end of the release segment.
    xtratim 5
    a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
    ; The envelope of the instrument is the product of the physical envelope times 
    ; the declicking envelope. 
    a_envelope = a_physical_envelope * a_declicking_envelope
    ; That envelope is then low-pass filtered to remove most discontinuities.
    a_filtered_envelope tonex a_envelope, 40, 4
    a_out_left = a_out_left * i_amplitude * a_filtered_envelope * k_gain 
    a_out_right = a_out_right * i_amplitude * a_filtered_envelope * k_gain 
    
    outleta "outleft", a_out_left 
    outleta "outright", a_out_right
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    /**
     * This is yet another attempt to adapt this beautiful sound for use in 
     * wider contexts. 
     *
     * In its original form this could not work without artifacts because of the 
     * k-rate frequency modulation of the pluck opcode.
     */
    gi_Kung2_detune_cents chnexport "gk_Kung2_detune_cents", 3
    gi_Kung2_detune_cents init 8
    gk_Kung2_level chnexport "gk_Kung2_level", 3
    gk_Kung2_level init 0
    gk_Kung2_midi_dynamic_range chnexport "gk_Kung2_midi_dynamic_range", 3
    gk_Kung2_midi_dynamic_range init 30
    gk_Kung2_space_left_to_right chnexport "gk_Kung2_space_left_to_right", 3
    gk_Kung2_space_left_to_right init .5
    gi_Kung2_sine ftgen 0, 0, 65537, 10, 1
    opcode Kung2_, aa, 0
    setksmps 1
    i_instrument = p1
    i_time = p2
    ; Make indefinite notes last no longer than the physical decay.
    i_instrument_duration = 999999
    if p3 == -1 then
    i_duration = i_instrument_duration
    else
    i_duration = p3
    endif
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_Kung2_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    if p7 ==0 then
    k_space_left_to_right = gk_Kung2_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 21 + 51 + 7
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_Kung2_level)
    ishift = gi_Kung2_detune_cents/12000
    ipch = cpsmidinn(i_midi_key)
    ioct = octmidinn(i_midi_key)
    i_vibrato_frequency = (i_midi_key / 127) * 2
    kvib poscil3 1/120, i_vibrato_frequency, gi_Kung2_sine
    ag pluck 1, cpsoct(ioct+kvib), 1000, gi_Kung2_sine, 1
    agleft pluck 1, cpsoct(ioct+ishift), 1000, gi_Kung2_sine, 1
    agright pluck 1, cpsoct(ioct-ishift), 1000, gi_Kung2_sine, 1
    i_physical_decay = 20
    ; As with most software instruments that are modeled on an impulse exciting a 
    ; resonator, there should be two envelopes. The "physical" envelope must have a 
    ; fixed decay ending at zero.
    i_declick_minimum = .003
    i_attack = .001 / i_frequency + i_declick_minimum
    i_exponent = 3
    a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
    a_declicking_envelope cossegr 0, .006, 1, i_instrument_duration, 1,  .06, 0
    a_envelope = a_physical_envelope * a_declicking_envelope
    a_filtered_envelope tonex a_envelope, 30, 3
    xtratim 3
    ag = a_declicking_envelope * ag
    agleft = a_declicking_envelope * agleft
    agright = a_declicking_envelope * agright
    adump delayr 0.3
    ad1 deltap3 0.1
    ad2 deltap3 0.2
    delayw ag
    a_out_left = agleft + ad1
    a_out_right = agright + ad2
    a_filtered_declicking tonex a_declicking_envelope, 30, 4
    a_out_left = a_out_left * k_gain * i_amplitude * a_filtered_declicking
    a_out_right = a_out_right * k_gain * i_amplitude * a_filtered_declicking 
    xout a_out_left, a_out_right
    endop
    
    instr Kung2
    a_out_left, a_out_right Kung2_
    outleta "outleft", a_out_left 
    outleta "outright", a_out_right
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    gk_Bower_midi_dynamic_range chnexport "gk_Bower_midi_dynamic_range", 3
    gk_Bower_attack chnexport "gk_Bower_attack", 3
    gk_Bower_release chnexport "gk_Bower_release", 3
    gk_Bower_level chnexport "gk_Bower_level", 3
    gk_Bower_pressure chnexport "gk_Bower_pressure", 3
    gk_Bower_space_left_to_right chnexport "gk_Bower_space_left_to_right", 3
    
    gk_Bower_midi_dynamic_range init 20
    gk_Bower_attack init .125
    gk_Bower_release init .125
    gk_Bower_level init 0
    gk_Bower_pressure init 0.25
    gk_Bower_space_left_to_right init 0.75
    
    gi_Bower_sine ftgen 0,0,65537,10,1
    
    instr Bower
    i_instrument = p1
    i_time = p2
    i_duration = p3
    i_midi_key = p4
    i_midi_dynamic_range = i(gk_Bower_midi_dynamic_range)
    i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
    k_space_front_to_back = p6
    if p7 == 0 then
    k_space_left_to_right = gk_Bower_space_left_to_right
    else
    k_space_left_to_right = p7
    endif
    k_space_bottom_to_top = p8
    k_space_bottom_to_top = p8
    i_phase = p9
    i_frequency = cpsmidinn(i_midi_key)
    ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
    i_level_correction = 66
    i_normalization = ampdb(-i_level_correction) / 2
    i_amplitude = ampdb(i_midi_velocity) * i_normalization
    k_gain = ampdb(gk_Bower_level)
    iattack = i(gk_Bower_attack)
    idecay = i(gk_Bower_release)
    isustain = p3
    iamp = i_amplitude
    xtratim iattack + idecay
    kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
    ihertz = cpsmidinn(i_midi_key)
    kamp = kenvelope
    kfreq = ihertz
    kpres = 0.25
    krat rspline 0.006,0.988,1,4
    kvibf = 4.5
    kvibamp = 0
    iminfreq = i(kfreq) / 1.5
    aSig wgbow kamp,kfreq,gk_Bower_pressure,krat,kvibf,kvibamp,gi_Bower_sine,iminfreq
    a_signal = aSig * kenvelope * k_gain
    
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    #ifdef USE_SPATIALIZATION
    a_spatial_reverb_send init 0
    a_bsignal[] init 16
    a_bsignal, a_spatial_reverb_send Spatialize a_signal, k_space_front_to_back, k_space_left_to_right, k_space_bottom_to_top
    outletv "outbformat", a_bsignal
    outleta "out", a_spatial_reverb_send
    #else
    a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
    outleta "outleft", a_out_left
    outleta "outright", a_out_right
    #endif
    ;printks "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
    endin
    
    gk_ReverbSC_feedback chnexport "gk_ReverbSC_feedback", 3
    gk_ReverbSC_wet chnexport "gk_ReverbSC_wet", 3
    gi_ReverbSC_delay_modulation chnexport "gi_ReverbSC_delay_modulation", 3
    gk_ReverbSC_frequency_cutoff chnexport "gk_ReverbSC_frequency_cutoff", 3
    
    gk_ReverbSC_feedback init 0.875
    gk_ReverbSC_wet init 0.5
    gi_ReverbSC_delay_modulation init 0.0075
    gk_ReverbSC_frequency_cutoff init 15000
    
    instr ReverbSC
    gk_ReverbSC_dry = 1.0 - gk_ReverbSC_wet
    aleftin init 0
    arightin init 0
    aleftout init 0
    arightout init 0
    aleftin inleta "inleft"
    arightin inleta "inright"
    aleftout, arightout reverbsc aleftin, arightin, gk_ReverbSC_feedback, gk_ReverbSC_frequency_cutoff, sr, gi_ReverbSC_delay_modulation
    aleftoutmix = aleftin * gk_ReverbSC_dry + aleftout * gk_ReverbSC_wet
    arightoutmix = arightin * gk_ReverbSC_dry + arightout * gk_ReverbSC_wet
    outleta "outleft", aleftoutmix
    outleta "outright", arightoutmix
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    endin
    
    gk_MasterOutput_level chnexport "gk_MasterOutput_level", 3 ; 0
    gS_MasterOutput_filename chnexport "gS_MasterOutput_filename", 3 ; ""
    
    gk_MasterOutput_level init 0
    gS_MasterOutput_filename init ""

    chn_k "gk_MasterOutput_output_level_left", 3
    chn_k "gk_MasterOutput_output_level_right", 3

    instr MasterOutput
    aleft inleta "inleft"
    aright inleta "inright"
    k_gain = ampdb(gk_MasterOutput_level)
    printks2 "Master gain: %f\n", k_gain
    iamp init 1
    aleft butterlp aleft, 18000
    aright butterlp aright, 18000
    a_out_left = aleft * k_gain
    a_out_right = aright * k_gain
    outs a_out_left, a_out_right
    ; We want something that will play on my phone.
    i_amplitude_adjustment = ampdbfs(-3) / 32767
    i_filename_length strlen gS_MasterOutput_filename
    if i_filename_length > 0 then
    prints sprintf("Output filename: %s\n", gS_MasterOutput_filename)
    fout gS_MasterOutput_filename, 18, a_out_left * i_amplitude_adjustment, a_out_right * i_amplitude_adjustment
    endif
    prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
    gk_MasterOutput_output_level_left = dbfsamp(rms(a_out_left))
    gk_MasterOutput_output_level_right = dbfsamp(rms(a_out_right))
    chnset gk_MasterOutput_output_level_left, "gk_MasterOutput_output_level_left"
    chnset gk_MasterOutput_output_level_right, "gk_MasterOutput_output_level_right"
    printks "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), gk_MasterOutput_output_level_left, gk_MasterOutput_output_level_right
    endin
    
    </CsInstruments>
    <CsScore>
    
    </CsScore>
    </CsoundSynthesizer>
    
  </textarea>

    <!-- endregion -->

    <!-- #region Log -->

    <div id="console_view" class="w3-text-sand"
        style="position:absolute;top:60px;z-index:4;width:100vw;height:90vh;background:transparent;margin-left:53px;opacity:60%">
    </div>

    <!-- endregion -->

    <!-- #region Main Menu and Infrastructure -->

    <script>
        if ('caches' in window) {
            caches.keys().then(function (names) {
                for (let name of names)
                    caches.delete(name);
                console.log(`deleted ${name} from caches.`);
            });
        }
    </script>

    <!-- The menu bar has to stack on top of all layers in order for the 
       dat.gui controls to work. -->

    <div class="w3-bar" id="main_menu" style="position:fixed;background:transparent;z-index:100;">
        <ul class="menu" id="main_menu_list">
            <li id="menu_item_play" class="w3-btn w3-hover-text-light-green">Play</li>
            <!-- <li id="menu_item_render" class="w3-btn w3-hover-text-light-green">Render</li> -->
            <li id="menu_item_stop" class="w3-btn w3-hover-text-light-green">Stop</li>
            <li id="menu_item_fullscreen" class="w3-btn w3-hover-text-light-green">Fullscreen</li>
            <!-- <li id="menu_item_strudel" class="w3-btn w3-hover-text-light-green">Strudel</li> -->
            <!-- <li id="menu_item_score" class="w3-btn w3-hover-text-light-green">Score</li> -->
            <li id="menu_item_console" class="w3-btn w3-hover-text-light-green">Log</li>
            <li id="menu_item_about" class="w3-btn w3-hover-text-light-green">About Cloud Music No. 1</li>
            <li id="mini_console" class="w3-btn w3-text-green w3-hover-text-light-green"></li>
            <li id="vu_meter_left" class="w3-btn w3-hover-text-light-green"></li>
            <li id="vu_meter_right" class="w3-btn w3-hover-text-light-green"></li>
            <li id="menu_item_dat_gui" class="w3-btn w3-left-align w3-hover-text-light-green w3-right"></li>
        </ul>
    </div>

    <script>

        var message_callback_buffer = "";
        var console_editor = ace.edit("console_view");
        //console_editor.setTheme("ace/theme/gob");
        console_editor.setReadOnly(true);
        console_editor.setShowPrintMargin(false);
        console_editor.setDisplayIndentGuides(false);
        console_editor.renderer.setOption("showGutter", false);
        console_editor.renderer.setOption("showLineNumbers", true);

        var csound_message_callback = async function (message) {
            if (message === null) {
                return;
            }
            let level_left = -100;
            let level_right = -100;
            if (csound) {
                (async function () {
                    score_time = await csound.GetScoreTime();
                    level_left = await csound.GetControlChannel("gk_MasterOutput_output_level_left");
                    level_right = await csound.GetControlChannel("gk_MasterOutput_output_level_right");
                    let delta = score_time;
                    // calculate (and subtract) whole days
                    let days = Math.floor(delta / 86400);
                    delta -= days * 86400;
                    // calculate (and subtract) whole hours
                    let hours = Math.floor(delta / 3600) % 24;
                    delta -= hours * 3600;
                    // calculate (and subtract) whole minutes
                    let minutes = Math.floor(delta / 60) % 60;
                    delta -= minutes * 60;
                    // what's left is seconds
                    let seconds = delta % 60;  // in theory the modulus is not required
                    if (level_left > 0) {
                        $("#vu_meter_left").css("color", "red");
                    } else if (level_left > -12) {
                        $("#vu_meter_left").css("color", "orange")
                    } else {
                        $("#vu_meter_left").css("color", "lightgreen");
                    }
                    if (level_right > 0) {
                        $("#vu_meter_right").css("color", "red");
                    } else if (level_right > -12) {
                        $("#vu_meter_right").css("color", "orange")
                    } else {
                        $("#vu_meter_right").css("color", "lightgreen");
                    }
                    $("#mini_console").html(sprintf("d:%4d h:%02d m:%02d s:%06.3f", days, hours, minutes, seconds));
                    $("#vu_meter_left").html(sprintf("L%+7.1f dBA", level_right));
                    $("#vu_meter_right").html(sprintf("R%+7.1f dBA", level_right));
                }());
            }
            // Split in case the newline is in the middle of the message but 
            // not at the end?
            message_callback_buffer = message_callback_buffer + message;
            if (message_callback_buffer.endsWith("\n")) {
                console.log(message_callback_buffer);
                let lines = console_editor.getSession().getLength();
                // Prevent the console editor from hogging memory.
                if (lines > 5000) {
                    console_editor.getSession().removeFullLines(0, 2500);
                    lines = console_editor.getSession().getLength();
                }
                console_editor.moveCursorTo(lines, 0);
                console_editor.scrollToLine(lines);
                console_editor.insert(message_callback_buffer);
                message_callback_buffer = "";
            }
        };

        var interval_id = null;

        var trackScoreTime = function () {
            var score_time = csound.getScoreTime();
            interval_id = setTimeout(trackScoreTime, 200);
            lsys.score.progress3D(score_time);
            // Reset buttons.
            if (csound.isPlaying() == false) {
                $("#menu_item_play").html("Play");
                $("#menu_item_render").html("Render");
            }
        };

        $(window).on("load", async function () {
            csound_message_callback("$(window).on(\"load\"...\n");
            var txt = "\n";
            txt += "Browser CodeName: " + navigator.appCodeName + "\n";
            txt += "Browser Name: " + navigator.appName + "\n";
            txt += "Browser Version: " + navigator.appVersion + "\n";
            txt += "Cookies Enabled: " + navigator.cookieEnabled + "\n";
            txt += "Browser Language: " + navigator.language + "\n";
            txt += "Browser Online: " + navigator.onLine + "\n";
            txt += "Platform: " + navigator.platform + "\n";
            txt += "User-agent header: " + navigator.userAgent + "\n";
            txt += "gl.VENDOR: " + gl.getParameter(gl.VENDOR) + "\n";
            txt += "gl.RENDERER: " + gl.getParameter(gl.RENDERER) + "\n";
            txt += "gl.VERSION: " + gl.getParameter(gl.VERSION) + "\n";
            txt += "gl.SHADING_LANGUAGE_VERSION: " + gl.getParameter(gl.SHADING_LANGUAGE_VERSION) + "\n";
            csound_message_callback(txt);
            CsoundAC = await createCsoundAC();
            csound_message_callback("CsoundAC: " + CsoundAC);
            score = new CsoundAC.Score();
            scale = new CsoundAC.Scale("F major");
            chord = scale.chord(1, 5, 3);
            //CsoundAC.CHORD_SPACE_DEBUGGING(false);
            build_dat_gui_menu();
            load_scene();
            $("#strudel_view").css("display", "none");
            $("#score_view").css("display", "none");
            $("#about_view").css("display", "none");
            $("#console_view").css("display", "none");
            $("#menu_item_play").click(async function (event) {
                console.log("menu_item_play click...");
                try {
                    csound_message_callback("Trying to load CsoundAudioNode...\n");
                    var AudioContext = window.AudioContext || window.webkitAudioContext;
                    var audioContext = new AudioContext();
                    await audioContext.audioWorklet.addModule('CsoundAudioProcessor.js').then(function () {
                        csound_message_callback("Creating CsoundAudioNode...\n");
                        csound = new CsoundAudioNode(audioContext, csound_message_callback);
                        csound_message_callback("CsoundAudioNode (AudioWorklet) is available in this JavaScript context.\n");
                        analyser = new AnalyserNode(audioContext);
                        analyser.fftSize = 2048;
                        console.log("Analyzer buffer size: " + analyser.frequencyBinCount);
                        csound.connect(analyser);
                        console.log("csound: " + csound);
                    }, function (error) {
                        csound_message_callback(error + '\n');
                    });
                    csound_image_player = new CsoundImagePlayer(csound, CsoundAC, canvas);
                } catch (e) {
                    csound_message_callback(e + '\n');
                }
                let csd = await document.getElementById('csd').value;
                console_editor.setValue("");
                let result = await csound.CompileCsdText(csd);
                csound_message_callback("CompileCsdText returned: " + result);
                await csound.Start();
                // Send _current_ dat.gui control channel values to Csound 
                // before actually performing. Default parameters pasted in from a 
                // decent rendering are used.
                let parameters_ = default_json.remembered.Default[0];
                for (let channel_name in parameters_) {
                    let channel_value = parseFloat(parameters_[channel_name]);
                    await csound.SetControlChannel(channel_name, channel_value);
                }
                await csound.Perform();
                scale = new CsoundAC.Scale("F major");
                csound_message_callback("Csound is playing...\n");
                next_time = 0;
            });
            $("#menu_item_stop").click(async function (event) {
                console.log("menu_item_stop click...");
                await csound.Stop();
                await csound.Cleanup();
                csound.Reset();
                csound_message_callback("Csound is stopping...\n");
            });
            $("#menu_item_fullscreen").click(function (event) {
                console.log("menu_item_fullscreen click...");
                const display = document.getElementById("display");
                if (display.requestFullscreen) {
                    display.requestFullscreen();
                } else if (display.webkitRequestFullscreen) {
                    display.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    display.msRequestFullscreen();
                }
            });
            $("#menu_item_strudel").click(function (event) {
                console.log("menu_item_strudel click...");
                $("#about_view").hide();
                $("#console_view").hide();
                $("#scorew_view").hide();
                if ($("#strudel_view").is(":visible")) {
                    $("#strudel_view").hide();
                } else {
                    $("#strudel_view").show();
                }
            });
            $("#menu_item_console").click(function (event) {
                console.log("menu_item_console click...");
                $("#about_view").hide();
                $("#strudel_view").hide();
                //$("#score_view").hide();
                if ($("#console_view").is(":visible")) {
                    $("#console_view").hide();
                } else {
                    $("#console_view").show();
                    const menu_bar = document.getElementById('main_menu');
                    const menu_bar_bottom = menu_bar.getBoundingClientRect().bottom;
                    let console_view = document.getElementById('console_view');
                    console_view.style.top = `${menu_bar_bottom}px`;
                    // Back out menu bar height from console view height.
                    console_view.style.height= `calc(${document.body.style.height} - ${menu_bar_bottom}px)`;
                    // Needed to make visible in place.
                    console_editor.resize(true);
                }
            });
            $("#menu_item_about").click(function (event) {
                console.log("menu_item_about click...");
                $("#console_view").hide();
                $("#strudel_view").hide();
                if ($("#about_view").is(":visible")) {
                    $("#about_view").hide();
                } else {
                    $("#about_view").show();
                    const menu_bar = document.getElementById('main_menu');
                    const menu_bar_bottom = menu_bar.getBoundingClientRect().bottom;
                    let about_view = document.getElementById('about_view');
                    about_view.style.top = `${menu_bar_bottom}px`;
                    // Back out menu bar height from about view height.
                    about_view.style.height= `calc(${document.body.style.height} - ${menu_bar_bottom}px)`;
                    // Needed to make visible in place.
                    ///about_view.resize(true);
                }
            });
            $(document).keydown(function (event) {
                console.log("document keydown...");
                if (event.keyCode === 'F11') {
                    $("#menu_item_fullscreen").trigger("click");
                }
            });
            $('input').on('input', async function (event) {
                var slider_value = parseFloat(event.target.value);
                if (csound) {
                    csound.SetControlChannel(event.target.id, slider_value);
                }
                var output_selector = '#' + event.target.id + '_output';
                $(output_selector).val(slider_value);
            });
            $('#default').on('click', function () {
                /// Try parameters here.
                let defaults = { "gk_Phaser_ratio2": "1", "gk_ReverbSC_feedback": "0.994", "gk_MasterOutput_level": "-17.329", "gk_Blower_grainDensity": "90", "gk_Blower_grainFrequencyRange": "10", "strudel-settingsfontSize": "18", "gk_Blower_grainAmplitudeRange": "100", "strudel-settingsisLineWrappingEnabled": "false", "gk_ReverbSC_frequency_cutoff": "7260.785", "gk_Droner_partial5": "0.1", "gk_Droner_partial2": "0.05", "gk_Droner_partial3": "0.1", "gi_ReverbSC_delay_modulation": "0.111", "strudel-settingsisLineNumbersDisplayed": "true", "gk_Droner_partial4": "0.2", "gk_Phaser_level": "-22.716", "strudel-settingssoundsFilter": "all", "strudel-settingslatestCode": "stack(\"0,3,[11 6]\"\n  .add(\"<0 1 2 [3 4] 5 7 8>\")\n  .transpose(\"<0 1 2 1>/8\")\n  .slow(7).degradeBy(.125)\n  .transpose(60)\n  .legato(.95)\n  .iter(2)\n  .note()\n  .csoundm(\"1 2\"),\n\"0,4,[7 6]\"\n  .sub(\"<0 1 2 3 4 5 [7 8] 9>\")\n  .transpose(\"<0 1 -1 1>/3\")\n  .iter(4)\n  .slow(7)\n  .transpose(\"<48 36>/7\")\n  .legato(.95)\n  .note()\n  .csoundm(\"2 3\"))\n  .slow(12)\n  //.scale(slowcat('D dorian', 'G mixolydian', 'C dorian', 'F mixolydian')/18)\n  .pianoroll({cycles:120})", "gk_Droner_level": "-32.362", "gk_Phaser_attack": "0.125", "gk_Phaser_release": "0.125", "strudel-settingskeybindings": "codemirror", "strudel-settingsfontFamily": "monospace", "gi_Droner_waveform": "0", "gk_Blower_grainDuration": "0.2005", "strudel-settingsisAutoCompletionEnabled": "false", "strudel-settingsactiveFooter": "intro", "gk_Phaser_index2": "2.481", "gk_Phaser_ratio1": "1.287", "strudel-settingspanelPosition": "bottom", "gk_Droner_partial1": "0.5", "gk_Phaser_index1": "1.502", "strudel-settingstheme": "strudelTheme", "strudel-settingsisZen": "false", "gk_Blower_level": "-13.905" };
                for (let [key, value] of Object.entries(defaults)) {
                    console.log(key, value);
                    // For Web sites, this should probably be true.
                    if (true) {
                        $('.persistent-element').each(function () {
                            localStorage.setItem(key, value);
                        });
                    }
                    if (csound) {
                        csound.SetControlChannel(key, parseFloat(value));
                    }
                    let input = '#' + key;
                    $(input).val(value);
                    let output_selector = '#' + key + '_output';
                    $(output_selector).val(value);
                }
                csound_message_callback("Set controls state from defaults.\n");
            });
            // Reset controls to defaults every time the window loads!
            try {
                $("#default")[0].click();
            } catch (ex) {
                console.log(ex);
            }
        });
    </script>

    <!-- endregion -->

</html>