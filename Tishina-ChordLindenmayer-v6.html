<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="dat.gui.js"></script>
    <script src="jquery.js"></script>
    <script src="sprintf.js"></script>
    <script src="three.js"></script>
    <script src="ace.js"></script>
    <script src="tinycolor.js"></script>
    <script src="CsoundAudioNode.js"></script>
    <script src="csound_loader.js"></script>
    <script src="CsoundAC.js"></script>
    <!-- <script src='piano-roll.js'></script> -->
    <script src="PianoRoll3D.js"></script>
    <script src='Silencio.js'></script>
    <script src='ChordSpace.js'></script>
    <script src="TrackballControls.js"></script>
    <link rel="stylesheet" href="w3.css">
    <style>
        .w3-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .w3-bar {
            z-index: 1;
        }

        .dg {
            font: 12px 'Verdana', sans-serif;
        }

        .dg .c {
            background: transparent;
        }

        .dg.main .close-button {
            background: transparent;
            font: 15px 'Verdana', sans-serif;
        }

        .dg.main .close-button:hover {
            background: transparent;
        }

        input {
            font: 1em/1.25em Verdana, sans-serif;
            background: transparent;
        }
    </style>
</head>

<body id="body" class="w3-medium w3-text-sand" style="height:100vh;">

    <!-- #region Canvas -->

    <canvas id="display" class="w3-container" style="background-color:black;height:100%;margin:0;padding:0;z-index:0;">
    </canvas>

    <!-- endregion-->

    <!-- #region About -->

    <div id="about_view" class="w3-container"
        style="font-size:11px;position:absolute;top:40px;margin:20px;z-index:5;background:transparent;color:rgb(255, 255, 200, 67%);max-height: calc(100vh - 70px);overflow-y:auto;">

        <h1 style="font-size: 15px;">Poustinia v5e</h1>
        <h2 style="font-size: 13px">Michael Gogins<br>
            February 2024</h2>

        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License"
                style="border-width:0;" src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
        <p>This work is licensed under a <a rel="license"
                href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative
                Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.</a>

        <p>Although this piece is written in HTML5, it will run only in
            <a href="https://nwjs.io/">NW.js</a> using
            <a href="https://github.com/gogins/csound-extended-node">csound.node</a>,
            because the Csound orchestra uses native code VST3 plugins.
        </p>

        <p> The score of this piece is generated by a
            <a href="http://algorithmicbotany.org/papers/abop/abop.pdf">Lindenmayer system</a>
            that operates not only on notes, but also on chords, to which the notes
            are then conformed. These operations are the generators of the
            <a href="https://mtosmt.org/classic/mto.05.11.3/mto.05.11.3.fiore_satyendra.pdf">Generalized Contextual
                Group</a>
            of Fiore and Satyendra, as implemented by me.
        </p>
        <h2 style="font-size:13px">Credits</h2>

        <p>Code for compiling and controlling shaders is adapted from <a
                href="https://www.shadertoy.com">ShaderToy.com</a>.

        <p>The music visualization code is adapted from <a href="https://www.shadertoy.com/view/DtsyWl"><b><i>Colourful
                        smoke</i></b></a>
            by <a href="https://www.shadertoy.com/user/motus_art">motus_art</a>.

        <p>Some of the Csound instruments are by me, others are adapted by me from
            patches originally written by others as noted in the orchestra.
        <p>

            <a href="http://michaelgogins.tumblr.com">
                <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
                <svg version="1.1" id="Calque_1" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="36" height="36"
                    viewBox="0 0 256 256" enable-background="new 0 0 256 256" xml:space="preserve">
                    <g>
                        <g>
                            <g>
                                <rect x="0.24" y="0.167" fill="#314358" width="255.52" height="256" />
                            </g>
                        </g>
                        <g>
                            <path fill="#FFFFFF"
                                d="M168.08,170.918c-2.969,1.416-8.647,2.648-12.881,2.754c-12.783,0.342-15.264-8.979-15.367-15.736v-49.705
                h32.065V84.055h-31.954V43.382c0,0-23.008,0-23.383,0c-0.385,0-1.057,0.337-1.152,1.192c-1.368,12.448-7.192,34.296-31.416,43.032
                v20.624h16.16v52.167c0,17.863,13.176,43.24,47.959,42.641c11.736-0.201,24.77-5.113,27.648-9.354L168.08,170.918" />
                        </g>
                    </g>
                </svg>
            </a>

            <a href="https://github.com/gogins">
                <?xml version="1.0" encoding="UTF-8" standalone="no"?>
                <svg width="36" height="36" viewBox="0 0 256 250" version="1.1" xmlns="http://www.w3.org/2000/svg"
                    xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid">
                    <g>
                        <path
                            d="M128.00106,0 C57.3172926,0 0,57.3066942 0,128.00106 C0,184.555281 36.6761997,232.535542 87.534937,249.460899 C93.9320223,250.645779 96.280588,246.684165 96.280588,243.303333 C96.280588,240.251045 96.1618878,230.167899 96.106777,219.472176 C60.4967585,227.215235 52.9826207,204.369712 52.9826207,204.369712 C47.1599584,189.574598 38.770408,185.640538 38.770408,185.640538 C27.1568785,177.696113 39.6458206,177.859325 39.6458206,177.859325 C52.4993419,178.762293 59.267365,191.04987 59.267365,191.04987 C70.6837675,210.618423 89.2115753,204.961093 96.5158685,201.690482 C97.6647155,193.417512 100.981959,187.77078 104.642583,184.574357 C76.211799,181.33766 46.324819,170.362144 46.324819,121.315702 C46.324819,107.340889 51.3250588,95.9223682 59.5132437,86.9583937 C58.1842268,83.7344152 53.8029229,70.715562 60.7532354,53.0843636 C60.7532354,53.0843636 71.5019501,49.6441813 95.9626412,66.2049595 C106.172967,63.368876 117.123047,61.9465949 128.00106,61.8978432 C138.879073,61.9465949 149.837632,63.368876 160.067033,66.2049595 C184.49805,49.6441813 195.231926,53.0843636 195.231926,53.0843636 C202.199197,70.715562 197.815773,83.7344152 196.486756,86.9583937 C204.694018,95.9223682 209.660343,107.340889 209.660343,121.315702 C209.660343,170.478725 179.716133,181.303747 151.213281,184.472614 C155.80443,188.444828 159.895342,196.234518 159.895342,208.176593 C159.895342,225.303317 159.746968,239.087361 159.746968,243.303333 C159.746968,246.709601 162.05102,250.70089 168.53925,249.443941 C219.370432,232.499507 256,184.536204 256,128.00106 C256,57.3066942 198.691187,0 128.00106,0 Z M47.9405593,182.340212 C47.6586465,182.976105 46.6581745,183.166873 45.7467277,182.730227 C44.8183235,182.312656 44.2968914,181.445722 44.5978808,180.80771 C44.8734344,180.152739 45.876026,179.97045 46.8023103,180.409216 C47.7328342,180.826786 48.2627451,181.702199 47.9405593,182.340212 Z M54.2367892,187.958254 C53.6263318,188.524199 52.4329723,188.261363 51.6232682,187.366874 C50.7860088,186.474504 50.6291553,185.281144 51.2480912,184.70672 C51.8776254,184.140775 53.0349512,184.405731 53.8743302,185.298101 C54.7115892,186.201069 54.8748019,187.38595 54.2367892,187.958254 Z M58.5562413,195.146347 C57.7719732,195.691096 56.4895886,195.180261 55.6968417,194.042013 C54.9125733,192.903764 54.9125733,191.538713 55.713799,190.991845 C56.5086651,190.444977 57.7719732,190.936735 58.5753181,192.066505 C59.3574669,193.22383 59.3574669,194.58888 58.5562413,195.146347 Z M65.8613592,203.471174 C65.1597571,204.244846 63.6654083,204.03712 62.5716717,202.981538 C61.4524999,201.94927 61.1409122,200.484596 61.8446341,199.710926 C62.5547146,198.935137 64.0575422,199.15346 65.1597571,200.200564 C66.2704506,201.230712 66.6095936,202.705984 65.8613592,203.471174 Z M75.3025151,206.281542 C74.9930474,207.284134 73.553809,207.739857 72.1039724,207.313809 C70.6562556,206.875043 69.7087748,205.700761 70.0012857,204.687571 C70.302275,203.678621 71.7478721,203.20382 73.2083069,203.659543 C74.6539041,204.09619 75.6035048,205.261994 75.3025151,206.281542 Z M86.046947,207.473627 C86.0829806,208.529209 84.8535871,209.404622 83.3316829,209.4237 C81.8013,209.457614 80.563428,208.603398 80.5464708,207.564772 C80.5464708,206.498591 81.7483088,205.631657 83.2786917,205.606221 C84.8005962,205.576546 86.046947,206.424403 86.046947,207.473627 Z M96.6021471,207.069023 C96.7844366,208.099171 95.7267341,209.156872 94.215428,209.438785 C92.7295577,209.710099 91.3539086,209.074206 91.1652603,208.052538 C90.9808515,206.996955 92.0576306,205.939253 93.5413813,205.66582 C95.054807,205.402984 96.4092596,206.021919 96.6021471,207.069023 Z"
                            fill="#161614"></path>
                    </g>
                </svg>
            </a>

    </div>

    <!-- endregion -->

    <!-- #region Score -->

    <canvas id="score_view" class="w3-container"
        style="background-color:black;height:100%;width:100%;margin:0;padding:0;z-index:1;">
    </canvas>

    <script>

        try {
            var fs = require("fs");
            var __dirname = fs.realpathSync.native(".");
        } catch (e) {
            console.log(e);
        }

        var generate_score_hook = async function () {
            csound.message("generate_score_hook()...\n");
            try {
                let CsoundAC = await createCsoundAC();
                let score_model = new CsoundAC.ScoreModel();
                let scale = new CsoundAC.Scale("C major");
                csound.message(scale.information());
                let chord = scale.chord(1, 5, 4);
                csound.message(chord.eOP().information());
                let lindenmayer = new CsoundAC.ChordLindenmayer();
                lindenmayer.setAxiom("(seed P 3928394)(= P 72)(= Sc Cmajor {0,2,4,5,7,9,11})(++ C)(= C {0,4,7})(= M {0,4,7})(= N[d] 36.)(Sc P)(A)");
                lindenmayer.addRule("(A)", "(B)(F N .5 R)(uni V 1 210)(W C R)(+ N[k] -1 R)(+ N[v] 2)(+ Sd -3 R)(W Cl R)([)(* S[t] .75)(- N[k] .5 R)(F N 1)(A)(])(M Sc 3 1)(uni N[x] 0 1)(+ N[t] 1)(R O t k .3333334)(F N 1.5 R)(R O t i .25)(- N[v] 2)(B)(+ Sd 4)(C Sd 4)(W Cl R)(+ Sd 3)(uni N[i] 1 5)(M Sc 3 0)(Sc P)(W N R)(A)(+ N[k] 2 R)(+ N[t] .5)(W N R)(A)");
                lindenmayer.addRule("(A)", "(B)(F N .125 R)(uni V 1 111)(W C R)(+ N[k] -1 R)(+ N[v] 2)(+ Sd -1 R)(W Cl R)([)(* S[t] .75)(- N[k] .5 R)(F N 1)(A)(])(M Sc 3 1)(uni N[x] 0 1)(+ N[t] 1)(R O t k .041)(F N 1.5 R)(R O t i -.325)(- N[v] 2)(B)(+ Sd 4)(C Sd 4)(W Cl R)(+ Sd 3)(uni N[i] 1 5)(M Sc 3 0)(Sc P)(W N R)(A)(+ N[k] 2 R)(+ N[t] 5)(W N R)(A)");
                lindenmayer.addRule("(B)", "(Sc P)(B)([)(/ S[t] 2)(/ 2 S[d])(+ N[k] 3)(uni V 1 101)(W C R)(A)(])");
                //lindenmayer.addRule("(B)", "(Sc P)(B)([)(* S[t] 3.5)(B)(* 7 S[d])(B)(+ N[k] 2)(A)(])");
                lindenmayer.setIterationCount(this.parameters.gk_Iterations);
                let rescale = new CsoundAC.Rescale();
                rescale.setRescale(0, true, false, 1., 0.);
                rescale.setRescale(3, true, true, 1., 8.);
                rescale.setRescale(4, true, false, 18., 72.);
                rescale.setRescale(5, true, true, 60., 12.);
                rescale.addChild(lindenmayer);
                score_model.addChild(rescale);
                //CsoundAC.System.setMessageLevel(15);
                score_model.generate();
                // Global.
                score = score_model.getScore();
                csound.message(`generated ${score.size()} notes.\n`);
                score.setDuration(7 * 60);
                let score_view = document.getElementById("score_view");
                // Copy all notes from the CsoundAC score to an empty Silencio 
                // score for display. Also global.
                silencio_score = new Silencio.Score(window.score);
                silencio_score.draw3D(score_view);
            } catch (err) {
                csound.message(err.name + ': ' + err.message + ' ' + err.line + '\n');
            }
        };

    </script>

    <!-- endregion -->

    <!-- #region Music to Visuals -->

    <script id="draw-shader-fs" type="x-shader/x-fragment">#version 300 es
        #line 281
        precision highp float;
        /**
         * These are all of the standard ShaderToy inputs. If any of these are 
         * used in this shader, they must be created and initialized in the 
         * JavaScript code.
         */
        uniform vec3 iResolution;
        // viewport resolution (in pixels)
        uniform float iTime;
        // shader playback time (in seconds)
        uniform float iTimeDelta;
        // render time (in seconds)
        uniform int iFrame;
        // shader playback frame
        uniform float iChannelTime[4];
        // channel playback time (in seconds)
        uniform vec3 iChannelResolution[4];
        // channel resolution (in pixels)
        uniform vec4 iMouse;
        // mouse pixel coords. xy: current (if MLB down), zw: click
        uniform sampler2D iChannel0;
        // input channel. XX = 2D/Cube
        uniform sampler2D iChannel1;
        // input channel. XX = 2D/Cube
        uniform sampler2D iChannel2;
        // input channel. XX = 2D/Cube
        uniform sampler2D iChannel3;
        // input channel. XX = 2D/Cube
        uniform vec4 iDate;
        // (year, month, day, time in seconds)
        uniform float iSampleRate;
        // sound sample rate (i.e., 44100)
        uniform float spectralTilt;
        uniform float totalLoudness;
      
        /**
         * Theoretically, any fragment shader copied from the ShaderToy 
         * editor can replace the body of the mainImage function below, 
         * if all inputs actually used in the shader are defined and bound.
         */

        void mainImage(out vec4 _ufragColor, in vec2 _ufragCoord);
        out vec4 _ushadertoy_out_color;
        void main(){
          (_ushadertoy_out_color = vec4(0.0, 0.0, 0.0, 0.0));
          (_ushadertoy_out_color = vec4(1.0, 1.0, 1.0, 1.0));
          vec4 _ucolor = vec4(0.0, 0.0, 0.0, 1.0);
          mainImage(_ucolor, gl_FragCoord.xy);
          if ((_ushadertoy_out_color.x < 0.0))
          {
            (_ucolor = vec4(1.0, 0.0, 0.0, 1.0));
          }
          if ((_ushadertoy_out_color.y < 0.0))
          {
            (_ucolor = vec4(0.0, 1.0, 0.0, 1.0));
          }
          if ((_ushadertoy_out_color.z < 0.0))
          {
            (_ucolor = vec4(0.0, 0.0, 1.0, 1.0));
          }
          if ((_ushadertoy_out_color.w < 0.0))
          {
            (_ucolor = vec4(1.0, 1.0, 0.0, 1.0));
          }
          (_ushadertoy_out_color = vec4(_ucolor.xyz, 1.0));
        }

        // https://www.shadertoy.com/view/DtsyWl
        // Colourful waves of smoke based upon an example on 
        // GLSL sandbox water turbulence effect by joltz0r and 
        // David Hoskins's implementation https://www.shadertoy.com/view/MdlXz8
        #define TAU 6.28318530718
        #define MAX_ITER 8

        // cosine based palette, 4 vec3 params
        // By Inigo Quilez https://iquilezles.org/articles/palettes/
        vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
        {
            return a + b*cos( 6.28318*(c*t+d) );
        }

        void mainImage( out vec4 fragColor, in vec2 fragCoord )
        {
            float time = iTime * .095 + 23.0;
            vec2 uv = fragCoord/iResolution.xy;;
            vec2 p = mod(uv*TAU, TAU) - 213.0;
            vec2 i = vec2(p);
            float c = 1.0;
            float inten = .005;
            for (int n = 0; n < MAX_ITER; n++) {
                float t = time * (1.0 - (3.5 / float(n + 1)));
                i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));
                c += 1.0 / length(vec2(p.x / (sin(i.x + t) / inten), p.y / (cos(i.y + t) / inten)));
            }
            c /= float(MAX_ITER);
            c = 1.17 - pow(c, 1.4);
            vec3 colour = vec3(pow(abs(c), 10.0));
            colour.r = colour.r - spectralTilt;
            colour.b = colour.b + spectralTilt;
            colour *= (1.1 + totalLoudness);
            colour = clamp(colour + vec3(0.095), 0.0, 1.0);
            float palettePhase = abs(sin(uv.x * uv.y + iTime * 0.05)) + iTime * 0.1;
            vec3 col = palette(palettePhase, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));
            col *=  colour;
            fragColor = vec4(col, 1.0);
        }
        
    </script>

    <script id="draw-shader-vs" type="x-shader/x-vertex">#version 300 es
    in vec2 inPos;
    void main() {
        gl_Position = vec4(inPos.xy, 0.0, 1.0);
    }
  </script>

    <script>
        var shader_program = null;
        var analyser = null;
        // Set up for high-resolution displays.
        var devicePixelRatio_ = window.devicePixelRatio || 1
        var canvas = document.getElementById("display");
        canvas.width = canvas.clientWidth * devicePixelRatio_;
        canvas.height = canvas.clientHeight * devicePixelRatio_;
        console.log("canvas.height: " + canvas.height);
        console.log("canvas.width:  " + canvas.width);
        var gl = canvas.getContext("webgl2", { antialias: true });
        if (!gl) {
            alert("Could not create webgl2 context.");
        }
        let extensions = gl.getSupportedExtensions();
        console.log("Supported extensions:\n" + extensions);
        if ("gpu" in navigator) {
            var gpu_adapter = navigator.gpu.requestAdapter();
            console.log("WebGPU adapter: " + gpu_adapter);
        } else {
            console.warn("WebGPU is not available on this platform.");
        }
        var EXT_color_buffer_float = gl.getExtension("EXT_color_buffer_float");
        if (!EXT_color_buffer_float) {
            alert("EXT_color_buffer_float is not available on this platform.");
        }
        var WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders");
        const audio_texture_level = 0;
        const audio_texture_internalFormat = gl.R32F;
        const audio_texture_width = 512;
        const audio_texture_height = 2;
        const audio_texture_border = 0;
        const audio_texture_srcFormat = gl.RED;
        const audio_texture_srcType = gl.FLOAT;
        var frequency_domain_data = new Uint8Array(audio_texture_width * 2);
        var time_domain_data = new Uint8Array(audio_texture_width * 2);
        var audio_data = new Float32Array(audio_texture_width * 2);
        var image_sample_buffer = new Uint8ClampedArray();

        var channel0_texture_unit = 0;
        var channel0_texture = gl.createTexture();
        channel0_texture.name = "channel0_texture";
        var channel0_sampler = gl.createSampler();
        channel0_sampler.name - "channel0_sampler";

        var current_events = new Map();
        var prior_events = current_events;
        var rendering_frame = 0;

        const midpoint = audio_texture_width / 2;
        function write_audio_texture(analyser, texture_unit, texture, sampler) {
            let spectral_tilt = 0.;
            let totalLoudness = 0.;
            if (analyser != null) {
                analyser.getByteFrequencyData(frequency_domain_data);
                analyser.getByteTimeDomainData(time_domain_data);
                for (let i = 0; i < audio_texture_width; ++i) {
                    // Map frequency domain magnitudes to [0, 1].
                    let sample = frequency_domain_data[i];
                    sample = sample / 255.;
                    audio_data[i] = sample;
                    totalLoudness += sample;
                }
                let audio_data_width = audio_texture_width * 2;
                for (let j = 0; j < audio_texture_width; ++j) {
                    // Map time domain amplitudes to [-1, 1].
                    let sample = time_domain_data[j];
                    sample = sample / 255.;
                    audio_data[audio_texture_width + j] = sample;
                    if (j < midpoint) {
                        spectral_tilt -= Math.abs(sample);
                    } else {
                        spectral_tilt += Math.abs(sample);
                    }
                }
                spectral_tilt = spectral_tilt / audio_texture_width;
                totalLoudness = totalLoudness / audio_texture_width;
            }
            gl.activeTexture(gl.TEXTURE0 + texture_unit);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.bindSampler(texture_unit, sampler);
            gl.texImage2D(gl.TEXTURE_2D, audio_texture_level, audio_texture_internalFormat, audio_texture_width, audio_texture_height, audio_texture_border, audio_texture_srcFormat, audio_texture_srcType, audio_data);
            gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
            gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_MODE, gl.NONE);
            gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_FUNC, gl.LEQUAL);
            if (false && analyser) { // For debugging.
                let is_texture = gl.isTexture(texture);
                let uniform_count = gl.getProgramParameter(shader_program, gl.ACTIVE_UNIFORMS);
                let uniform_index;
                for (let uniform_index = 0; uniform_index < uniform_count; ++uniform_index) {
                    uniform_info = gl.getActiveUniform(shader_program, uniform_index);
                    console.log(uniform_info);
                    const location = gl.getUniformLocation(shader_program, uniform_info.name);
                    const value = gl.getUniform(shader_program, location);
                    console.log("Uniform location: " + location);
                    console.log("Uniform value: " + value);
                }
            }
            if (false && analyser) {
                const unit = gl.getUniform(shader_program, shader_program.iChannel0);
                console.log("Sampler texture unit: " + unit);
                console.log("Texture unit: " + texture_unit);
                gl.activeTexture(gl.TEXTURE0 + texture_unit);
                let texture2D = gl.getParameter(gl.TEXTURE_BINDING_2D);
                console.log("Texture binding 2D " + texture2D);
                var debug_framebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, debug_framebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2D, 0);
                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                    console.log("These attachments don't work.");
                }
                // Read the contents of the debug_framebuffer (data stores the pixel data).
                var data = new Float32Array(1024);
                // What comes out, should be what went in.
                gl.readPixels(0, 0, 512, 2, gl.RED, gl.FLOAT, data);
                //console.log("\nfrequency domain: \n" + data.slice(0, 512));
                //console.log("time domain: \n" + data.slice(512));
                gl.deleteFramebuffer(debug_framebuffer);
            }
            return [spectral_tilt, totalLoudness];
        }

        (function load_scene() {
            var webgl_viewport_size;
            var webgl_buffers = {};
            var mouse_position = [0, 0, 0, 0];
            function create_scene() {
                canvas.addEventListener('mousemove', (e) => {
                    mouse_position = [e.clientX, e.clientY];
                });
                shader_program = gl.createProgram();
                for (let i = 0; i < 2; ++i) {
                    let shader_code = document.getElementById(i == 0 ? "draw-shader-vs" : "draw-shader-fs").text;
                    let shader_object = gl.createShader(i == 0 ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
                    gl.shaderSource(shader_object, shader_code);
                    gl.compileShader(shader_object);
                    let status = gl.getShaderParameter(shader_object, gl.COMPILE_STATUS);
                    if (!status) {
                        console.warn(gl.getShaderInfoLog(shader_object));
                    }
                    gl.attachShader(shader_program, shader_object);
                    gl.linkProgram(shader_program);
                    console.log("shader:" + WEBGL_debug_shaders.getTranslatedShaderSource(shader_object));
                }
                status = gl.getProgramParameter(shader_program, gl.LINK_STATUS);
                if (!status) {
                    console.warn(gl.getProgramInfoLog(shader_program));
                }
                shader_program.inPos = gl.getAttribLocation(shader_program, "inPos");
                shader_program.iMouse = gl.getUniformLocation(shader_program, "iMouse");
                shader_program.iResolution = gl.getUniformLocation(shader_program, "iResolution");
                shader_program.iTime = gl.getUniformLocation(shader_program, "iTime");
                shader_program.iTimeDelta = gl.getUniformLocation(shader_program, "iTimeDelta");
                shader_program.iFrame = gl.getUniformLocation(shader_program, "iFrame");
                shader_program.iChannel0 = gl.getUniformLocation(shader_program, "iChannel0");
                shader_program.iChannel1 = gl.getUniformLocation(shader_program, "iChannel1");
                shader_program.iChannel2 = gl.getUniformLocation(shader_program, "iChannel2");
                shader_program.iChannel3 = gl.getUniformLocation(shader_program, "iChannel3");
                shader_program.iSampleRate = gl.getUniformLocation(shader_program, "iSampleRate");
                shader_program.spectralTilt = gl.getUniformLocation(shader_program, "spectralTilt");
                shader_program.totalLoudness = gl.getUniformLocation(shader_program, "totalLoudness");
                gl.useProgram(shader_program);

                gl.uniform1f(shader_program.iSampleRate, 48000.);
                var pos = [-1, -1,
                    1, -1,
                    1, 1,
                -1, 1];
                var inx = [0, 1, 2, 0, 2, 3];
                webgl_buffers.pos = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, webgl_buffers.pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
                webgl_buffers.inx = gl.createBuffer();
                webgl_buffers.inx.len = inx.length;
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webgl_buffers.inx);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(inx), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(shader_program.inPos);
                gl.vertexAttribPointer(shader_program.inPos, 2, gl.FLOAT, false, 0, 0);
                gl.enable(gl.DEPTH_TEST);
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                write_audio_texture(analyser, channel0_texture_unit, channel0_texture, channel0_sampler);
                window.onresize = resize;
                resize();
                requestAnimationFrame(render_scene);
            }

            function resize() {
                webgl_viewport_size = [window.innerWidth, window.innerHeight];
                canvas.width = webgl_viewport_size[0] * window.devicePixelRatio;
                canvas.height = webgl_viewport_size[1] * window.devicePixelRatio;
                image_sample_buffer = new Uint8ClampedArray(canvas.width * 4);
                prior_image_sample_buffer = new Uint8ClampedArray(canvas.width * 4);
                console.info("resize: image_sample_buffer.length: " + image_sample_buffer.length);
            }

            function clientWaitAsync(sync, flags, interval_ms) {
                return new Promise((resolve, reject) => {
                    function test() {
                        const result = gl.clientWaitSync(sync, flags, 0);
                        if (result === gl.WAIT_FAILED) {
                            reject();
                            return;
                        }
                        // This is the workaround for platforms where maximum 
                        // timeout is always 0.
                        if (result === gl.TIMEOUT_EXPIRED) {
                            setTimeout(test, interval_ms);
                            return;
                        }
                        resolve();
                    }
                    test();
                });
            }

            async function getBufferSubDataAsync(target, buffer, srcByteOffset, dstBuffer,
                /* optional */ dstOffset, /* optional */ length) {
                const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                gl.flush();
                await clientWaitAsync(sync, 0, 10);
                gl.deleteSync(sync);
                gl.bindBuffer(target, buffer);
                gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
                gl.bindBuffer(target, null);
            }

            /**
             * Converts an RGB color value to HSV. The formula is 
             * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
             * Assumes r, g, and b are in [0, 255] and
             * returns h, s, and v are in [0, 1].
             */
            var rgb_to_hsv = function (rgb) {
                r = rgb[0] / 255;
                g = rgb[1] / 255;
                b = rgb[2] / 255;
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                var h, s, v = max;
                var d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max == min) {
                    h = 0;
                } else {
                    // More efficient than switch?
                    if (max == r) {
                        h = (g - b) / d + (g < b ? 6 : 0);
                    } else if (max == g) {
                        h = (b - r) / d + 2;
                    } else if (max == b) {
                        h = (r - g) / d + 4;
                    }
                    h /= 6;
                }
                return [h, s, v];
            }

            async function readPixelsAsync(x, y, w, h, format, type, sample) {
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
                gl.bufferData(gl.PIXEL_PACK_BUFFER, sample.byteLength, gl.STREAM_READ);
                gl.readPixels(x, y, w, h, format, type, 0);
                gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
                await getBufferSubDataAsync(gl.PIXEL_PACK_BUFFER, buffer, 0, sample);
                gl.deleteBuffer(buffer);
            }

            /**
             * Adapts https://github.com/pingec/downsample-lttb from time 
             * series data to vectors of float HSV pixels. Our data is not 
             * [[time, value], [time, value],...], but rather 
             * [[pixel index0, hsv0[2]], [pixel index1, hsv1[2]], ...].
             */
            function downsample_lttb(data, buckets) {
                if (buckets >= data.length || buckets === 0) {
                    return data; // Nothing to do
                }
                let sampled_data = [],
                    sampled_data_index = 0;
                // Bucket size. Leave room for start and end data points
                let bucket_size = (data.length - 2) / (buckets - 2);
                // Triangles are points {a, b, c}.
                let a = 0,  // Initially a is the first point in the triangle
                    max_area_point,
                    max_area,
                    area,
                    next_a;
                sampled_data[sampled_data_index++] = data[a]; // Always add the first point
                for (let i = 0; i < buckets - 2; i++) {
                    // Calculate point average for next bucket (containing c)
                    let avg_x = 0,
                        avg_y = 0,
                        avg_range_start = Math.floor((i + 1) * bucket_size) + 1,
                        avg_range_end = Math.floor((i + 2) * bucket_size) + 1;
                    avg_range_end = avg_range_end < data.length ? avg_range_end : data.length;
                    let avg_range_length = avg_range_end - avg_range_start;
                    for (; avg_range_start < avg_range_end; avg_range_start++) {
                        avg_x += data[avg_range_start][0] * 1; // * 1 enforces Number (value may be Date)
                        avg_y += data[avg_range_start][1] * 1;
                    }
                    avg_x /= avg_range_length;
                    avg_y /= avg_range_length;
                    // Get the range for this bucket
                    let range_offs = Math.floor((i + 0) * bucket_size) + 1,
                        range_to = Math.floor((i + 1) * bucket_size) + 1;
                    // Point a
                    let point_a_x = data[a][0] * 1, // enforce Number (value may be Date)
                        point_a_y = data[a][1] * 1;
                    max_area = area = -1;
                    for (; range_offs < range_to; range_offs++) {
                        // Calculate triangle area over three buckets
                        area = Math.abs((point_a_x - avg_x) * (data[range_offs][1] - point_a_y) -
                            (point_a_x - data[range_offs][0]) * (avg_y - point_a_y)
                        ) * 0.5;
                        if (area > max_area) {
                            max_area = area;
                            max_area_point = data[range_offs];
                            next_a = range_offs; // Next a is this b
                        }
                    }
                    sampled_data[sampled_data_index++] = max_area_point; // Pick this point from the bucket
                    a = next_a; // This a is the next a (chosen b)
                }
                sampled_data[sampled_data_index++] = data[data.length - 1]; // Always add last
                return sampled_data; ///sampled_data;
            }

            /**
             * Translates one row of RGBA pixels, the width of the WebGL 
             * canvas, to Csound events. 
             *
             * https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf
             */

            var instrument_count = 9;
            var sampled_events = new Array();
            var playlist = new Map();
            var rendering_frame_rate = 400;
            var frame_translation_count = 0;
            var midi_key_begin = 36;
            var midi_key_range = 60;
            var maximum_voices = 8;
            var event_velocity_threshold = 100;
            var midi_key_end = midi_key_begin + midi_key_range;
            var sample_count = 0;
            var root_progression = 0;
            var on_events = new Array();
            var off_events = new Array();
            var playing_events = new Map();
            var event_tag = 0;
            var root_progressions = [2, 3, -4, 5, -1, 3];

            async function translate_sample_to_csound_events(maximum_events, threshold, parent_rendering_frame) {
                if (non_csound(csound)) {
                    return;
                }
                let x = 0;
                // y is zero at the bottom of the canvas.
                let y = 0;
                let width = canvas.width;
                let height = 1;
                let format = gl.RGBA;
                let type = gl.UNSIGNED_BYTE;
                readPixelsAsync(x, y, width, height, format, type, image_sample_buffer);
                // Translate the sample format from byte RGBA to float HSV.
                let hsv_image_sample = [];
                for (let byte_i = 0; byte_i < image_sample_buffer.length; byte_i = byte_i + 4) {
                    let rgb = image_sample_buffer.slice(byte_i, byte_i + 3);
                    let hsv = rgb_to_hsv(rgb);
                    hsv_image_sample.push([hsv_image_sample.length + 1, hsv[2], hsv]);
                }
                // Downsample the HSV samples.
                let downsampled_pixels = downsample_lttb(hsv_image_sample, midi_key_range);
                sampled_events.length = 0;
                on_events.length = 0;
                off_events.length = 0;
                score.clear();
                // Translate the HSV samples to Csound event vectors.
                // 0 is p1 insno (hsv[0](, tagged by downsampled pixel, 
                //   positive for on or negative for off.
                // 1 is p2 time always 0.
                // 2 is p3 duration (either hsv[1] or -1, must be 0 for off
                //   events).
                // 3 is p4 MIDI key (downsampled pixel).
                // 4 is p5 MIDI velocity (hsv[2]).
                for (let downsampled_pixel_i = 0; downsampled_pixel_i < downsampled_pixels.length; downsampled_pixel_i++) {
                    let hsv = downsampled_pixels[downsampled_pixel_i][2];
                    let instrument_number = 1 + (hsv[0] * instrument_count);
                    let time = 0;
                    let duration = -1;
                    let midi_key = Math.floor(midi_key_begin + downsampled_pixel_i);
                    let insno = sprintf("%d.%d", Math.floor(instrument_number), midi_key);
                    instrument_number = parseFloat(insno);
                    let midi_velocity = hsv[2] * 128;
                    let event_for_pixel = [instrument_number, time, duration, midi_key, midi_velocity];
                    sampled_events.push(event_for_pixel);
                }
                // Events that are playing but not loud enough, are turned off.
                for (let sampled_event_i = 0; sampled_event_i < sampled_events.length; sampled_event_i++) {
                    let sampled_event = sampled_events[sampled_event_i];
                    let key = sampled_event[0];
                    if ((sampled_event[4] < event_velocity_threshold) && (playing_events.has(key) == true)) {
                        let off_event = playing_events.get(key);
                        let instrument_number = off_event[0];
                        csound.KillInstance(instrument_number, "", 4, true);
                        playing_events.delete(key);
                    }
                }
                // Events that are loud enough but not playing, are turned on.
                for (let sampled_event_i = 0; sampled_event_i < sampled_events.length; sampled_event_i++) {
                    let sampled_event = sampled_events[sampled_event_i];
                    let key = sampled_event[0];
                    if ((sampled_event[4] >= event_velocity_threshold) && (playing_events.has(key) == false)) {
                        playing_events.set(key, sampled_event);
                        on_events.push(sampled_event);
                    }
                }
                CsoundAC.setCorrectNegativeDurations(false);
                // Limit number of on events, play N loudest only. Could also pick at random.
                on_events.sort(function (a, b) {
                    if (a[5] < b[5]) {
                        return 1;
                    }
                    if (b[5] < a[5]) {
                        return -1;
                    }
                    return 0;
                });
                let voices = Math.min(on_events.length, maximum_voices);
                for (let i = 0; i < voices; i++) {
                    let on_event = on_events[i];
                    let time = 0;
                    let duration = on_event[2];
                    let status = 144;
                    let instrument_number = on_event[0];
                    let key = on_event[3];
                    let velocity = on_event[4];
                    let phase = 0;
                    let pan = .01 + Math.random() * .8;
                    let depth = 0;
                    let height = 0;
                    let pitches = 4095;
                    score.add(time, duration, status, instrument_number, key, velocity, phase, pan, depth, height, pitches);
                }
                if (score.size() > 0) {
                    if (sample_count % 4 == 0) {
                        if (sample_count % 24 == 0) {
                            let scales = scale.modulations(chord);
                            if (scales.size() > 1) {
                                scale = scales.get(Math.floor(Math.random() * scales.size()));
                                csound_message_callback(sprintf("\n%s\n\n", scale.name()));
                            }
                        }
                        let root_progression = root_progressions[Math.floor(Math.random() * root_progressions.length)];
                        csound_message_callback(sprintf("\n%s\n\n", chord.eOP().name()));
                        chord = scale.transpose_degrees(chord, root_progression, 3)
                    }
                    CsoundAC.apply(score, chord, 0, 1000000, true);
                    let score_text = score.getCsoundScore(12., true);
                    csound.ReadScore(score_text);
                    ///console.info(score_text);
                }
                sample_count++;
            }

            function render_scene(milliseconds) {
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                let tyme = milliseconds / 1000;
                gl.uniform1f(shader_program.iTime, tyme);
                gl.uniform3f(shader_program.iResolution, canvas.width, canvas.height, 0);
                gl.uniform4f(shader_program.iMouse, mouse_position[0], mouse_position[1], 0, 0);
                if (analyser) {
                    let visualization_data = write_audio_texture(analyser, channel0_texture_unit, channel0_texture, channel0_sampler);
                    gl.uniform1f(shader_program.spectralTilt, visualization_data[0] * .1);
                    gl.uniform1f(shader_program.totalLoudness, visualization_data[1] * .1);
                    ///console.info(sprintf("render_scene:                      time: %9.4f frame: %5d tilt: %9.4f loudness: %9.4f", tyme, rendering_frame, visualization_data[0], visualization_data[1]));
                } else {
                    ///console.info(sprintf("render_scene:                      time: %9.4f frame: %5d", tyme, rendering_frame));
                }
                gl.drawElements(gl.TRIANGLES, webgl_buffers.inx.len, gl.UNSIGNED_SHORT, 0);
                rendering_frame++;
                requestAnimationFrame(render_scene);
            }
            create_scene();
        })();

    </script>

    <!-- endregion -->

    <!-- #region Visuals to Music -->

    <!-- endregion -->

    <!-- #region Controls -->

    <script>

        function create_dat_gui_hook() {
            csound_message_callback("create_dat_gui_hook...\n");
            parameters = {
                "gk_Duration_factor": 0.8682696259761612,
                "gk_Iterations": 4,
                "gk_MasterOutput_level": -2.383888203863542,
                "gk_Shimmer_wetDry": 0.4958898479243732,
                "gk_Shimmer_feedback": 0.45643238799835595,
                "gk_Shimmer_diffusion": 0.14736409413215498,
                "gk_Shimmer_size": 0.5813810110974106,
                "gk_Shimmer_modRate": 0.9167694204685574,
                "gk_Shimmer_modDepth": 0.009248792518754496,
                "gk_Shimmer_reverbMode": 0.275,
                "gk_Shimmer_program": 2.073160706946157,
                "gk_Blower_level": -29.344363374781626,
                "gk_Blower_attack": 1.5,
                "gk_Blower_release": 2,
                "gk_Blower_grainDensity": 245.730140787175,
                "gk_Blower_grainDuration": 0.03750899188161545,
                "gk_Blower_grainAmplitudeRange": 119.4532935977803,
                "gk_Blower_grainFrequencyRange": 50.251772685232766,
                "gk_Bower_level": -10.271297913883465,
                "gk_Bower_pressure": 4.715856540951598,
                "gk_Bower_rat": 0.4518548967218169,
                "gk_Buzzer_level": -26.71359572500257,
                "gk_Buzzer_harmonics": 1.3688212927756656,
                "gk_Droner_level": -14.217449388552048,
                "gk_Droner_partial1": 0.12105641763436441,
                "gk_Droner_partial2": 0.22628712362552666,
                "gk_Droner_partial3": 0.6406330284657281,
                "gk_Droner_partial4": 0.11447949850991676,
                "gk_Droner_partial5": 0,
                "gk_FilteredSines_level": -3.6943787894358238,
                "gk_ZakianFlute_level": -22.767444250333984,
                "gk_FMWaterBell_level": 0.9094645976775197,
                "gi_FMWaterBell_attack": 0.002,
                "gi_FMWaterBell_release": 0.01,
                "gi_FMWaterBell_exponent": 15,
                "gi_FMWaterBell_sustain": 20,
                "gi_FMWaterBell_sustain_level": 0.1,
                "gk_FMWaterBell_crossfade": 0.5,
                "gk_FMWaterBell_index": 0.5,
                "gk_FMWaterBell_vibrato_depth": 0.05,
                "gk_FMWaterBell_vibrato_rate": 6,
                "gk_Guitar_level": 0,
                "gk_Kung2_level": 3.534730785039045,
                "gk_Kung4_level": -16.19052512588634,
                "gk_Phaser_level": -21.452060425444458,
                "gk_Phaser_ratio1": 2,
                "gk_Phaser_ratio2": 3,
                "gk_Phaser_index1": 1.0266159695817492,
                "gk_Phaser_index2": 0.533347035248176,
                "gk_Plucked_level": 35.10944404480526,
                "gk_Shiner_level": -16.848217038331107,
                "gk_Shiner_attack": 0.125,
                "gk_Shiner_release": 0.5,
                "gk_SeidelHarmonicOsc_level": 0,
                "gk_Sweeper_level": -15.532833213441577,
                "gk_Sweeper_britel": 0.22114890555955194,
                "gk_Sweeper_briteh": 2.4309937313739596,
                "gk_Sweeper_britels": 0.3526872880485048,
                "gk_Sweeper_britehs": 0.7473024355153632,
                "gk_TubularBell_level": -6.982838351659645,
                "gk_VcvOut_level": 0,
                "gk_YiString_level": 0,
                "gk_Xing_level": 0
            }
            // Ensure that the dat.gui controls are children of the _Controls_ button.
            let dat_gui_parameters = { autoPlace: false, closeOnTop: true, closed: true, width: 400, useLocalStorage: false };
            gui = new dat.GUI(dat_gui_parameters);
            var dat_gui = document.getElementById('menu_item_dat_gui');
            dat_gui.appendChild(gui.domElement);
            var Master = gui.addFolder('Master');
            add_slider(Master, 'gk_MasterOutput_level', -50, 50);
            add_slider(Master, 'gk_Iterations', 2., 9., 1.);
            add_slider(Master, 'gk_Duration_factor', 0., 5.);
            add_slider(Master, 'gk_Shimmer_wetDry', 0., 1.);
            //add_slider(Master, 'gk_Shimmer_shift', 0., 1.);
            add_slider(Master, 'gk_Shimmer_feedback', 0., 1.);
            add_slider(Master, 'gk_Shimmer_diffusion', 0., 1.);
            add_slider(Master, 'gk_Shimmer_size', 0., 1.);
            //add_slider(Master, 'gk_Shimmer_lowcut', 0., 1.);
            //add_slider(Master, 'gk_Shimmer_highcut', 0., 1.);
            add_slider(Master, 'gk_Shimmer_modRate', 0., 1.);
            add_slider(Master, 'gk_Shimmer_modDepth', 0., 1.);
            add_slider(Master, 'gk_Shimmer_reverbMode', 0., 1., .25);
            //add_slider(Master, 'gk_Shimmer_shiftMode', 0., 1);
            //add_slider(Master, 'gk_Shimmer_colorMode', 0., 1);
            //add_slider(Master, 'gk_Shimmer_bypass', 0., 1);
            add_slider(Master, 'gk_Shimmer_program', 0., 8, 1);
            var Blower = gui.addFolder('Blower');
            add_slider(Blower, 'gk_Blower_level', -50, 50);
            add_slider(Blower, 'gk_Blower_attack', 0, 2);
            add_slider(Blower, 'gk_Blower_release', 0, 4);
            add_slider(Blower, 'gk_Blower_grainDensity', 0, 400);
            add_slider(Blower, 'gk_Blower_grainDuration', 0, .5);
            add_slider(Blower, 'gk_Blower_grainAmplitudeRange', 0, 400);
            add_slider(Blower, 'gk_Blower_grainFrequencyRange', 0, 100);
            var Bower = gui.addFolder('Bower');
            add_slider(Bower, 'gk_Bower_level', -50, 50);
            add_slider(Bower, 'gk_Bower_pressure', 0, 5);
            add_slider(Bower, 'gk_Bower_rat', 0, .5);
            var Buzzer = gui.addFolder('Buzzer');
            add_slider(Buzzer, 'gk_Buzzer_level', -50, 50);
            add_slider(Buzzer, 'gk_Buzzer_harmonics', 0, 20);
            var Droner = gui.addFolder('Droner');
            add_slider(Droner, 'gk_Droner_level', -50, 50);
            add_slider(Droner, 'gk_Droner_partial1', 0, 1);
            add_slider(Droner, 'gk_Droner_partial2', 0, 1);
            add_slider(Droner, 'gk_Droner_partial3', 0, 1);
            add_slider(Droner, 'gk_Droner_partial4', 0, 1);
            add_slider(Droner, 'gk_Droner_partial5', 0, 1);
            var FilteredSines = gui.addFolder('Filtered Sines');
            add_slider(FilteredSines, 'gk_FilteredSines_level', -50, 50);
            var Flute = gui.addFolder('Zakian Flute');
            add_slider(Flute, 'gk_ZakianFlute_level', -50, 50);
            var FMWaterBell = gui.addFolder('FMWaterBell');
            add_slider(FMWaterBell, 'gk_FMWaterBell_level', -50, 50);
            add_slider(FMWaterBell, 'gi_FMWaterBell_attack', 0, .1);
            add_slider(FMWaterBell, 'gi_FMWaterBell_release', 0, .1);
            add_slider(FMWaterBell, 'gi_FMWaterBell_exponent', -30, 30);
            add_slider(FMWaterBell, 'gi_FMWaterBell_sustain', 0, 20);
            add_slider(FMWaterBell, 'gi_FMWaterBell_sustain_level', 0, 1);
            add_slider(FMWaterBell, 'gk_FMWaterBell_crossfade', 0, 1);
            add_slider(FMWaterBell, 'gk_FMWaterBell_index', 0, 15);
            add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_depth', 0, 10);
            add_slider(FMWaterBell, 'gk_FMWaterBell_vibrato_rate', 0, 10);
            var Guitar = gui.addFolder('Guitar');
            add_slider(Guitar, 'gk_Guitar_level', -50, 50);
            var Kung2 = gui.addFolder('Kung2');
            add_slider(Kung2, 'gk_Kung2_level', -50, 50);
            var Kung4 = gui.addFolder('Kung4');
            add_slider(Kung4, 'gk_Kung4_level', -50, 50);
            var Phaser = gui.addFolder('Phaser');
            add_slider(Phaser, 'gk_Phaser_level', -50, 50);
            add_slider(Phaser, 'gk_Phaser_ratio1', 0, 5);
            add_slider(Phaser, 'gk_Phaser_ratio2', 0, 5);
            add_slider(Phaser, 'gk_Phaser_index1', 0, 15);
            add_slider(Phaser, 'gk_Phaser_index2', 0, 15);
            var Plucked = gui.addFolder('Plucked');
            add_slider(Plucked, 'gk_Plucked_level', -50, 50);
            var Shiner = gui.addFolder('Shiner');
            add_slider(Shiner, 'gk_Shiner_level', -50, 50);
            add_slider(Shiner, 'gk_Shiner_attack', 0, 1);
            add_slider(Shiner, 'gk_Shiner_release', 0, 4);
            var SeidelHarmonicOsc = gui.addFolder('SeidelHarmonicOsc');
            add_slider(SeidelHarmonicOsc, 'gk_SeidelHarmonicOsc_level', -50, 50);
            var Sweeper = gui.addFolder('Sweeper');
            add_slider(Sweeper, 'gk_Sweeper_level', -50, 50);
            add_slider(Sweeper, 'gk_Sweeper_britel', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_briteh', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_britels', 0, 4);
            add_slider(Sweeper, 'gk_Sweeper_britehs', 0, 4);
            var TubularBell = gui.addFolder('TubularBell');
            add_slider(TubularBell, 'gk_TubularBell_level', -50, 50);
            var VcvRack = gui.addFolder('VcvRack');
            add_slider(VcvRack, 'gk_VcvOut_level', -50, 50);
            var YiString = gui.addFolder('YiString');
            add_slider(YiString, 'gk_YiString_level', -50, 50);
            var Xing = gui.addFolder('Xing');
            add_slider(Xing, 'gk_Xing_level', -50, 50);
            // Remembers parameter values. Required for the 'Revert' button to 
            // work, and to be able to save/restore new presets.
            gui.remember(parameters);
            document.addEventListener("keydown", function (e) {
                var e_char = String.fromCharCode(e.keyCode || e.charCode);
                if (e.ctrlKey === true) {
                    if (e_char === 'H') {
                        var console = document.getElementById("console");
                        if (console.style.display === "none") {
                            console.style.display = "block";
                        } else {
                            console.style.display = "none";
                        }
                        gui.closed = true;
                        gui.closed = false;
                    } else if (e_char === 'G') {
                        generate_score_hook();
                    } else if (e_char === 'P') {
                        parameters.play();
                    } else if (e_char === 'S') {
                        parameters.stop();
                    }
                }
            });
        };

        var gk_update = function (name, value) {
            var numberValue = parseFloat(value);
            console.log("gk_update: name: " + name + " value: " + numberValue);
            if (non_csound(csound) == false) {
                csound.SetControlChannel(name, numberValue);
            }
        }

        var add_slider = function (gui_folder, token, minimum, maximum, step) {
            var on_parameter_change = function (value) {
                gk_update(token, value);
            };
            gui_folder.add(parameters, token, minimum, maximum, step).listen().onChange(on_parameter_change);
        };

        window.addEventListener("unload", function (event) {
            nw_window.close();
        });

    </script>

    <!-- endregion -->

    <!-- #region Csound Orchestra -->

    <textarea id="csd" cols=80 rows=24 style="display:none;">

<CsoundSynthesizer>
  <CsOptions>
  -dm162 -odac --sample-accurate
  </CsOptions>
  <CsInstruments>
  ; Change to 96000 with 100 ksmps for final rendering.
  sr = 96000
  ksmps = 100
  nchnls = 2
  0dbfs = 3
  
  ; Ensure the same random stream for each rendering.
  ; rand, randh, randi, rnd(x) and birnd(x) are not affected by seed.
  
  ;seed  81814
  ;seed  818145
  seed  88818145
  
  connect "Blower", "outleft", "Shimmer", "inleft"
  connect "Blower", "outright", "Shimmer", "inright"
  connect "Bower", "outleft", "Shimmer", "inleft"
  connect "Bower", "outright", "Shimmer", "inright"
  connect "Buzzer", "outleft", "Shimmer", "inleft"
  connect "Buzzer", "outright", "Shimmer", "inright"
  connect "Droner", "outleft", "Shimmer", "inleft"
  connect "Droner", "outright", "Shimmer", "inright"
  connect "FMWaterBell", "outleft", "Shimmer", "inleft"
  connect "FMWaterBell", "outright", "Shimmer", "inright"
  ; Phaser is the one that actually "buzzes" in this piece.
  connect "Phaser", "outleft", "Shimmer", "inleft"
  connect "Phaser", "outright", "Shimmer", "inright"
  connect "Sweeper", "outleft", "Shimmer", "inleft"
  connect "Sweeper", "outright", "Shimmer", "inright"
  connect "Shiner", "outleft", "Shimmer", "inleft"
  connect "Shiner", "outright", "Shimmer", "inright"
  connect "ZakianFlute", "outleft", "Shimmer", "inleft"
  connect "ZakianFlute", "outright", "Shimmer", "inright"
  connect "FilteredSines", "outleft", "Shimmer", "inleft"
  connect "FilteredSines", "outright", "Shimmer", "inright"
  connect "Guitar", "outleft", "Shimmer", "inleft"
  connect "Guitar", "outleft", "Shimmer", "inleft"
  connect "Harpsichord", "outleft", "Shimmer", "inleft"
  connect "Harpsichord", "outright", "Shimmer", "inright"
  connect "Kung2", "outleft", "Shimmer", "inleft"
  connect "Kung2", "outright", "Shimmer", "inright"
  connect "Kung4", "outleft", "Shimmer", "inleft"
  connect "Kung4", "outright", "Shimmer", "inright"
  connect "Plucked", "outleft", "Shimmer", "inleft"
  connect "Plucked", "outright", "Shimmer", "inright"
  connect "SeidelHarmOsc", "outleft", "Shimmer", "inleft"
  connect "SeidelHarmOsc", "outright", "Shimmer", "inright"
  connect "TubularBell", "outleft", "Shimmer", "inleft"
  connect "TubularBell", "outright", "Shimmer", "inright"
  connect "YiString", "outleft", "Shimmer", "inleft"
  connect "YiString", "outright", "Shimmer", "inright"
  connect "VcvOut", "outleft", "Shimmer", "inleft"
  connect "VcvOut", "outright", "Shimmer", "inright"
  connect "Xing", "outleft", "Shimmer", "inleft"
  connect "Xing", "outright", "Shimmer", "inright"

  connect "Shimmer", "outleft", "MasterOutput", "inleft"
  connect "Shimmer", "outright", "MasterOutput", "inright"
  
  alwayson "VcvOut"
  alwayson "Shimmer"
  alwayson "MasterOutput"
  
  gk_Duration_factor init 4.5
  
  prealloc 1, 50
  prealloc 2, 50
  prealloc 3, 50
  prealloc 4, 50
  prealloc 5, 50
  prealloc 6, 50
  prealloc 7, 50
  prealloc 8, 20
  prealloc 9, 20

gi_Cardinal vst3initpreset "/Library/Audio/Plug-Ins/VST3/Cardinal.vst3", "Cardinal", "wibl-2.vstpreset", 0
  
  //////////////////////////////////////////////
  // Original by Steven Yi.
  // Adapted by Michael Gogins.
  //////////////////////////////////////////////
  gk_FMWaterBell_level chnexport "gk_FMWaterBell_level", 3 ; 0
  gi_FMWaterBell_attack chnexport "gi_FMWaterBell_attack", 3 ; 0.002
  gi_FMWaterBell_release chnexport "gi_FMWaterBell_release", 3 ; 0.01
  gi_FMWaterBell_sustain chnexport "gi_FMWaterBell_sustain", 3 ; 20
  gi_FMWaterBell_sustain_level chnexport "gi_FMWaterBell_sustain_level", 3 ; .1
  gk_FMWaterBell_index chnexport "gk_FMWaterBell_index", 3 ; .5
  gk_FMWaterBell_crossfade chnexport "gk_FMWaterBell_crossfade", 3 ; .5
  gk_FMWaterBell_vibrato_depth chnexport "gk_FMWaterBell_vibrato_depth", 3 ; 0.05
  gk_FMWaterBell_vibrato_rate chnexport "gk_FMWaterBell_vibrato_rate", 3 ; 6
  gk_FMWaterBell_midi_dynamic_range chnexport "gk_FMWaterBell_midi_dynamic_range", 3 ; 20
  gk_FMWaterBell_level init 0
  gi_FMWaterBell_attack init 0.002
  gi_FMWaterBell_release init 0.01
  gi_FMWaterBell_sustain init 20
  gi_FMWaterBell_sustain_level init .1
  gk_FMWaterBell_index init .5
  gk_FMWaterBell_crossfade init .5
  gk_FMWaterBell_vibrato_depth init 0.05
  gk_FMWaterBell_vibrato_rate init 6
  gk_FMWaterBell_midi_dynamic_range init 20
  gk_FMWaterBell_space_left_to_right chnexport "gk_FMWaterBell_space_left_to_right", 3
  gk_FMWaterBell_space_left_to_right init .5
  gi_FMWaterBell_cosine ftgen 0, 0, 65537, 11, 1
  instr FMWaterBell
  i_instrument = p1
  i_time = p2
  i_duration = p3
  ; One of the envelopes in this instrument should be releasing, and use this:
  i_sustain = 1000
  xtratim gi_FMWaterBell_attack + gi_FMWaterBell_release
  i_midi_key = p4
  i_midi_dynamic_range = i(gk_FMWaterBell_midi_dynamic_range)
  i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
  k_space_front_to_back = p6
  if p7 == 0 then
  k_space_left_to_right = gk_FMWaterBell_space_left_to_right
  else
  k_space_left_to_right = p7
  endif
  k_space_bottom_to_top = p8
  i_phase = p9
  i_frequency = cpsmidinn(i_midi_key)
  ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
  i_level_correction = 80
  i_normalization = ampdb(-i_level_correction) / 2
  i_amplitude = ampdb(i_midi_velocity) * i_normalization * 1.6
  k_gain = ampdb(gk_FMWaterBell_level)
  i_releasing_attack = 3 / min(i_frequency, 256)
  i_releasing_release = .01
  a_signal fmbell	1, i_frequency, gk_FMWaterBell_index, gk_FMWaterBell_crossfade, gk_FMWaterBell_vibrato_depth, gk_FMWaterBell_vibrato_rate, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine, gi_FMWaterBell_cosine ;, gi_FMWaterBell_sustain
  a_envelope transeg 0, gi_FMWaterBell_attack, 6,  1, gi_FMWaterBell_sustain, -6,  0
  a_declicking cossegr 0, i_releasing_attack, 1, gi_FMWaterBell_sustain - 1, 1, i_releasing_release, 0
  ;;;a_signal = a_signal * i_amplitude * a_envelope * a_declicking * k_gain
  a_signal = a_signal * i_amplitude * a_envelope * a_declicking * k_gain
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  ;printks "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
  endin
  
  gk_Phaser_attack chnexport "gk_Phaser_attack", 3 ;  .125
  gk_Phaser_release chnexport "gk_Phaser_release", 3 ;  .125
  gk_Phaser_ratio1 chnexport "gk_Phaser_ratio1", 3 ;  1
  gk_Phaser_ratio2 chnexport "gk_Phaser_ratio2", 3 ;  1/5
  gk_Phaser_index1 chnexport "gk_Phaser_index1", 3 ;  1.01
  gk_Phaser_index2 chnexport "gk_Phaser_index2", 3 ;  .103
  gk_Phaser_level chnexport "gk_Phaser_level", 3 ;  0.5
  gk_Phaser_midi_dynamic_range chnexport "gk_Phaser_midi_dynamic_range", 3 ;  20
  gk_Phaser_attack init .125
  gk_Phaser_release init .125
  gk_Phaser_ratio1 init 1
  gk_Phaser_ratio2 init 1/5
  gk_Phaser_index1 init 1.01
  gk_Phaser_index2 init .103
  gk_Phaser_level init 0.5
  gk_Phaser_midi_dynamic_range init 20
  gi_Phaser_sine ftgen 0,0,65537,10,1
  instr Phaser
  i_instrument = p1
  i_time = p2
  i_duration = p3
  i_midi_key = p4
  i_midi_dynamic_range = i(gk_Phaser_midi_dynamic_range)
  i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
  k_space_front_to_back = p6
  k_space_left_to_right = p7
  k_space_bottom_to_top = p8
  i_phase = p9
  i_frequency = cpsmidinn(i_midi_key)
  ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
  i_level_correction = 81
  i_normalization = ampdb(-i_level_correction) / 2
  i_amplitude = ampdb(i_midi_velocity) * i_normalization
  k_gain = ampdb(gk_Phaser_level)
  i_attack = i(gk_Phaser_attack)
  i_release = i(gk_Phaser_release)
  i_sustain = 1000
  xtratim i_attack + i_release
  a_envelope transegr 0.0, i_attack / 2.0, 1.5, i_amplitude / 2.0, i_attack / 2.0, -1.5, i_amplitude, i_sustain, 0.0, i_amplitude, i_release / 2.0, 1.5, i_amplitude / 2.0, i_release / 2.0, -1.5, 0
  a1,a2 crosspm gk_Phaser_ratio1, gk_Phaser_ratio2, gk_Phaser_index1, gk_Phaser_index2, i_frequency, gi_Phaser_sine, gi_Phaser_sine
  a_signal = (a1 + a2) * k_gain * a_envelope
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  ;printks "Phaser         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(aleft)), dbamp(rms(aright))
  endin
  
  gk_Droner_partial1 chnexport "gk_Droner_partial1", 3
  gk_Droner_partial2 chnexport "gk_Droner_partial2", 3
  gk_Droner_partial3 chnexport "gk_Droner_partial3", 3
  gk_Droner_partial4 chnexport "gk_Droner_partial4", 3
  gk_Droner_partial5 chnexport "gk_Droner_partial5", 3
  gk_Droner_partial6 chnexport "gk_Droner_partial6", 3
  gk_Droner_partial7 chnexport "gk_Droner_partial7", 3
  gk_Droner_partial8 chnexport "gk_Droner_partial8", 3
  gk_Droner_partial9 chnexport "gk_Droner_partial9", 3
  gk_Droner_partial10 chnexport "gk_Droner_partial10", 3
  gk_Droner_level chnexport "gk_Droner_level", 3
  gi_Droner_waveform chnexport "gi_Droner_waveform", 3
  gk_Droner_partial1 init .5
  gk_Droner_partial2 init .05
  gk_Droner_partial3 init .1
  gk_Droner_partial4 init .2
  gk_Droner_partial5 init .1
  gk_Droner_partial6 init 0
  gk_Droner_partial7 init 0
  gk_Droner_partial8 init 0
  gk_Droner_partial9 init 0
  gk_Droner_partial10 init 0
  gk_Droner_level init 0
  gi_Droner_waveform init 0
  gk_Droner_space_left_to_right chnexport "gk_Droner_space_left_to_right", 3
  gk_Droner_space_left_to_right init .5
  gi_Droner_sine ftgen 0, 0, 65537, 10, 1, 0, .02
  instr Droner
  i_instrument = p1
  i_time = p2
  ; Make indefinite notes last no longer than the physical decay.
  i_physical_decay = 200000
  if p3 == -1 then
  i_duration = i_physical_decay
  else
  i_duration = p3
  endif
  i_midi_key = p4
  i_midi_velocity = p5
  k_space_front_to_back = p6
  if p7 ==0 then
  k_space_left_to_right = gk_Droner_space_left_to_right
  else
  k_space_left_to_right = p7
  endif
  k_space_bottom_to_top = p8
  i_phase = p9
  i_frequency = cpsmidinn(i_midi_key)
  ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
  i_overall_amps = 19
  i_normalization = ampdb(-i_overall_amps) / 2
  i_amplitude = ampdb(i_midi_velocity) * i_normalization
  k_gain = ampdb(gk_Droner_level)
  k1 = gk_Droner_partial1
  k2 = gk_Droner_partial2
  k3 = gk_Droner_partial3
  k4 = gk_Droner_partial4
  k5 = gk_Droner_partial5
  k6 = gk_Droner_partial6
  k7 = gk_Droner_partial7
  k8 = gk_Droner_partial8
  k9 = gk_Droner_partial9
  k10 = gk_Droner_partial10
  iwaveform = gi_Droner_waveform
  iattack = .5
  idecay = .5
  isustain = p3
  aenvelope transegr 0.0, iattack / 2.0, 1.5, 1 / 2.0, iattack / 2.0, -1.5, 1, isustain, 0.0, 1, idecay / 2.0, 1.5, 1 / 2.0, idecay / 2.0, -1.5, 0
  ihertz = cpsmidinn(i_midi_key)
  if iwaveform == 0 goto i_waveform_0
  if iwaveform == 1 goto i_waveform_1
  if iwaveform == 2 goto i_waveform_2
  i_waveform_0:
  asignal poscil3 1, ihertz, gi_Droner_sine
  goto i_waveform_endif
  i_waveform_1:
  asignal vco2 1, ihertz, 8 ; integrated saw
  goto i_waveform_endif
  i_waveform_2:
  asignal vco2 1, ihertz, 12 ; triangle
  i_waveform_endif:
  a_signal chebyshevpoly asignal, 0, k1, k2, k3, k4, k5, k6, k7, k8, k9, k10
  ;adeclicking linsegr 0, .004, 1, p3 - .014, 1, .1, 0
  ;a_signal = asignal * adeclicking
  ;
  ; The de-clicking envelope must have attack and release segments that damp 
  ; artifacts in the signal. The duration of these segments depends on 
  ; the behavior of the instrument, and may vary as a function of frequency.
  i_declick_attack = .005
  i_declick_release = .01
  ; The end of the note must be extended _past_ the end of the release segment.
  xtratim 1
  a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
  ; The envelope of the instrument is the product of the physical envelope times 
  ; the declicking envelope. 
  a_envelope = aenvelope * a_declicking_envelope
  ; That envelope is then low-pass filtered to remove most discontinuities.
  a_filtered_envelope tonex a_envelope, 40, 4
  a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  endin
    
  gk_Sweeper_midi_dynamic_range chnexport "gk_Sweeper_midi_dynamic_range", 3 ;  127
  gk_Sweeper_attack chnexport "gk_Sweeper_attack", 3 ;  .125
  gk_Sweeper_release chnexport "gk_Sweeper_release", 3 ;  .25
  gk_Sweeper_britel chnexport "gk_Sweeper_britel", 3 ;  0.1
  gk_Sweeper_briteh chnexport "gk_Sweeper_briteh", 3 ;  2.9
  gk_Sweeper_britels chnexport "gk_Sweeper_britels", 3 ;  2
  gk_Sweeper_britehs chnexport "gk_Sweeper_britehs", 3 ;  1
  gk_Sweeper_level chnexport "gk_Sweeper_level", 3 ;  0
  gk_Sweeper_midi_dynamic_range init 20
  gk_Sweeper_attack init .125
  gk_Sweeper_release init .25
  gk_Sweeper_britel init .01
  gk_Sweeper_briteh init 5
  gk_Sweeper_britels init .5
  gk_Sweeper_britehs init 1.75
  gk_Sweeper_level init 0
  gk_Sweeper_space_left_to_right chnexport "gk_Sweeper_space_left_to_right", 3
  gk_Sweeper_space_left_to_right init .5
  gi_Sweeper_sine ftgen 0, 0, 65537, 10, 1
  gi_Sweeper_octfn ftgen 0, 0, 65537, -19, 1, 0.5, 270, 0.5
  instr Sweeper
  //////////////////////////////////////////////
  // Original by Iain McCurdy.
  // Adapted by Michael Gogins.
  //////////////////////////////////////////////
  i_instrument = p1
  i_time = p2
  i_duration = p3
  i_midi_key = p4
  i_midi_dynamic_range = i(gk_Sweeper_midi_dynamic_range)
  i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
  k_space_front_to_back = p6
  if p7 ==0 then
  k_space_left_to_right = gk_Sweeper_space_left_to_right
  else
  k_space_left_to_right = p7
  endif
  k_space_bottom_to_top = p8
  i_phase = p9
  i_frequency = cpsmidinn(i_midi_key)
  ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
  i_level_correction = 34.2
  i_normalization = ampdb(-i_level_correction) / 2
  i_amplitude = ampdb(i_midi_velocity) * i_normalization
  k_gain = ampdb(gk_Sweeper_level)
  iattack = i(gk_Sweeper_attack)
  irelease = i(gk_Sweeper_release)
  isustain = p3
  kenvelope transegr 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, irelease / 2.0, 1.5, i_amplitude / 2.0, irelease / 2.0, -1.5, 0
  ihertz = i_frequency
  icps = ihertz
  kamp expseg 0.001,0.02,0.2,p3-0.01,0.001
  ktonemoddep jspline 0.01,0.05,0.2
  ktonemodrte jspline 6,0.1,0.2
  ktone poscil3 ktonemoddep, ktonemodrte, gi_Sweeper_sine
  ; kres rspline krangeMin, krangeMax, kcpsMin, kcpsMax
  kbrite rspline gk_Sweeper_britel, gk_Sweeper_briteh, gk_Sweeper_britels, gk_Sweeper_britehs
  ibasfreq init icps
  ioctcnt init 3
  iphs init 0
  a1 hsboscil kenvelope, ktone, kbrite, ibasfreq, gi_Sweeper_sine, gi_Sweeper_octfn, ioctcnt, iphs
  amod poscil3 0.25, ibasfreq*(1/3), gi_Sweeper_sine
  arm = a1*amod
  kmix expseg 0.001, 0.01, rnd(1), rnd(3)+0.3, 0.001
  kmix=.25
  a1 ntrpol a1, arm, kmix
  kpanrte jspline 5, 0.05, 0.1
  kpandep jspline 0.9, 0.2, 0.4
  kpan poscil3 kpandep, kpanrte, gi_Sweeper_sine
  ;a1,a2 pan2 a1, kpan
  a1,a2 pan2 a1, k_space_left_to_right
  aleft delay a1, rnd(0.1)
  aright delay a2, rnd(0.11)
  a_signal = (aleft + aright)
  ; As with most software instruments that are modeled on an impulse exciting a 
  ; resonator, there should be two envelopes. The "physical" envelope must have a 
  ; fixed decay ending at zero.
  i_declick_minimum = .003
  i_attack = .001 / i_frequency + i_declick_minimum
  i_declick_attack = i_attack
  i_declick_release = i_declick_minimum * 2
  ; The end of the note must be extended _past_ the end of the release segment.
  xtratim 1
  a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
  ; The envelope of the instrument is the product of the physical envelope times 
  ; the declicking envelope. 
  a_envelope = a_declicking_envelope
  ; That envelope is then low-pass filtered to remove most discontinuities.
  a_filtered_envelope tonex a_envelope, 40, 4
  a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  outs a_out_left, a_out_right
  endin
    
  gk_Buzzer_attack chnexport "gk_Buzzer_attack", 3
  gk_Buzzer_release chnexport "gk_Buzzer_release", 3
  gk_Buzzer_harmonics chnexport "gk_Buzzer_harmonics", 3
  gk_Buzzer_level chnexport "gk_Buzzer_level", 3
  gk_Buzzer_midi_dynamic_range chnexport "gk_Buzzer_midi_dynamic_range", 3
  gk_Buzzer_attack init .125
  gk_Buzzer_release init .25
  gk_Buzzer_harmonics init 8
  gk_Buzzer_level init 0
  gk_Buzzer_midi_dynamic_range init 20
  gi_Buzzer_sine ftgen 0, 0, 65537, 10, 1
  instr Buzzer
  i_instrument = p1
  i_time = p2
  i_duration = p3
  i_midi_key = p4
  i_midi_dynamic_range = i(gk_Buzzer_midi_dynamic_range)
  i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
  k_space_front_to_back = p6
  k_space_left_to_right = p7
  k_space_bottom_to_top = p8
  i_phase = p9
  i_frequency = cpsmidinn(i_midi_key)
  ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
  i_level_correction = 75
  i_normalization = ampdb(-i_level_correction) / 2
  i_amplitude = ampdb(i_midi_velocity) * i_normalization
  k_gain = ampdb(gk_Buzzer_level)
  i_attack = i(gk_Buzzer_attack)
  i_release = i(gk_Buzzer_release)
  i_sustain = p3
  xtratim 1
  a_envelope transegr 0.0, i_attack / 2.0, 1.5, i_amplitude / 2.0, i_attack / 2.0, -1.5, i_amplitude, i_sustain, 0.0, i_amplitude, i_release / 2.0, 1.5, i_amplitude / 2.0, i_release / 2.0, -1.5, 0
  a_signal buzz a_envelope, i_frequency, gk_Buzzer_harmonics, gi_Buzzer_sine
  a_signal = a_signal * k_gain
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  ;printks "Buzzer         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
  endin
    
gk_Shiner_midi_dynamic_range chnexport "gk_Shiner_midi_dynamic_range", 3 ;  127
gk_Shiner_attack chnexport "gk_Shiner_attack", 3 ;  .0125
gk_Shiner_release chnexport "gk_Shiner_release", 3 ;  .0125
gk_Shiner_level chnexport "gk_Shiner_level", 3 ;  0.5
gk_Shiner_midi_dynamic_range init 20
gk_Shiner_attack init .0125
gk_Shiner_release init .0125
gk_Shiner_level init -23
gk_Shiner_front_to_back chnexport "gk_Shiner_front_to_back", 3 ;  0
gk_Shiner_left_to_right chnexport "gk_Shiner_left_to_right", 3 ;  0.5
gk_Shiner_bottom_to_top chnexport "gk_Shiner_bottom_to_top", 3 ;  0
gk_Shiner_front_to_back init 0
gk_Shiner_left_to_right init 0.5
gk_Shiner_bottom_to_top init 0
instr Shiner
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_physical_decay = 20
if p3 == -1 then
i_duration = i_physical_decay
else
i_duration = p3
endif
i_midi_key = p4
i_midi_dynamic_range = i(gk_Shiner_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
if p7 ==0 then
k_space_left_to_right = gk_Shiner_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 42.5
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Shiner_level)
iattack = i(gk_Shiner_attack)
idecay = i(gk_Shiner_release)
isustain = i_duration
a_physical_envelope transeg 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, idecay / 2.0, 1.5, i_amplitude / 2.0, idecay / 2.0, -1.5, 0
ihertz = cpsmidinn(i_midi_key)
gk_Harmonics = 1 * 20
a_signal vco2 4, ihertz, 12
kgain = ampdb(gk_Shiner_level) * .5
; The end of the note must be extended _past_ the end of the release segment.
xtratim 1
a_declicking_envelope cossegr 0, .005, 1,  i_duration, 1,  .01, 0
; The envelope of the instrument is the product of the physical envelope times 
; the declicking envelope. 
a_envelope = a_physical_envelope * a_declicking_envelope
; That envelope is then low-pass filtered to remove most discontinuities.
a_filtered_envelope tonex a_envelope, 40, 4
a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
endin

gk_Blower_grainDensity chnexport "gk_Blower_grainDensity", 3
gk_Blower_grainDuration chnexport "gk_Blower_grainDuration", 3
gk_Blower_grainAmplitudeRange chnexport "gk_Blower_grainAmplitudeRange", 3
gk_Blower_grainFrequencyRange chnexport "gk_Blower_grainFrequencyRange", 3
gk_Blower_attack chnexport "gk_Blower_attack", 3
gk_Blower_release chnexport "gk_Blower_release", 3
gk_Blower_level chnexport "gk_Blower_level", 3
gk_Blower_midi_dynamic_range chnexport "gk_Blower_midi_dynamic_range", 3
gk_Blower_grainDensity init 40
gk_Blower_grainDuration init 0.2
gk_Blower_grainAmplitudeRange init 100
gk_Blower_grainFrequencyRange init 3
gk_Blower_attack init 1.5 
gk_Blower_release init 2
gk_Blower_level init 0
gk_Blower_midi_dynamic_range init 20
gk_Blower_space_left_to_right chnexport "gk_Blower_space_left_to_right", 3
gk_Blower_space_left_to_right init .5
gi_Blower_grtab ftgen 0, 0, 65537, 10, 1, .3, .1, 0, .2, .02, 0, .1, .04
gi_Blower_wintab ftgen 0, 0, 65537, 10, 1, 0, .5, 0, .33, 0, .25, 0, .2, 0, .167
instr Blower
//////////////////////////////////////////////
// Original by Hans Mikelson.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_Blower_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
if p7 ==0 then
k_space_left_to_right = gk_Blower_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 123
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Blower_level)
iHz = i_frequency
ihertz = iHz
ip4 = i_amplitude
ip5 = iHz
ip6 = gi_Blower_grtab
ip7 = gi_Blower_wintab
ip8 = 0.033
ip8 = .002
ip9 = 150
ip9 = 100
ip10 = 1.6
ip10 = 3
idur = p3
iamp = i_amplitude ; p4
ifqc = iHz ; cpspch(p5)
igrtab = ip6
iwintab = ip7
ifrng = ip8
idens = ip9
ifade = ip10
igdur = 0.2
iattack = i(gk_Blower_attack)
i_sustain = p3
idecay = i(gk_Blower_release)
xtratim iattack + idecay
kenvelope transegr 0.0, iattack / 2.0, 1.5, .5, iattack / 2.0, -1.5, 1, i_sustain, 0.0, 1, idecay / 2.0, 1.5, .5, idecay / 2.0, -1.5, 0
; Amp Fqc Dense AmpOff PitchOff GrDur GrTable WinTable MaxGrDur
// Maybe frequency range should really be pitch range?
aoutl grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
aoutr grain ip4, ifqc, gk_Blower_grainDensity, gk_Blower_grainAmplitudeRange, gk_Blower_grainFrequencyRange, gk_Blower_grainDuration, igrtab, iwintab, 5
a_signal = aoutl + aoutr
i_attack = .002
i_release = 0.01
; xtratim i_attack + i_release
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
; print iattack, idecay
a_signal = a_signal * i_amplitude * k_gain * kenvelope
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
;printks "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
endin
  
  gk_ZakianFlute_midi_dynamic_range chnexport "gk_ZakianFlute_midi_dynamic_range", 3 ;  20
  gk_ZakianFlute_level chnexport "gk_ZakianFlute_level", 3 ;  0
  gk_ZakianFlute_pan chnexport "gk_ZakianFlute_pan", 3 ;  .5
  gi_ZakianFLute_seed chnexport "gi_ZakianFLute_seed", 3 ;  .5
  gi_ZakianFLute_space_left_to_front chnexport "gi_ZakianFLute_space_left_to_front", 3 ;  .5
  gk_ZakianFlute_midi_dynamic_range init 20
  gk_ZakianFlute_level init 0
  gk_ZakianFlute_pan init .5
  gi_ZakianFLute_seed init .5
  gi_ZakianFLute_space_left_to_front init .5
  gi_ZakianFLute_f2  ftgen 0, 0, 16, -2, 40, 40, 80, 160, 320, 640, 1280, 2560, 5120, 10240, 10240
  gi_ZakianFlute_f26 ftgen 0, 0, 65537, -10, 2000, 489, 74, 219, 125, 9, 33, 5, 5
  gi_ZakianFlute_f27 ftgen 0, 0, 65537, -10, 2729, 1926, 346, 662, 537, 110, 61, 29, 7
  gi_ZakianFlute_f28 ftgen 0, 0, 65537, -10, 2558, 2012, 390, 361, 534, 139, 53, 22, 10, 13, 10
  gi_ZakianFlute_f29 ftgen 0, 0, 65537, -10, 12318, 8844, 1841, 1636, 256, 150, 60, 46, 11
  gi_ZakianFlute_f30 ftgen 0, 0, 65537, -10, 1229, 16, 34, 57, 32
  gi_ZakianFlute_f31 ftgen 0, 0, 65537, -10, 163, 31, 1, 50, 31
  gi_ZakianFlute_f32 ftgen 0, 0, 65537, -10, 4128, 883, 354, 79, 59, 23
  gi_ZakianFlute_f33 ftgen 0, 0, 65537, -10, 1924, 930, 251, 50, 25, 14
  gi_ZakianFlute_f34 ftgen 0, 0, 65537, -10, 94, 6, 22, 8
  gi_ZakianFlute_f35 ftgen 0, 0, 65537, -10, 2661, 87, 33, 18
  gi_ZakianFlute_f36 ftgen 0, 0, 65537, -10, 174, 12
  gi_ZakianFlute_f37 ftgen 0, 0, 65537, -10, 314, 13
  gi_ZakianFlute_wtsin ftgen 0, 0, 65537, 10, 1
  instr ZakianFlute
  ; Author: Lee Zakian
  ; Adapted by: Michael Gogins
  i_instrument = p1
  i_time = p2
  if p3 == -1 then
  i_duration = 1000
  else
  i_duration = p3
  endif
  i_midi_key = p4
  i_midi_velocity = p5
  k_space_front_to_back = p6
  if p7 == 0 then
  k_space_left_to_right = gi_ZakianFLute_space_left_to_front
  else
  k_space_left_to_right = p7
  endif
  k_space_bottom_to_top = p8
  i_phase = p9
  i_overall_amps = 65.2
  i_normalization = ampdb(-i_overall_amps) / 2
  i_midi_dynamic_range = i(gk_ZakianFlute_midi_dynamic_range)
  i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
  i_amplitude = ampdb(i_midi_velocity) * i_normalization
  k_gain = ampdb(gk_ZakianFlute_level)
  ;;;xtratim iattack + irelease
  iHz = cpsmidinn(i_midi_key)
  kHz = k(iHz)
  // Bug?
  aenvelope transeg 1.0, 20.0, -10.0, 0.05
  ///aenvelope transegr 1.0, 20.0, -10.0, 0.05
  ip3 = 3;;; (p3 < 3.0 ? p3 : 3.0)
  ; parameters
  ; p4 overall amplitude scaling factor
  ip4 init i_amplitude
  ; p5 pitch in Hertz (normal pitch range: C4-C7)
  ip5 init iHz
  ; p6 percent vibrato depth, recommended values in range [-1., +1.]
  ip6 init 0.5
  ; 0.0 -> no vibrato
  ; +1. -> 1% vibrato depth, where vibrato rate increases slightly
  ; -1. -> 1% vibrato depth, where vibrato rate decreases slightly
  ; p7 attack time in seconds
  ; recommended value: .12 for slurred notes, .06 for tongued notes
  ; (.03 for short notes)
  ip7 init .08
  ; p8 decay time in seconds
  ; recommended value: .1 (.05 for short notes)
  ip8 init .08
  ; p9 overall brightness / filter cutoff factor
  ; 1 -> least bright / minimum filter cutoff frequency (40 Hz)
  ; 9 -> brightest / maximum filter cutoff frequency (10,240Hz)
  ip9 init 5
  ; initial variables
  iampscale = ip4 ; overall amplitude scaling factor
  ifreq = ip5 ; pitch in Hertz
  ivibdepth = abs(ip6*ifreq/100.0) ; vibrato depth relative to fundamental frequency
  iattack = ip7 * (1.1 - .2*gi_ZakianFLute_seed) ; attack time with up to +-10% random deviation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947) ; reset gi_ZakianFLute_seed
  idecay = ip8 * (1.1 - .2*gi_ZakianFLute_seed) ; decay time with up to +-10% random deviation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  ifiltcut tablei ip9, gi_ZakianFLute_f2 ; lowpass filter cutoff frequency
  iattack = (iattack < 6/kr ? 6/kr : iattack) ; minimal attack length
  idecay = (idecay < 6/kr ? 6/kr : idecay) ; minimal decay length
  isustain = i_duration - iattack - idecay
  ;;;p3 = (isustain < 5/kr ? iattack+idecay+5/kr : i_duration) ; minimal sustain length
  isustain = (isustain < 5/kr ? 5/kr : isustain)
  iatt = iattack/6
  isus = isustain/4
  idec = idecay/6
  iphase = gi_ZakianFLute_seed ; use same phase for all wavetables
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  ; vibrato block
  ; kvibdepth linseg .1, .8*p3, 1, .2*p3, .7
  kvibdepth linseg .1, .8*ip3, 1, isustain, 1, .2*ip3, .7
  kvibdepth = kvibdepth* ivibdepth ; vibrato depth
  kvibdepthr randi .1*kvibdepth, 5, gi_ZakianFLute_seed ; up to 10% vibrato depth variation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kvibdepth = kvibdepth + kvibdepthr
  ivibr1 = gi_ZakianFLute_seed ; vibrato rate
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  ivibr2 = gi_ZakianFLute_seed
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  if ip6 < 0 goto vibrato1
  kvibrate linseg 2.5+ivibr1, isustain, 4.5+ivibr2 ; if p6 positive vibrato gets faster
  goto vibrato2
  vibrato1:
  ivibr3 = gi_ZakianFLute_seed
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kvibrate linseg 3.5+ivibr1, .1, 4.5+ivibr2,isustain-.1, 2.5+ivibr3 ; if p6 negative vibrato gets slower
  vibrato2:
  kvibrater randi .1*kvibrate, 5, gi_ZakianFLute_seed ; up to 10% vibrato rate variation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kvibrate = kvibrate + kvibrater
  kvib oscili kvibdepth, kvibrate, gi_ZakianFlute_wtsin
  ifdev1 = -.03 * gi_ZakianFLute_seed ; frequency deviation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  ifdev2 = .003 * gi_ZakianFLute_seed
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  ifdev3 = -.0015 * gi_ZakianFLute_seed
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  ifdev4 = .012 * gi_ZakianFLute_seed
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kfreqr linseg ifdev1, iattack, ifdev2, isustain, ifdev3, idecay, ifdev4
  kfreq = kHz * (1 + kfreqr) + kvib
  if ifreq < 427.28 goto range1 ; (cpspch(8.08) + cpspch(8.09))/2
  if ifreq < 608.22 goto range2 ; (cpspch(9.02) + cpspch(9.03))/2
  if ifreq < 1013.7 goto range3 ; (cpspch(9.11) + cpspch(10.00))/2
  goto range4
  ; wavetable amplitude envelopes
  range1: ; for low range tones
  kamp1 linseg 0, iatt, 0.002, iatt, 0.045, iatt, 0.146, iatt, \
  0.272, iatt, 0.072, iatt, 0.043, isus, 0.230, isus, 0.000, isus, \
  0.118, isus, 0.923, idec, 1.191, idec, 0.794, idec, 0.418, idec, \
  0.172, idec, 0.053, idec, 0
  kamp2 linseg 0, iatt, 0.009, iatt, 0.022, iatt, -0.049, iatt, \
  -0.120, iatt, 0.297, iatt, 1.890, isus, 1.543, isus, 0.000, isus, \
  0.546, isus, 0.690, idec, -0.318, idec, -0.326, idec, -0.116, idec, \
  -0.035, idec, -0.020, idec, 0
  kamp3 linseg 0, iatt, 0.005, iatt, -0.026, iatt, 0.023, iatt, \
  0.133, iatt, 0.060, iatt, -1.245, isus, -0.760, isus, 1.000, isus, \
  0.360, isus, -0.526, idec, 0.165, idec, 0.184, idec, 0.060, idec, \
  0.010, idec, 0.013, idec, 0
  iwt1 = gi_ZakianFlute_f26 ; wavetable numbers
  iwt2 = gi_ZakianFlute_f27
  iwt3 = gi_ZakianFlute_f28
  inorm = 3949
  goto end
  range2: ; for low mid-range tones
  kamp1 linseg 0, iatt, 0.000, iatt, -0.005, iatt, 0.000, iatt, \
  0.030, iatt, 0.198, iatt, 0.664, isus, 1.451, isus, 1.782, isus, \
  1.316, isus, 0.817, idec, 0.284, idec, 0.171, idec, 0.082, idec, \
  0.037, idec, 0.012, idec, 0
  kamp2 linseg 0, iatt, 0.000, iatt, 0.320, iatt, 0.882, iatt, \
  1.863, iatt, 4.175, iatt, 4.355, isus, -5.329, isus, -8.303, isus, \
  -1.480, isus, -0.472, idec, 1.819, idec, -0.135, idec, -0.082, idec, \
  -0.170, idec, -0.065, idec, 0
  kamp3 linseg 0, iatt, 1.000, iatt, 0.520, iatt, -0.303, iatt, \
  0.059, iatt, -4.103, iatt, -6.784, isus, 7.006, isus, 11, isus, \
  12.495, isus, -0.562, idec, -4.946, idec, -0.587, idec, 0.440, idec, \
  0.174, idec, -0.027, idec, 0
  iwt1 = gi_ZakianFlute_f29
  iwt2 = gi_ZakianFlute_f30
  iwt3 = gi_ZakianFlute_f31
  inorm = 27668.2
  goto end
  range3: ; for high mid-range tones
  kamp1 linseg 0, iatt, 0.005, iatt, 0.000, iatt, -0.082, iatt, \
  0.36, iatt, 0.581, iatt, 0.416, isus, 1.073, isus, 0.000, isus, \
  0.356, isus, .86, idec, 0.532, idec, 0.162, idec, 0.076, idec, 0.064, \
  idec, 0.031, idec, 0
  kamp2 linseg 0, iatt, -0.005, iatt, 0.000, iatt, 0.205, iatt, \
  -0.284, iatt, -0.208, iatt, 0.326, isus, -0.401, isus, 1.540, isus, \
  0.589, isus, -0.486, idec, -0.016, idec, 0.141, idec, 0.105, idec, \
  -0.003, idec, -0.023, idec, 0
  kamp3 linseg 0, iatt, 0.722, iatt, 1.500, iatt, 3.697, iatt, \
  0.080, iatt, -2.327, iatt, -0.684, isus, -2.638, isus, 0.000, isus, \
  1.347, isus, 0.485, idec, -0.419, idec, -.700, idec, -0.278, idec, \
  0.167, idec, -0.059, idec, 0
  iwt1 = gi_ZakianFlute_f32
  iwt2 = gi_ZakianFlute_f33
  iwt3 = gi_ZakianFlute_f34
  inorm = 3775
  goto end
  range4: ; for high range tones
  kamp1 linseg 0, iatt, 0.000, iatt, 0.000, iatt, 0.211, iatt, \
  0.526, iatt, 0.989, iatt, 1.216, isus, 1.727, isus, 1.881, isus, \
  1.462, isus, 1.28, idec, 0.75, idec, 0.34, idec, 0.154, idec, 0.122, \
  idec, 0.028, idec, 0
  kamp2 linseg 0, iatt, 0.500, iatt, 0.000, iatt, 0.181, iatt, \
  0.859, iatt, -0.205, iatt, -0.430, isus, -0.725, isus, -0.544, isus, \
  -0.436, isus, -0.109, idec, -0.03, idec, -0.022, idec, -0.046, idec, \
  -0.071, idec, -0.019, idec, 0
  kamp3 linseg 0, iatt, 0.000, iatt, 1.000, iatt, 0.426, iatt, \
  0.222, iatt, 0.175, iatt, -0.153, isus, 0.355, isus, 0.175, isus, \
  0.16, isus, -0.246, idec, -0.045, idec, -0.072, idec, 0.057, idec, \
  -0.024, idec, 0.002, idec, 0
  iwt1 = gi_ZakianFlute_f35
  iwt2 = gi_ZakianFlute_f36
  iwt3 = gi_ZakianFlute_f37
  inorm = 4909.05
  goto end
  end:
  kampr1 randi .02*kamp1, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kamp1 = kamp1 + kampr1
  kampr2 randi .02*kamp2, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kamp2 = kamp2 + kampr2
  kampr3 randi .02*kamp3, 10, gi_ZakianFLute_seed ; up to 2% wavetable amplitude variation
  gi_ZakianFLute_seed = frac(gi_ZakianFLute_seed*105.947)
  kamp3 = kamp3 + kampr3
  awt1 poscil kamp1, kfreq, iwt1, iphase ; wavetable lookup
  awt2 poscil kamp2, kfreq, iwt2, iphase
  awt3 poscil kamp3, kfreq, iwt3, iphase
  asig = awt1 + awt2 + awt3
  asig = asig*(iampscale/inorm)
  kcut linseg 0, iattack, ifiltcut, isustain, ifiltcut, idecay, 0 ; lowpass filter for brightness control
  afilt tone asig, kcut
  a_signal balance afilt, asig
  i_attack = .002
  i_sustain = i_duration
  i_release = 0.01
  i_declick_attack = i_attack
  i_declick_release = i_declick_attack * 2
  ; The end of the note must be extended _past_ the end of the release segment.
  xtratim 1
  a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
  ; That envelope is then low-pass filtered to remove most discontinuities.
  a_filtered_envelope tonex a_declicking_envelope, 40, 4
  a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  a_signal *= .7
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  endin
    
  ; giPianoteq vstinit "/home/mkg/pianoteq_linux_v630/Pianoteq\ 6/amd64/Pianoteq\ 6.so", 1
  giPianoteq vst3init "/Library/Audio/Plug-Ins/VST3/Pianoteq 8.vst3", "Pianoteq 8", 1
  vst3info giPianoteq
  instr PianoteqNote
  i_instrument = p1
  i_time = p2
  i_duration = p3
  i_midikey = p4 - 12
  i_midivelocity = p5
  i_phase = p6
  i_pan = p7
  i_depth = p8
  i_height = p9
  i_pitchclassset = p10
  i_homogeneity = p11
  i_pitchclass = i_midikey % 12
  i_hertz cpsmidinn i_midikey
  i_amplitude = ampdb(i_midivelocity)
  ichannel = 0
  ; vstnote giPianoteq, ichannel, i_midikey, i_midivelocity, i_duration
  i_note_id vst3note  giPianoteq, 0, p4, p5, p3
  prints "PIanoteqNote   i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", p1, p2, p3, p4, p5, p7, active(p1)
  endin

  gk_Bower_midi_dynamic_range chnexport "gk_Bower_midi_dynamic_range", 3
  gk_Bower_attack chnexport "gk_Bower_attack", 3
  gk_Bower_release chnexport "gk_Bower_release", 3
  gk_Bower_level chnexport "gk_Bower_level", 3
  gk_Bower_pressure chnexport "gk_Bower_pressure", 3
  gk_Bower_space_left_to_right chnexport "gk_Bower_space_left_to_right", 3
  gk_Bower_midi_dynamic_range init 20
  gk_Bower_attack init .125
  gk_Bower_release init .125
  gk_Bower_level init 0
  gk_Bower_pressure init 0.25
  gk_Bower_space_left_to_right init 0.75
  gi_Bower_sine ftgen 0,0,65537,10,1
  instr Bower
  i_instrument = p1
  i_time = p2
  i_duration = p3
  i_midi_key = p4
  i_midi_dynamic_range = i(gk_Bower_midi_dynamic_range)
  i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
  k_space_front_to_back = p6
  if p7 == 0 then
  k_space_left_to_right = gk_Bower_space_left_to_right
  else
  k_space_left_to_right = p7
  endif
  k_space_bottom_to_top = p8
  k_space_bottom_to_top = p8
  i_phase = p9
  i_frequency = cpsmidinn(i_midi_key)
  ; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
  i_level_correction = 66
  i_normalization = ampdb(-i_level_correction) / 2
  i_amplitude = ampdb(i_midi_velocity) * i_normalization
  k_gain = ampdb(gk_Bower_level)
  iattack = i(gk_Bower_attack)
  idecay = i(gk_Bower_release)
  isustain = p3
  iamp = i_amplitude
  xtratim iattack + idecay
  kenvelope transegr 0.0, iattack / 2.0, 1.5, iamp / 2.0, iattack / 2.0, -1.5, iamp, isustain, 0.0, iamp, idecay / 2.0, 1.5, iamp / 2.0, idecay / 2.0, -1.5, 0
  ihertz = cpsmidinn(i_midi_key)
  kamp = kenvelope
  kfreq = ihertz
  kpres = 0.25
  krat rspline 0.006,0.988,1,4
  kvibf = 4.5
  kvibamp = 0
  iminfreq = i(kfreq) / 2
  aSig wgbow kamp,kfreq,gk_Bower_pressure,krat,kvibf,kvibamp,gi_Bower_sine,iminfreq
  a_signal = aSig * kenvelope * k_gain
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
  outleta "outleft", a_out_left
  outleta "outright", a_out_right
  ;printks "Blower         i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, p1, p2, p3, p4, p5, p7, active(p1), dbamp(rms(a_out_left)), dbamp(rms(a_out_right))
  endin
    
  gk_FilteredSines_level chnexport "gk_FilteredSines_level", 3
gi_FilteredSines_attack chnexport "gi_FilteredSines_attack", 3
gi_FilteredSines_release chnexport "gi_FilteredSines_release", 3

gk_FilteredSines_level init 0
gi_FilteredSines_attack init 1
  gi_FilteredSines_release init 1

gi_FilteredSines_bergeman ftgen 0, 0, 65537, 10, .28, 1, .74, .66, .78, .48, .05, .33, 0.12, .08, .01, .54, 0.19, .08, .05, 0.16, .01, 0.11, .3, .02, 0.2 ; Bergeman f1

instr FilteredSines
; Author: Michael Bergeman
; Modified by: Michael Gogins
xtratim gi_FilteredSines_attack + gi_FilteredSines_release
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_overall_amps = 166
i_normalization = ampdb(-i_overall_amps) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
i_frequency = cpsmidinn(i_midi_key)
k_gain = ampdb(gk_FilteredSines_level)
kHz = k(i_frequency)
koctave = octcps(kHz)
iattack init gi_FilteredSines_attack
isustain init p3
irelease init gi_FilteredSines_release
idb = 1.5
ip5 = gi_FilteredSines_bergeman
ip3 = 5.0
ip6 = 0.9
ip7 = 1.4
kp8 = cpsoct(koctave - .01)
kp9 = cpsoct(koctave + .01)
isc = idb * .333
k1 linseg 40, ip3, 800, p3, 800, 0.06, 0.0
k2 linseg 440, ip3, 220, p3, 220, 0.06, 0.0
k3 linseg 0.0, ip6, 800, ip7, 200.0, p3, 200, 0.06, 0.0
k4 linseg 800, ip3, 40, p3, 40, 0.06, 0.0
k5 linseg 220, ip3, 440, p3, 440, 0.06, 0.0
k6 linseg isc, ip6, p3, ip7, p3, 0.06, 0.0
k7 linseg 0.0, ip6, 1, ip7, .3, p3, .1, 0.06, 0.0
a5 poscil k3, kp8, ip5
a6 poscil k3, kp8 * 0.999, ip5
a7 poscil k3, kp8 * 1.001, ip5
a1 = a5 + a6 + a7
a8 poscil k6, kp9, ip5
a9 poscil k6, kp9 * 0.999, ip5
a10 poscil k6, kp9 * 1.001, ip5
a11 = a8 + a9 + a10
a2 butterbp a1, k1, 40
a3 butterbp a2, k5, k2 * 0.8
a4 balance a3, a1
a12 butterbp a11, k4, 40
a13 butterbp a12, k2, k5 * 0.8
a14 balance a13, a11
a15 reverb2 a4, 5, 0.3
a16 reverb2 a4, 4, 0.2
a17 = (a15 + a4) * k7
a18 = (a16 + a4) * k7
a_signal = (a17 + a18)
i_attack = .002
i_sustain = p3
i_release = 0.01
xtratim (i_attack + i_release)
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain * 1.88

a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  endin
  
  gk_Guitar_midi_dynamic_range chnexport "gk_Guitar_midi_dynamic_range", 3 ; 127
gk_Guitar_midi_dynamic_range init 30
gk_Guitar_level chnexport "gk_Guitar_level", 3
gk_Guitar_level init 0
gk_Guitar_space_left_to_right chnexport "gk_Guitar_space_left_to_right", 3
gk_Guitar_space_left_to_right init .5

instr Guitar
; Michael Gogins
; Simple emulation of a Spanish guitar.
; Considerably cleaned up after close listening and systematic testing. 
; But I think the plain `pluck` opcode is inherently a bit noisy. The 
; waveform is just jagged at first.
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_physical_decay = 20
if p3 == -1 then
i_duration = i_physical_decay
else
i_duration = p3
endif
i_midi_key = p4
i_midi_dynamic_range = i(gk_Guitar_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
if p7 ==0 then
k_space_left_to_right = gk_Guitar_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 73
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Guitar_level)
i_frequency2 = i_frequency
a_signal pluck 1.0, i_frequency, i_frequency2, 0, 6
a_top_body reson a_signal, 110, 80
a_bottom_body reson a_signal, 220, 100
a_whole_body reson a_signal, 440, 80
a_signal = (.6 * a_top_body + .8 * a_bottom_body + .6 * a_whole_body + .4 * a_signal) 
; For testing envelopes with a simple signal that lacks confounding artifacts.
; a_signal oscils .1, i_frequency2, 0
; For testing envelopes with a DC signal (shows only the envelope).
; a_signal = .25

; As with most software instruments that are modeled on an impulse exciting a 
; resonator, there should be two envelopes. The "physical" envelope must have a 
; fixed decay ending at zero.
i_declick_minimum = .003
i_attack = .001 / i_frequency + i_declick_minimum
i_exponent = 7
a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
; The de-clicking envelope must have attack and release segments that damp 
; artifacts in the signal. The duration of these segments depends on 
; the behavior of the instrument, and may vary as a function of frequency.
i_declick_attack = i_attack
i_declick_release = i_declick_minimum * 2
; The end of the note must be extended _past_ the end of the release segment.
xtratim 1
a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
; The envelope of the instrument is the product of the physical envelope times 
; the declicking envelope. 
a_envelope = a_physical_envelope * a_declicking_envelope
; That envelope is then low-pass filtered to remove most discontinuities.
a_filtered_envelope tonex a_envelope, 40, 4
a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001

a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_Harpsichord_level chnexport "gk_Harpsichord_level", 3
gk_Harpsichord_pick chnexport "gk_Harpsichord_pick", 3
gk_Harpsichord_reflection chnexport "gk_Harpsichord_reflection", 3
gk_Harpsichord_pluck chnexport "gk_Harpsichord_pluck", 3
gk_Harpsichord_midi_dynamic_range chnexport "gk_Harpsichord_midi_dynamic_range", 3
gk_Harpsichord_space_left_to_right chnexport "gk_Harpsichord_space_left_to_right", 3

gk_Harpsichord_level init 0
gk_Harpsichord_pick init .075
gk_Harpsichord_reflection init .5
gk_Harpsichord_pluck init .75
gk_Harpsichord_midi_dynamic_range init 20
gk_Harpsichord_space_left_to_right init .5

gi_Harpsichord_harptable ftgen 0, 0, 65537, 7, -1, 1024, 1, 1024, -1

instr 1000
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_physical_decay = 40
if p3 == -1 then
i_duration = i_physical_decay
else
i_duration = p3
endif
i_midi_key = p4
i_midi_dynamic_range = i(gk_Harpsichord_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
if p7 == 0 then
k_space_left_to_right = gk_Harpsichord_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 66
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Harpsichord_level)
iHz = cpsmidinn(i_midi_key)
kHz = k(iHz)
a_physical_envelope transeg 1.0, i_physical_decay, -25.0, 0.0
apluck pluck i_amplitude * k_gain, kHz, iHz, 0, 1
aharp poscil a_physical_envelope, kHz, gi_Harpsichord_harptable
aharp2 balance apluck, aharp
a_signal	= (apluck + aharp2)
i_attack = .0005
i_sustain = p3
i_release = 0.01
; The end of the note must be extended _past_ the end of the release segment.
xtratim 1
i_declick_attack init .0008
i_declick_release init .01
a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
a_envelope = a_declicking_envelope
a_filtered_envelope tonex a_envelope, 40, 4
a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain 

a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
;printks "Harpsichord      %9.4f   %9.4f\n", 0.5, a_out_left, a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin
/**
 * This is yet another attempt to adapt this beautiful sound for use in 
 * wider contexts. 
 *
 * In its original form this could not work without artifacts because of the 
 * k-rate frequency modulation of the pluck opcode.
 */
gi_Kung2_detune_cents chnexport "gk_Kung2_detune_cents", 3
gi_Kung2_detune_cents init 8
gk_Kung2_level chnexport "gk_Kung2_level", 3
gk_Kung2_level init 0
gk_Kung2_midi_dynamic_range chnexport "gk_Kung2_midi_dynamic_range", 3
gk_Kung2_midi_dynamic_range init 30
gk_Kung2_space_left_to_right chnexport "gk_Kung2_space_left_to_right", 3
gk_Kung2_space_left_to_right init .5
gi_Kung2_sine ftgen 0, 0, 65537, 10, 1
opcode Kung2_, aa, 0
setksmps 1
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_instrument_duration = 999999
if p3 == -1 then
i_duration = i_instrument_duration
else
i_duration = p3
endif
i_midi_key = p4
i_midi_dynamic_range = i(gk_Kung2_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
if p7 ==0 then
k_space_left_to_right = gk_Kung2_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 21 + 51 + 7
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Kung2_level)
ishift = gi_Kung2_detune_cents/12000
ipch = cpsmidinn(i_midi_key)
ioct = octmidinn(i_midi_key)
i_vibrato_frequency = (i_midi_key / 127) * 2
kvib poscil3 1/120, i_vibrato_frequency, gi_Kung2_sine
ag pluck 1, cpsoct(ioct+kvib), 1000, gi_Kung2_sine, 1
agleft pluck 1, cpsoct(ioct+ishift), 1000, gi_Kung2_sine, 1
agright pluck 1, cpsoct(ioct-ishift), 1000, gi_Kung2_sine, 1
i_physical_decay = 20
; As with most software instruments that are modeled on an impulse exciting a 
; resonator, there should be two envelopes. The "physical" envelope must have a 
; fixed decay ending at zero.
i_declick_minimum = .003
i_attack = .001 / i_frequency + i_declick_minimum
i_exponent = 3
a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
a_declicking_envelope cossegr 0, .006, 1, i_instrument_duration, 1,  .06, 0
a_envelope = a_physical_envelope * a_declicking_envelope
a_filtered_envelope tonex a_envelope, 30, 3
xtratim 3
ag = a_declicking_envelope * ag
agleft = a_declicking_envelope * agleft
agright = a_declicking_envelope * agright
adump delayr 0.3
ad1 deltap3 0.1
ad2 deltap3 0.2
delayw ag
a_out_left = agleft + ad1
a_out_right = agright + ad2
a_filtered_declicking tonex a_declicking_envelope, 30, 4
a_out_left = a_out_left * k_gain * i_amplitude * a_filtered_declicking
a_out_right = a_out_right * k_gain * i_amplitude * a_filtered_declicking 
xout a_out_left, a_out_right
endop

instr Kung2
a_out_left, a_out_right Kung2_
outleta "outleft", a_out_left 
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gi_Kung4_detune_cents chnexport "gk_Kung4_detune_cents", 3
gi_Kung4_detune_cents init 8
gk_Kung4_level chnexport "gk_Kung4_level", 3
gk_Kung4_level init 0
gk_Kung4_midi_dynamic_range chnexport "gk_Kung4_midi_dynamic_range", 3
gk_Kung4_midi_dynamic_range init 30
gk_Kung4_space_left_to_right chnexport "gk_Kung4_space_left_to_right", 3
gk_Kung4_space_left_to_right init .5
gi_Kung4_modulation_ratio_start chnexport "gi_Kung4_modulation_ratio_start", 3
gi_Kung4_modulation_ratio_start init 1.7
gi_Kung4_modulation_ratio_end chnexport "gi_Kung4_modulation_ratio_end", 3
gi_Kung4_modulation_ratio_end init .5

gi_Kung4_sine ftgen 0, 0, 65537, 10, 1
gi_Kung4_cosine ftgen 0, 0, 65537, 11, 1
gi_Kung4_ln ftgen 0, 9, 65537, -12, 20.0  ;unscaled ln(I(x)) from 0 to 20.0
/**
 * This is yet another attempt to adapt this beautiful sound for use in 
 * wider contexts.
 */
instr Kung4
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_instrument_duration = 999999
if p3 == -1 then
i_duration = i_instrument_duration
else
i_duration = p3
endif
;print i_duration
i_midi_key = p4
i_midi_dynamic_range = i(gk_Kung4_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
if p7 ==0 then
k_space_left_to_right = gk_Kung4_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 130 + 8 + 6
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Kung4_level)
ishift = gi_Kung4_detune_cents/12000
ipch = cpsmidinn(i_midi_key)
ioct = octmidinn(i_midi_key)
kvib poscil 1/120, ipch/50, gi_Kung4_sine
; The instrument envelope should observe limits.
if (i_duration > 10) then
i_instrument_attack = 10 / 3
elseif (i_duration < 1) then
i_instrument_attack = 1 / 3
else
i_instrument_attack = i_duration / 3
endif
;print i_instrument_attack
;i_instrument_duration -= (2 * i_instrument_attack)
aadsr linsegr 0, i_instrument_attack, 1.0, i_duration, 1.0, i_instrument_attack, 0 ;ADSR envelope
amodi linseg 0, i_instrument_attack, 5, i_duration, 3, i_instrument_attack, 0 ;ADSR envelope for I
amodr linseg gi_Kung4_modulation_ratio_start, i_duration, gi_Kung4_modulation_ratio_end ;r moves from p6->p7 in p3 sec.
a1 = amodi*(amodr-1/amodr)/2
a1ndx = abs(a1*2/20) ;a1*2 is normalized from 0-1.
a2 = amodi*(amodr+1/amodr)/2
a3 tablei a1ndx, gi_Kung4_ln, 1 ;lookup tbl in f3, normal index
ao1 poscil a1, ipch, gi_Kung4_cosine ;cosine
a4 = exp(-0.5*a3+ao1)
ao2 poscil a2*ipch, ipch, gi_Kung4_cosine ;cosine
a_out_left poscil 1000*aadsr*a4, ao2+cpsoct(ioct+ishift), gi_Kung4_sine ;fnl outleft
a_out_right poscil 1000*aadsr*a4, ao2+cpsoct(ioct-ishift), gi_Kung4_sine ;fnl outright
i_declick_minimum = .003
i_attack = .001 / i_frequency + i_declick_minimum
i_exponent = 7
a_physical_envelope = aadsr ;  transeg 0,   i_attack, i_exponent,  1,   i_duration, -i_exponent,  0
; The de-clicking envelope must have attack and release segments that damp 
; artifacts in the signal. The duration of these segments depends on 
; the behavior of the instrument, and may vary as a function of frequency.
i_declick_attack = i_attack
i_declick_release = i_declick_minimum * 2
; The end of the note must be extended _past_ the end of the release segment.
xtratim 5
;print i_declick_attack
;print i_declick_release
;print i_duration
a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
; The envelope of the instrument is the product of the physical envelope times 
; the declicking envelope. 
a_envelope = a_physical_envelope * a_declicking_envelope
; That envelope is then low-pass filtered to remove most discontinuities.
a_filtered_envelope tonex a_envelope, 40, 4
a_out_left = a_out_left * i_amplitude * a_filtered_envelope * k_gain 
a_out_right = a_out_right * i_amplitude * a_filtered_envelope * k_gain 

outleta "outleft", a_out_left 
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin
gk_Plucked_midi_dynamic_range chnexport "gk_Plucked_midi_dynamic_range", 3
gk_Plucked_midi_dynamic_range init 30
gk_Plucked_space_left_to_right chnexport "gk_Plucked_space_left_to_right", 3
gk_Plucked_space_left_to_right init .5
gk_Plucked_level chnexport "gk_Plucked_level", 3
gk_Plucked_level init 0

gi_Plucked_sine ftgen 0, 0, 65537, 10, 1

instr Plucked
; Author: Michael Gogins
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_physical_decay = 20
if p3 == -1 then
i_duration = i_physical_decay
else
i_duration = p3
endif
i_midi_key = p4
i_midi_dynamic_range = i(gk_Plucked_midi_dynamic_range)
i_midi_velocity = p5 ;* i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
i_midi_velocity ampmidid i_midi_velocity, i_midi_dynamic_range
k_space_front_to_back = p6
if p7 == 0 then
k_space_left_to_right = gk_Plucked_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_detune_cents = 1.5
i_detune = i_detune_cents / 100
i_frequency1 = cpsmidinn(i_midi_key - i_detune)
i_frequency2 = cpsmidinn(i_midi_key)
i_frequency3 = cpsmidinn(i_midi_key + i_detune)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_overall_amps = 26
i_normalization = ampdb(-(i_overall_amps)) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_Plucked_level)
asignal1 wgpluck2 0.1, 1.0, i_frequency1, 0.25, 0.222
asignal2 wgpluck2 0.1, 1.0, i_frequency2, 0.20, 0.223
asignal3 wgpluck2 0.1, 1.0, i_frequency3, 0.23, 0.225
a_signal = (asignal1 + asignal2 + asignal3)
; As with most instruments that are based upon an impulse delivered to a 
; resonator, there are two envelopes, one for the physical decay with a 
; fixed release ending at zero, and one with a release segment to remove 
; clicks from the attack and release.
;
; As with most software instruments that are modeled on an impulse exciting a 
; resonator, there should be two envelopes. The "physical" envelope must have a 
; fixed decay ending at zero.
i_declick_minimum = .001
i_attack = .001 / i_frequency2 + i_declick_minimum
i_exponent = 7
a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
; The de-clicking envelope must have attack and release segments that damp 
; artifacts in the signal. The duration of these segments depends on 
; the behavior of the instrument, and may vary as a function of frequency.
i_declick_attack = i_attack
i_declick_release = i_declick_minimum * 2
; The end of the note must be extended _past_ the end of the release segment.
xtratim 1
a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
; The envelope of the instrument is the product of the physical envelope times 
; the declicking envelope. 
a_envelope = a_physical_envelope * a_declicking_envelope
; That envelope is then low-pass filtered to remove most discontinuities.
a_filtered_envelope tonex a_envelope, 40, 4
a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.05

a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin
gi_SeidelHarmOsc_tabsz init 2^16

gi_SeidelHarmOsc_Sin     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0
gi_SeidelHarmOsc_Tri     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0,  3,0.333,180,  5,0.2,0,  7,0.143,180, 9,0.111,0, 11,0.091,180, 13,0.077,0, 15,0.067,180, 17,0.059,0, 19,0.053,180, 21,0.048,0, 23,0.043,180, 25,0.04,0, 27,0.037,180, 29,0.034,0, 31,0.032,180
gi_SeidelHarmOsc_Saw     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 7, 0, gi_SeidelHarmOsc_tabsz/2, 1, 0, -1, gi_SeidelHarmOsc_tabsz/2, 0
gi_SeidelHarmOsc_Square  ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 7, 1, gi_SeidelHarmOsc_tabsz/2, 1, 0, -1, gi_SeidelHarmOsc_tabsz/2, -1
gi_SeidelHarmOsc_Prime   ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0,  2,0.5,0,  3,0.3333,0,  5,0.2,0,   7,0.143,0,  11,0.0909,0,  13,0.077,0,   17,0.0588,0,  19,0.0526,0, 23,0.0435,0, 27,0.037,0, 31,0.032,180
gi_SeidelHarmOsc_Fib     ftgen 0, 0, gi_SeidelHarmOsc_tabsz, 9, 1,1,0,  2,0.5,0,  3,0.3333,0,  5,0.2,0,   8,0.125,0,  13,0.0769,0,  21,0.0476,0,  34,0.0294,0 ;,  55,0.0182,0,  89,0.0112,0, 144,0.0069,0

gi_SeidelHarmOsc_NumTables = 5
gi_SeidelHarmOsc_List ftgen 1000, 0, gi_SeidelHarmOsc_NumTables, -2, gi_SeidelHarmOsc_Tri, gi_SeidelHarmOsc_Saw, gi_SeidelHarmOsc_Square, gi_SeidelHarmOsc_Prime, gi_SeidelHarmOsc_Fib, gi_SeidelHarmOsc_Sin
gi_SeidelHarmOsc_Morf ftgen 1001, 0, gi_SeidelHarmOsc_tabsz, 10, 1

gi_SeidelHarmOsc_lforabsz init 2^13
gi_SeidelHarmOsc_LfoTri ftgen 0, 0, gi_SeidelHarmOsc_lforabsz, 7, 0, gi_SeidelHarmOsc_lforabsz/4, 1, gi_SeidelHarmOsc_lforabsz/2, -1, gi_SeidelHarmOsc_lforabsz/4, 0

gk_SeidelHarmOsc_level chnexport "gk_SeidelHarmOsc_level", 3 ;  0
gi_SeidelHarmOsc_attack chnexport "gi_SeidelHarmOsc_attack", 3 ;  0.003
gi_SeidelHarmOsc_petals chnexport "gi_SeidelHarmOsc_petals", 3 ;  2.99
gi_SeidelHarmOsc_release chnexport "gi_SeidelHarmOsc_release", 3 ;  0.01
gk_SeidelHarmOsc_midi_dynamic_range chnexport "gk_SeidelHarmOsc_midi_dynamic_range", 3 ;  20

gk_SeidelHarmOsc_level init 0
gi_SeidelHarmOsc_attack init 0.003
gi_SeidelHarmOsc_petals init 2.99
gi_SeidelHarmOsc_release init 0.01
gk_SeidelHarmOsc_midi_dynamic_range init 20

gk_SeidelHarmOsc_P1 chnexport "gk_SeidelHarmOsc_P1", 3
gk_SeidelHarmOsc_IN1CON chnexport "gk_SeidelHarmOsc_IN1CON", 3
gk_SeidelHarmOsc_IN1C1 chnexport "gk_SeidelHarmOsc_IN1C1", 3

gk_SeidelHarmOsc_P1 init 0.1
gk_SeidelHarmOsc_IN1CON init 0.1
gk_SeidelHarmOsc_IN1C1 init 1

gk_SeidelHarmOsc_P2 chnexport "gk_SeidelHarmOsc_P2", 3
gk_SeidelHarmOsc_IN2C1 chnexport "gk_SeidelHarmOsc_IN2C1", 3
gk_SeidelHarmOsc_IN2CON chnexport "gk_SeidelHarmOsc_IN2CON", 3

gk_SeidelHarmOsc_P2 init 0.1
gk_SeidelHarmOsc_IN2C1 init 1
gk_SeidelHarmOsc_IN2CON init 0.1

gk_SeidelHarmOsc_P3 chnexport "gk_SeidelHarmOsc_P3", 3
gk_SeidelHarmOsc_IN3C1 chnexport "gk_SeidelHarmOsc_IN3C1", 3
gk_SeidelHarmOsc_IN3CON chnexport "gk_SeidelHarmOsc_IN3CON", 3

gk_SeidelHarmOsc_P3 init 0.1
gk_SeidelHarmOsc_IN3C1 init 1
gk_SeidelHarmOsc_IN3CON init 0.1

gk_SeidelHarmOsc_P4 chnexport "gk_SeidelHarmOsc_P4", 3
gk_SeidelHarmOsc_IN4C1 chnexport "gk_SeidelHarmOsc_IN4C1", 3
gk_SeidelHarmOsc_IN4CON chnexport "gk_SeidelHarmOsc_IN4CON", 3

gk_SeidelHarmOsc_P4 init 0.1
gk_SeidelHarmOsc_IN4C1 init 1
gk_SeidelHarmOsc_IN4CON init 0.1

gi_SeidelHarmOsc_pitch_bend_table ftgen 0, 0, 1024, -7, 1, 1024, 1 
gi_SeidelHarmOsc_sine ftgen 0, 0, 65537, 10, 1

instr SeidelHarmOsc
i_instrument = p1
i_time = p2
i_sustain = p3
xtratim gi_SeidelHarmOsc_attack + gi_SeidelHarmOsc_release
i_midi_key = p4
i_midi_dynamic_range = i(gk_SeidelHarmOsc_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
// Spatial location is specified in Ambisonic coordinates.
k_space_front_to_back = p6
// AKA stereo pan.
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
// Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 87
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_SeidelHarmOsc_level)
; prints("p1=%f, p2=%f, p3=%f, p4=%f\n", p1, p2, p3, p4)
;;;kfreq chnget sprintf("FREQ%d", p4)
kfreq init i_frequency

kin1con init 0
kin2con init 0
kin3con init 0
kin4con init 0

koff  init 0.001
koff1 init 0.001
koff2 init 2 * 0.001
koff3 init 3 * 0.001
koff4 init 5 * 0.001
koffa = scale2(gk_SeidelHarmOsc_P1, 0.001, 0.1, -10, 10)
if (gk_SeidelHarmOsc_IN1CON == 1) then
koffb = scale2(gk_SeidelHarmOsc_IN1C1, 0.001, 0.1, 0, 10)
koff = koffa + koffb
else
koff = koffa
endif
koff1 = koff
koff2 = 2 * koff
koff3 = 3 * koff
koff4 = 5 * koff

itbl = gi_SeidelHarmOsc_Morf
kndx init 0
kndxa = scale2(gk_SeidelHarmOsc_P2, 0, gi_SeidelHarmOsc_NumTables-1.01, -10, 10)
if (gk_SeidelHarmOsc_IN2CON == 1) then
kndxb = scale2(gk_SeidelHarmOsc_IN2C1, 0, gi_SeidelHarmOsc_NumTables-1.01, 0, 10)
kndx = kndxa + kndxb
else
kndx = kndxa
endif
ftmorf kndx, gi_SeidelHarmOsc_List, gi_SeidelHarmOsc_Morf

kamp init 0.8/9

; a1 oscil3 kamp, kfreq, itbl
a2 oscil3 kamp, kfreq+koff1, itbl
a3 oscil3 kamp, kfreq+koff2, itbl
a4 oscil3 kamp, kfreq+koff3, itbl
a5 oscil3 kamp, kfreq+koff4, itbl
a6 oscil3 kamp, kfreq-koff1, itbl
a7 oscil3 kamp, kfreq-koff2, itbl
a8 oscil3 kamp, kfreq-koff3, itbl
a9 oscil3 kamp, kfreq-koff4, itbl

kdst init 0
kdsta = scale2(gk_SeidelHarmOsc_P3, 0, 10, -10, 10)
if (gk_SeidelHarmOsc_IN3CON == 1) then
kdstb = scale2(gk_SeidelHarmOsc_IN3C1, 0, 10, 0, 10)
kdst = kdsta + kdstb
else
kdst = kdsta
endif

aL = a2+a4+a6+a8
aR = a3+a5+a7+a9
aoutL = aL + distort1(aL, kdst, 0.1, 0, 0)
aoutR = aR + distort1(aR, kdst, 0.1, 0, 0)

kpana = scale2(gk_SeidelHarmOsc_P4, 0, 7, -10, 10)
if (gk_SeidelHarmOsc_IN4CON == 1) then
kpanb = scale2(gk_SeidelHarmOsc_IN4C1, 0, 5, 0, 10)
kpan = kpana + kpanb
else
kpan = kpana
endif
if (kpan == 0) then
kext = 0
else
kext = 0.1
endif
klfoL oscili 0.49, kpan-kext, gi_SeidelHarmOsc_LfoTri, 90
klfoR oscili 0.49, kpan+kext, gi_SeidelHarmOsc_LfoTri, 270
klfoL += 0.5
klfoR += 0.5
aoutL1, aoutR1 pan2 aoutL, klfoL
aoutL2, aoutR2 pan2 aoutR, klfoR
aoutL = aoutL1+aoutL2
aoutR = aoutR1+aoutR2

aenv madsr 0.07,0,1,0.7
a_out_left = aoutL * aenv * k_gain * i_amplitude
a_out_right = aoutR * aenv * k_gain * i_amplitude
;;; outs aoutL*aenv, aoutR*aenv
;;; a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
;printks "WGPluck      %9.4f   %9.4f\n", 0.5, a_out_left, a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_TubularBell_level chnexport "gk_TubularBell_level", 3
gi_TubularBell_crossfade chnexport "gi_TubularBell_crossfade", 3
gi_TubularBell_vibrato_depth chnexport "gi_TubularBell_vibrato_depth", 3
gi_TubularBell_vibrato_rate chnexport "gi_TubularBell_vibrato_rate", 3

gk_TubularBell_level init 0
gi_TubularBell_crossfade init 2
gi_TubularBell_vibrato_depth init .1
gi_TubularBell_vibrato_rate init 5
gk_TubularBell_midi_dynamic_range chnexport "gk_TubularBell_midi_dynamic_range", 3 ; 127
gk_TubularBell_midi_dynamic_range init 30

gk_TubularBell_space_left_to_right chnexport "gk_TubularBell_space_left_to_right", 3
gk_TubularBell_space_left_to_right init .5

gi_TubularBell_isine ftgen 0, 0, 65537, 10, 1
gi_TubularBell_icosine ftgen 0, 0, 65537, 11, 1
gi_TubularBell_icook3 ftgen 0, 0, 65537, 10, 1, .4, 0.2, 0.1, 0.1, .05

instr TubularBell
; Authors: Perry Cook, John ffitch, Michael Gogins
i_instrument = p1
i_time = p2
i_physical_decay = 5
if p3 == -1 then
i_duration = i_physical_decay
else
i_duration = p3
endif
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
if p7 ==0 then
k_space_left_to_right = gk_TubularBell_space_left_to_right
else
k_space_left_to_right = p7
endif
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_overall_amps = 12.5
i_normalization = ampdb(-i_overall_amps) / 2
i_midi_dynamic_range = i(gk_TubularBell_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_TubularBell_level)
iattack = 0.002
isustain = p3
irelease = 0.05
iindex = 1
ifn1 = gi_TubularBell_isine
ifn2 = gi_TubularBell_icook3
ifn3 = gi_TubularBell_isine
ifn4 = gi_TubularBell_isine
ivibefn = gi_TubularBell_icosine
a_signal fmbell 1, i_frequency, iindex, gi_TubularBell_crossfade, gi_TubularBell_vibrato_depth, gi_TubularBell_vibrato_rate, ifn1, ifn2, ifn3, ifn4, ivibefn
i_attack = .002
i_sustain = i_duration
i_release = 0.01
; As with most software instruments that are modeled on an impulse exciting a 
; resonator, there should be two envelopes. The "physical" envelope must have a 
; fixed decay ending at zero.
i_declick_minimum = .001
i_attack = .001 / i_frequency + i_declick_minimum
i_exponent = 7
a_physical_envelope transeg 0,   i_attack, i_exponent,  1,   i_physical_decay, -i_exponent,  0
; The de-clicking envelope must have attack and release segments that damp 
; artifacts in the signal. The duration of these segments depends on 
; the behavior of the instrument, and may vary as a function of frequency.
i_declick_attack = .004
i_declick_release = i_declick_minimum * 2
; The end of the note must be extended _past_ the end of the release segment.
xtratim 1
a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
; The envelope of the instrument is the product of the physical envelope times 
; the declicking envelope. 
a_envelope = a_physical_envelope * a_declicking_envelope
; That envelope is then low-pass filtered to remove most discontinuities.
a_filtered_envelope tonex a_envelope, 120, 4
a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001

a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gk_YiString_midi_dynamic_range chnexport "gk_YiString_midi_dynamic_range", 3 ;  127
gk_YiString_level chnexport "gk_YiString_level", 3 ;  0
gk_YiString_reverb_send chnexport "gk_YiString_reverb_send", 3 ;  .5
gk_YiString_chorus_send chnexport "gk_YiString_chorus_send", 3 ;  .5
gi_YiString_overlap chnexport "gi_YiString_overlap", 3 ;  .1

gk_YiString_midi_dynamic_range init 20
gk_YiString_level init 0
gk_YiString_reverb_send init .5
gk_YiString_chorus_send init .5
gi_YiString_overlap init .1

gk_YiString_space_left_to_right chnexport "gk_YiString_space_left_to_right", 3
gk_YiString_space_left_to_right init .5

instr YiString
//////////////////////////////////////////////
// Original by Steven Yi.
// Adapted by Michael Gogins.
//////////////////////////////////////////////
i_instrument = p1
i_time = p2
; Make indefinite notes last no longer than the physical decay.
i_physical_duration = 20000
if p3 == -1 then
i_duration = i_physical_duration
else
i_duration = p3
endif
i_midi_key = p4
i_midi_dynamic_range = i(gk_YiString_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.5 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_frequency = cpsmidinn(i_midi_key)
; Adjust the following value until "overall amps" at the end of performance is about -6 dB.
i_level_correction = 62.25
i_normalization = ampdb(-i_level_correction) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
k_gain = ampdb(gk_YiString_level)
iattack = gi_YiString_overlap
isustain = i_duration
idecay = gi_YiString_overlap
xtratim 1
a_physical_envelope transeg 0.0, iattack / 2.0, 1.5, i_amplitude / 2.0, iattack / 2.0, -1.5, i_amplitude, isustain, 0.0, i_amplitude, idecay / 2.0, 1.5, i_amplitude / 2.0, idecay / 2.0, -1.5, 0
;ampenv = madsr:a(1, 0.1, 0.95, 0.5)
a_signal = vco2(1, i_frequency)
a_signal = moogladder(a_signal, 6000, 0.1)

; The de-clicking envelope must have attack and release segments that damp 
; artifacts in the signal. The duration of these segments depends on 
; the behavior of the instrument, and may vary as a function of frequency.
i_declick_attack = iattack
i_declick_release = i_declick_attack * 2
; The end of the note must be extended _past_ the end of the release segment.
xtratim 1
a_declicking_envelope cossegr 0, i_declick_attack, 1,  i_duration, 1,  i_declick_release, 0
; The envelope of the instrument is the product of the physical envelope times 
; the declicking envelope. 
a_envelope = a_physical_envelope * a_declicking_envelope
; That envelope is then low-pass filtered to remove most discontinuities.
a_filtered_envelope tonex a_envelope, 40, 4
a_signal = a_signal * i_amplitude * a_filtered_envelope * k_gain *.001

a_signal_reverb = a_signal * gk_YiString_reverb_send
a_signal_chorus = a_signal * gk_YiString_chorus_send
a_out_left, a_out_right pan2 a_signal_reverb, p7
outleta "outleft", a_out_left
outleta "outright",  a_out_right
a_out_left, a_out_right pan2 a_signal_chorus, p7
outleta "chorusleft", a_out_left 
outleta "chorusright", a_out_right 
;printks "YiString         %9.4f  %9.4f\n", 0.5, a_out_left, a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin
gk_Xing_level chnexport "gk_Xing_level", 3

gk_Xing_level init 0

gi_Xing_isine ftgen 0, 0, 65537, 10, 1

instr Xing
; Author: Andrew Horner
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_overall_amps = 75
i_normalization = ampdb(-i_overall_amps) / 2
i_amplitude = ampdb(i_midi_velocity) * i_normalization
i_frequency = cpsmidinn(i_midi_key)
k_gain = ampdb(gk_Xing_level)
iinstrument = p1
istarttime = p2
ioctave = p4
idur = p3
kfreq = k(i_frequency)
iamp = 1
inorm = 32310
aamp1 linseg 0,.001,5200,.001,800,.001,3000,.0025,1100,.002,2800,.0015,1500,.001,2100,.011,1600,.03,1400,.95,700,1,320,1,180,1,90,1,40,1,20,1,12,1,6,1,3,1,0,1,0
adevamp1 linseg 0, .05, .3, idur - .05, 0
adev1 poscil adevamp1, 6.7, gi_Xing_isine, .8
amp1 = aamp1 * (1 + adev1)
aamp2 linseg 0,.0009,22000,.0005,7300,.0009,11000,.0004,5500,.0006,15000,.0004,5500,.0008,2200,.055,7300,.02,8500,.38,5000,.5,300,.5,73,.5,5.,5,0,1,1
adevamp2 linseg 0,.12,.5,idur-.12,0
adev2 poscil adevamp2, 10.5, gi_Xing_isine, 0
amp2 = aamp2 * (1 + adev2)
aamp3 linseg 0,.001,3000,.001,1000,.0017,12000,.0013,3700,.001,12500,.0018,3000,.0012,1200,.001,1400,.0017,6000,.0023,200,.001,3000,.001,1200,.0015,8000,.001,1800,.0015,6000,.08,1200,.2,200,.2,40,.2,10,.4,0,1,0
adevamp3 linseg 0, .02, .8, idur - .02, 0
adev3 poscil adevamp3, 70, gi_Xing_isine ,0
amp3 = aamp3 * (1 + adev3)
awt1 poscil amp1, i_frequency, gi_Xing_isine
awt2 poscil amp2, 2.7 * i_frequency, gi_Xing_isine
awt3 poscil amp3, 4.95 * i_frequency, gi_Xing_isine
asig = awt1 + awt2 + awt3
arel linenr 1,0, idur, .06
a_signal = asig * arel * (iamp / inorm)
i_attack = .002
i_sustain = p3
i_release = 0.01
xtratim i_attack + i_release
a_declicking linsegr 0, i_attack, 1, i_sustain, 1, i_release, 0
a_signal = a_signal * i_amplitude * a_declicking * k_gain

a_out_left, a_out_right pan2 a_signal, k_space_left_to_right
outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

/**
 * Uses the Cardinal VST3 plugin version of VCV Rack.
 */
gk_VcvNote_midi_dynamic_range chnexport "gk_VcvNote_midi_dynamic_range", 3 ;  20
gk_VcvNote_midi_dynamic_range init 20

instr VcvNote
if p3 == -1 then
  p3 = 1000000
endif
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_dynamic_range = i(gk_VcvNote_midi_dynamic_range)
i_midi_velocity = p5 * i_midi_dynamic_range / 127 + (63.6 - i_midi_dynamic_range / 2)
k_space_front_to_back = p6
k_space_left_to_right = p7
k_space_bottom_to_top = p8
i_phase = p9
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
i_homogeneity = p11
instances active p1
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
i_pitch_correction = 44100 / sr
; prints "Pitch factor:   %9.4f\n", i_pitch_correction
i_result vst3note gi_Cardinal, 0, i_midi_key, i_midi_velocity, i_duration
endin

gk_VcvOut_level chnexport "gk_VcvOut_level", 3 ;  0
gi_VcvOut_print chnexport "gi_VcvOut_print", 3 ;  1
gk_VcvOut_front_to_back chnexport "gk_VcvOut_front_to_back", 3 ;  0
gk_VcvOut_left_to_right chnexport "gk_VcvOut_left_to_right", 3 ;  0.5
gk_VcvOut_bottom_to_top chnexport "gk_VcvOut_bottom_to_top", 3 ;  0

gk_VcvOut_level init 0
gi_VcvOut_print init 1
gk_VcvOut_front_to_back init 0
gk_VcvOut_left_to_right init 0.5
gk_VcvOut_bottom_to_top init 0

instr VcvOut
k_gain = ampdb(gk_VcvOut_level)
i_overall_amps = 87
i_normalization = ampdb(-i_overall_amps) * 2
i_amplitude = ampdb(80) * i_normalization
i_instrument = p1
i_time = p2
i_duration = p3
i_midi_key = p4
i_midi_velocity = p5
aoutleft init 0
aoutright init 0
ainleft init 0
ainright init 0
aoutleft, aoutright vst3audio gi_Cardinal, ainleft, ainright
a_signal = aoutleft + aoutright
a_signal *= k_gain
a_signal *= (i_amplitude)
a_out_left, a_out_right pan2 a_signal, gk_VcvOut_left_to_right

outleta "outleft", a_out_left
outleta "outright", a_out_right
prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
endin

gi_Valhalla vst3init "/Library/Audio/Plug-Ins/VST3/ValhallaShimmer.vst3", "ValhallaShimmer", 1
// Note: Doesn't actually print parameters.
vst3info gi_Valhalla
    
  // id 48
  gk_Shimmer_wetDry chnexport "gk_Shimmer_wetDry", 3 ; 0
  gk_Shimmer_wetDry init .5
  // id 49
  gk_Shimmer_shift chnexport "gk_Shimmer_shift", 3 ; 0
  gk_Shimmer_shift init 0
  // id 50
  gk_Shimmer_feedback chnexport "gk_Shimmer_feedback", 3 ; 0
  gk_Shimmer_feedback init .5
  // id 51
  gk_Shimmer_diffusion chnexport "gk_Shimmer_diffusion", 3 ; 0
  gk_Shimmer_diffusion init .885
  // id 52
  gk_Shimmer_size chnexport "gk_Shimmer_size", 3 ; 0
  gk_Shimmer_size init .5
  // id 53
  gk_Shimmer_lowcut chnexport "gk_Shimmer_lowcut", 3 ; 0
  gk_Shimmer_lowcut init 0
  // id 54
  gk_Shimmer_highcut chnexport "gk_Shimmer_highcut", 3 ; 0
  gk_Shimmer_highcut init 0
  // id 55
  gk_Shimmer_modRate chnexport "gk_Shimmer_modRate", 3 ; 0
  gk_Shimmer_modRate init .38
  // id 56
  gk_Shimmer_modDepth chnexport "gk_Shimmer_modDepth", 3 ; 0
  gk_Shimmer_modDepth init .04
  // id 57
  gk_Shimmer_reverbMode chnexport "gk_Shimmer_reverbMode", 3 ; 0
  // "Big stereo"
  gk_Shimmer_reverbMode init .275
  // id 1567
  gk_Shimmer_shiftMode chnexport "gk_Shimmer_shiftMode", 3 ; 0
  gk_Shimmer_shiftMode init 0
  // id 1568
  gk_Shimmer_colorMode chnexport "gk_Shimmer_colorMode", 3 ; 0
  gk_Shimmer_colorMode init 0
  // id 12
  gk_Shimmer_bypass chnexport "gk_Shimmer_bypass", 3 ; 0
  gk_Shimmer_bypass init 0
  // id 1886548852
  gk_Shimmer_program chnexport "gk_Shimmer_program", 3 ; 0
  gk_Shimmer_program init 2

  instr Shimmer
  ainleft init 0
  ainright init 0
  aoutleft init 0
  aoutright init 0
  ainleft inleta "inleft"
  ainright inleta "inright"
  vst3paramset gi_Valhalla, 1886548852, gk_Shimmer_program
  vst3paramset gi_Valhalla, 48, gk_Shimmer_wetDry
  vst3paramset gi_Valhalla, 50, gk_Shimmer_feedback
  vst3paramset gi_Valhalla, 51, gk_Shimmer_diffusion
  vst3paramset gi_Valhalla, 52, gk_Shimmer_size
  vst3paramset gi_Valhalla, 55, gk_Shimmer_modRate
  vst3paramset gi_Valhalla, 56, gk_Shimmer_modDepth
  vst3paramset gi_Valhalla, 57, gk_Shimmer_reverbMode
  aoutleft, aoutright vst3audio gi_Valhalla, ainleft, ainright
  outleta "outleft", aoutleft
  outleta "outright", aoutright
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  endin
  
  gk_MasterOutput_level chnexport "gk_MasterOutput_level", 3 ; 0
  gS_MasterOutput_filename chnexport "gS_MasterOutput_filename", 3 ; ""
  
  gk_MasterOutput_level init 0
  gS_MasterOutput_filename init ""

  chn_k "gk_MasterOutput_output_level_left", 3
  chn_k "gk_MasterOutput_output_level_right", 3

  instr MasterOutput
  aleft inleta "inleft"
  aright inleta "inright"
  k_gain = ampdb(gk_MasterOutput_level)
  printks2 "Master gain: %f\n", k_gain
  iamp init 1
  aleft butterlp aleft, 18000
  aright butterlp aright, 18000
  a_out_left = aleft * k_gain
  a_out_right = aright * k_gain
  outs a_out_left, a_out_right
  ; We want something that will play on my phone.
  i_amplitude_adjustment = ampdbfs(-3) / 32767
  i_filename_length strlen gS_MasterOutput_filename
  if i_filename_length > 0 then
  prints sprintf("Output filename: %s\n", gS_MasterOutput_filename)
  fout gS_MasterOutput_filename, 18, a_out_left * i_amplitude_adjustment, a_out_right * i_amplitude_adjustment
  endif
  prints "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d\n", nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1)
  gk_MasterOutput_output_level_left = dbfsamp(rms(a_out_left))
  gk_MasterOutput_output_level_right = dbfsamp(rms(a_out_right))
  chnset gk_MasterOutput_output_level_left, "gk_MasterOutput_output_level_left"
  chnset gk_MasterOutput_output_level_right, "gk_MasterOutput_output_level_right"
  ;;; printks "%-24s i %9.4f t %9.4f d %9.4f k %9.4f v %9.4f p %9.4f #%3d l%9.4f r%9.4f\n", 1, nstrstr(p1), p1, p2, p3, p4, p5, p7, active(p1), gk_MasterOutput_output_level_left, gk_MasterOutput_output_level_right
  endin
  
  </CsInstruments>
  <CsScore>
  f 0 [ 7 * 60 + 45]
  </CsScore>
</CsoundSynthesizer>

  </textarea>

    <!-- endregion -->

    <!-- #region Log -->

    <div id='console_view' class="w3-text-sand"
        style="position:absolute;top:60px;z-index:4;width:100vw;height:90vh;background:transparent;margin-left:53px;opacity:60%">
    </div>

    <!-- endregion -->

    <!-- #region Main Menu and Infrastructure -->

    <!-- The menu bar has to stack on top of all layers in order for the 
       dat.gui controls to work. -->

    <div class="w3-bar " id="main_menu" style="position:fixed;background:transparent;z-index:100;">
        <ul class="menu">
            <li id="menu_item_play" title="Play piece on system audio output" class="w3-btn w3-hover-text-light-green">
                Play</li>
            <li id="menu_item_render" title="Render piece to soundfile" class="w3-btn w3-hover-text-light-green">Render
            </li>
            <li id="menu_item_stop" title="Stop performance" class="w3-btn w3-hover-text-light-green">Stop</li>
            <li id="menu_item_fullscreen" class="w3-btn w3-hover-text-light-green">Fullscreen</li>
            <!-- <li id="menu_item_strudel" class="w3-btn w3-hover-text-light-green">Strudel</li> -->
            <li id="menu_item_score" title="Show/hide piano roll score" class="w3-btn w3-hover-text-light-green">Score
            </li>
            <li id="menu_item_console" title="Show/hide message console" class="w3-btn w3-hover-text-light-green">Log
            </li>
            <li id="menu_item_about" title="Show/hide information about this piece"
                class="w3-btn w3-hover-text-light-green">About</li>
            <li id="mini_console" class="w3-btn w3-text-green w3-hover-text-light-green"></li>
            <li id="vu_meter_left" class="w3-btn w3-hover-text-light-green"></li>
            <li id="vu_meter_right" class="w3-btn w3-hover-text-light-green"></li>
            <li id="menu_item_dat_gui"
                title="Show/hide performance controls; 'Save' copies all control parameters to system clipboard"
                class="w3-btn w3-left-align w3-hover-text-light-green w3-right"></li>
        </ul>
    </div>

    <script>

        // The title of the piece is always the basename of the document.
        document.title = document.location.pathname.replace("/", "").replace(".html", "");

        if ('caches' in window) {
            caches.keys().then(function (names) {
                for (let name of names)
                    caches.delete(name);
                console.log(`deleted ${name} from caches.`);
            });
        }

        function non_csound(csound_) {
            if (typeof csound_ === 'undefined') {
                console.warn("csound is undefined.");
                console.trace();
                return true;
            }
            if (csound_ === null) {
                console.warn("csound is null.");
                console.trace();
                return true;
            }
            return false;
        }

        /**
         * Replaces the order of instruments in a CsoundAC Score with a new order.
         * Instrument numbers are re-ordered as if they are integers. The 
         * new_order parameter is a map, e.g. `{1:5, 3:1, 4:17}`. The map need not 
         * be complete.
         */
        function arrange_silencio(score, new_order_) {
            if (non_csound(csound)) {
                return;
            }
            csound.message("arrange: reassigning instrument numbers...\n")
            let new_order = new Map(Object.entries(new_order_));
            // Renumber the insnos in the Score. Fractional parts of old insnos are 
            // preserved.
            for (i = 0, n = score.data.length; i < n; ++i) {
                let event_ = score.data[i];
                let current_insno = event_.channel;
                let current_insno_integer = Math.floor(current_insno);
                let string_key = current_insno_integer.toString();
                if (new_order.has(string_key)) {
                    let new_insno_integer = new_order.get(string_key);
                    let new_insno_fraction = current_insno - current_insno_integer;
                    let new_insno = new_insno_integer + new_insno_fraction;
                    csound.message("renumbered: " + event_.toIStatement());
                    event_.channel = new_insno;
                    score.data[i] = event_;
                    csound.message("        to: " + score.data[i].toIStatement());
                }
            }
            csound.message("arrange: finished reassigning instrument numbers.\n")
        }

        /**
         * Replaces the order of instruments in a CsoundAC Score with a new order.
         * Instrument numbers are re-ordered as if they are integers. The 
         * new_order parameter is a map, e.g. `{1:5, 3:1, 4:17}`. The map need not 
         * be complete.
         */
        function arrange(score, new_order_) {
            if (non_csound(csound)) {
                return;
            }
            csound.message("arrange: reassigning instrument numbers...\n")
            let new_order = new Map(Object.entries(new_order_));
            // Renumber the insnos in the Score. Fractional parts of old insnos are 
            // preserved.
            for (i = 0, n = score.size(); i < n; ++i) {
                let event_ = score.get(i);
                let current_insno = event_.getInstrument();
                let current_insno_integer = Math.floor(current_insno);
                let string_key = current_insno_integer.toString();
                if (new_order.has(string_key)) {
                    let new_insno_integer = new_order.get(string_key);
                    let new_insno_fraction = current_insno - current_insno_integer;
                    let new_insno = new_insno_integer + new_insno_fraction;
                    csound.message("renumbered: " + event_.toIStatement());
                    event_.setInstrument(new_insno);
                    score.set(i, event_);
                    csound.message("        to: " + event_.toIStatement());
                }
            }
            csound.message("arrange: finished reassigning instrument numbers.\n")
        }

        function write_file(filepath, data) {
            var fs = require('fs');
            try {
                // Sync, so a bad .csd file doesn't blow up Csound 
                // before the .csd file is written so it can be tested!
                fs.writeFileSync(filepath, data, function (err) {
                    console.error(err);
                });
            } catch (err) {
                console.warn(err);
            }
        }

        /**
         * Sends the values of the parameters to the Csound control channels 
         * with the same names.
         */
        function send_parameters(parameters_, csound_) {
            if (non_csound(csound_) == false) {
                for (const [name, value] of Object.entries(parameters_)) {
                    csound.Message(name + ": " + value + "\n");
                    csound.SetControlChannel(name, parseFloat(value));
                }
            }
        }

        /**
         * Copies all _current_ dat.gui parameters to the system clipboard in 
         * JSON format.
         */
        function copy_parameters() {
            const json_text = JSON.stringify(parameters, null, 4);
            navigator.clipboard.writeText(json_text);
            csound_message_callback("Copied all control parameters to system clipboard.\n")
        }

        var message_callback_buffer = "";
        var console_editor = ace.edit("console_view");
        //console_editor.setTheme("ace/theme/gob");
        console_editor.setReadOnly(true);
        console_editor.setShowPrintMargin(false);
        console_editor.setDisplayIndentGuides(false);
        console_editor.renderer.setOption("showGutter", false);
        console_editor.renderer.setOption("showLineNumbers", true);

        var csound_message_callback = async function (message) {
            if (message === null) {
                return;
            }
            if (csound === null) {
                return;
            }
            if (typeof csound == 'undefined') {
                return;
            }
            let level_left = -100;
            let level_right = -100;
            if (non_csound(csound) == false) {
                score_time = await csound.GetScoreTime();
                level_left = await csound.GetControlChannel("gk_MasterOutput_output_level_left");
                level_right = await csound.GetControlChannel("gk_MasterOutput_output_level_right");
                let delta = score_time;
                // calculate (and subtract) whole days
                let days = Math.floor(delta / 86400);
                delta -= days * 86400;
                // calculate (and subtract) whole hours
                let hours = Math.floor(delta / 3600) % 24;
                delta -= hours * 3600;
                // calculate (and subtract) whole minutes
                let minutes = Math.floor(delta / 60) % 60;
                delta -= minutes * 60;
                // what's left is seconds
                let seconds = delta % 60;  // in theory the modulus is not required
                if (level_left > 0) {
                    $("#vu_meter_left").css("color", "red");
                } else if (level_left > -12) {
                    $("#vu_meter_left").css("color", "orange")
                } else {
                    $("#vu_meter_left").css("color", "lightgreen");
                }
                if (level_right > 0) {
                    $("#vu_meter_right").css("color", "red");
                } else if (level_right > -12) {
                    $("#vu_meter_right").css("color", "orange")
                } else {
                    $("#vu_meter_right").css("color", "lightgreen");
                }
                $("#mini_console").html(sprintf("d:%4d h:%02d m:%02d s:%06.3f", days, hours, minutes, seconds));
                $("#vu_meter_left").html(sprintf("L%+7.1f dBA", level_right));
                $("#vu_meter_right").html(sprintf("R%+7.1f dBA", level_right));
            };
            // Split in case the newline is in the middle of the message but 
            // not at the end?
            message_callback_buffer = message_callback_buffer + message;
            if (message_callback_buffer.endsWith("\n")) {
                console.log(message_callback_buffer);
                let lines = console_editor.getSession().getLength();
                // Prevent the console editor from hogging memory.
                if (lines > 5000) {
                    console_editor.getSession().removeFullLines(0, 2500);
                    lines = console_editor.getSession().getLength();
                }
                console_editor.moveCursorTo(lines, 0);
                console_editor.scrollToLine(lines);
                console_editor.insert(message_callback_buffer);
                message_callback_buffer = "";
            };
        };

        var interval_id = null;

        var trackScoreTime = function () {
            if (non_csound(csound)) {
                return;
            }
            var score_time = csound.getScoreTime();
            interval_id = setTimeout(trackScoreTime, 200);
            silencio_score.progress3D(score_time);
        };

        var render = async function (is_realtime) {
            $("#score_view").show();
            await generate_score_hook();
            csound = await get_csound(csound_message_callback);
            if (non_csound(csound)) {
                return;
            }
            let AudioContext = window.AudioContext || window.webkitAudioContext;
            let audioContext = new AudioContext();
            analyser = new AnalyserNode(audioContext);
            analyser.fftSize = 2048;
            console.log("Analyzer buffer size: " + analyser.frequencyBinCount);
            // Doesn't work for csound.node, of course!
            // csound.connect(analyser);
            // This too will not work. csound.node running here is not going through WebAudio.
            // Not possible without an audio loopback device, I think.
            // audioContext.destination.connect(analyser);
            csound.setMetadata("artist", "Michael Gogins");
            csound.setMetadata("copyright", "Copyright 2023 by Michael Gogins");
            csound.setMetadata("performer", "Michael Gogins");
            csound.setMetadata("title", document.title);
            csound.setMetadata("album", "Silence");
            csound.setMetadata("track", "1");
            csound.setMetadata("tracknumber", "1");
            csound.setMetadata("date", "2024");
            csound.setMetadata("publisher", "Irreducible Productions ASCAP");
            csound.setMetadata("comment", "Lindenmayer system in chord space.");
            csound.setMetadata("license", "CC BY-NC-SA");
            csound.setMetadata("genre", "Electroacoustic");
            let csd = await document.getElementById('csd').value;
            let csound_score = score.getCsoundScore(12., false);
            csound_score = csound_score.concat("\n</CsScore>");
            csd = csd.replace("</CsScore>", csound_score);
            console_editor.setValue("");
            if (is_realtime == false) {
                csd = csd.replace("-odac", "-o" + document.title + ".wav");
            }
            // Save the .csd file so we can debug a failing orchestra,
            // instead of it just nullifying Csound.        
            const csd_filename = document.title + '-generated.csd';
            write_file(csd_filename, csd);
            let result = await csound.CompileCsdText(csd);
            csound_message_callback("CompileCsdText returned: " + result + "\n");
            await csound.Start();
            // Send _current_ dat.gui parameter values to Csound 
            // before actually performing.
            send_parameters(parameters, csound);
            csound_message_callback("Csound has started...\n");
            if (is_realtime == true) {
                await csound.Perform();
            } else {
                // Actually, returns before finishing because Csound will 
                // perform in a separate thread.
                await csound.performAndPostProcess();
            }
            trackScoreTime();
            csound_message_callback("Csound is playing...\n");
        }

        window.onload = async function () {
            let csound = await get_csound(csound_message_callback);
            if (non_csound(csound)) {
                return;
            }
            csound_message_callback("\n$(window).on(\"load\")...\n");
            create_dat_gui_hook();
            var txt = "\n";
            txt += "Browser CodeName: " + navigator.appCodeName + "\n";
            txt += "Browser Name: " + navigator.appName + "\n";
            txt += "Browser Version: " + navigator.appVersion + "\n";
            txt += "Cookies Enabled: " + navigator.cookieEnabled + "\n";
            txt += "Browser Language: " + navigator.language + "\n";
            txt += "Browser Online: " + navigator.onLine + "\n";
            txt += "Platform: " + navigator.platform + "\n";
            txt += "User-agent header: " + navigator.userAgent + "\n";
            txt += "gl.VENDOR: " + gl.getParameter(gl.VENDOR) + "\n";
            txt += "gl.RENDERER: " + gl.getParameter(gl.RENDERER) + "\n";
            txt += "gl.VERSION: " + gl.getParameter(gl.VERSION) + "\n";
            txt += "gl.SHADING_LANGUAGE_VERSION: " + gl.getParameter(gl.SHADING_LANGUAGE_VERSION) + "\n";
            csound_message_callback(txt);
            $("#strudel_view").css("display", "none");
            $("#score_view").css("display", "none");
            $("#about_view").css("display", "none");
            $("#console_view").css("display", "none");
            $("#menu_item_play").click(async function (event) {
                console.log("menu_item_play click...");
                render(true);
            });
            $("#menu_item_render").click(async function (event) {
                console.log("menu_item_render click...");
                render(false);
            });
            $("#menu_item_stop").click(async function (event) {
                console.log("menu_item_stop click...");
                if (non_csound(csound)) {
                    return;
                }
                await clearInterval(interval_id);
                await csound.Stop();
                await csound.Cleanup();
                csound.Reset();
                csound_message_callback("Csound has stopped.\n");
            });
            $("#menu_item_fullscreen").click(function (event) {
                console.log("menu_item_fullscreen click...");
                const display = document.getElementById("display");
                if (display.requestFullscreen) {
                    display.requestFullscreen();
                } else if (display.webkitRequestFullscreen) {
                    display.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    display.msRequestFullscreen();
                }
            });
            $("#menu_item_strudel").click(function (event) {
                console.log("menu_item_strudel click...");
                $("#about_view").hide();
                $("#console_view").hide();
                $("#scorew_view").hide();
                if ($("#strudel_view").is(":visible")) {
                    $("#strudel_view").hide();
                } else {
                    $("#strudel_view").show();
                }
            });
            $("#menu_item_score").click(function (event) {
                console.log("menu_item_score click...");
                $("#about_view").hide();
                $("#console_view").hide();
                $("#strudel_view").hide();
                if ($("#score_view").is(":visible")) {
                    $("#score_view").hide();
                } else {
                    $("#score_view").show();
                }
            });
            $("#menu_item_console").click(function (event) {
                console.log("menu_item_console click...");
                $("#about_view").hide();
                $("#strudel_view").hide();
                //$("#score_view").hide();
                let v = document.getElementById("console_view");
                if ($("#console_view").is(":visible")) {
                    $("#console_view").hide();
                } else {
                    $("#console_view").show();
                    // Needed to make visible in place.
                    console_editor.resize(true);
                }
            });
            $("#menu_item_about").click(function (event) {
                console.log("menu_item_about click...");
                $("#console_view").hide();
                $("#strudel_view").hide();
                if ($("#about_view").is(":visible")) {
                    $("#about_view").hide();
                } else {
                    $("#about_view").show();
                }
            });
            // Binds the dat.gui 'Save' button to also copy all 
            // current dat.gui control parameters to system clipboard.
            $(".button.save").on("click", function (event) {
                // event.stopPropagation();
                // event.stopImmediatePropagation();
                copy_parameters();
            });
            $(document).keydown(function (event) {
                console.log("document keydown...");
                if (event.keyCode === 'F11') {
                    $("#menu_item_fullscreen").trigger("click");
                }
            });
            $('input').on('input', async function (event) {
                var slider_value = parseFloat(event.target.value);
                if (non_csound(csound) == false) {
                    csound.SetControlChannel(event.target.id, slider_value);
                }
                var output_selector = '#' + event.target.id + '_output';
                $(output_selector).val(slider_value);
            });
            $('#default').on('click', function () {
                let defaults = { "gk_Phaser_ratio2": "1", "gk_ReverbSC_feedback": "0.994", "gk_MasterOutput_level": "-17.329", "gk_Blower_grainDensity": "90", "gk_Blower_grainFrequencyRange": "10", "strudel-settingsfontSize": "18", "gk_Blower_grainAmplitudeRange": "100", "strudel-settingsisLineWrappingEnabled": "false", "gk_ReverbSC_frequency_cutoff": "7260.785", "gk_Droner_partial5": "0.1", "gk_Droner_partial2": "0.05", "gk_Droner_partial3": "0.1", "gi_ReverbSC_delay_modulation": "0.111", "strudel-settingsisLineNumbersDisplayed": "true", "gk_Droner_partial4": "0.2", "gk_Phaser_level": "-22.716", "strudel-settingssoundsFilter": "all", "strudel-settingslatestCode": "stack(\"0,3,[11 6]\"\n  .add(\"<0 1 2 [3 4] 5 7 8>\")\n  .transpose(\"<0 1 2 1>/8\")\n  .slow(7).degradeBy(.125)\n  .transpose(60)\n  .legato(.95)\n  .iter(2)\n  .note()\n  .csoundm(\"1 2\"),\n\"0,4,[7 6]\"\n  .sub(\"<0 1 2 3 4 5 [7 8] 9>\")\n  .transpose(\"<0 1 -1 1>/3\")\n  .iter(4)\n  .slow(7)\n  .transpose(\"<48 36>/7\")\n  .legato(.95)\n  .note()\n  .csoundm(\"2 3\"))\n  .slow(12)\n  //.scale(slowcat('D dorian', 'G mixolydian', 'C dorian', 'F mixolydian')/18)\n  .pianoroll({cycles:120})", "gk_Droner_level": "-32.362", "gk_Phaser_attack": "0.125", "gk_Phaser_release": "0.125", "strudel-settingskeybindings": "codemirror", "strudel-settingsfontFamily": "monospace", "gi_Droner_waveform": "0", "gk_Blower_grainDuration": "0.2005", "strudel-settingsisAutoCompletionEnabled": "false", "strudel-settingsactiveFooter": "intro", "gk_Phaser_index2": "2.481", "gk_Phaser_ratio1": "1.287", "strudel-settingspanelPosition": "bottom", "gk_Droner_partial1": "0.5", "gk_Phaser_index1": "1.502", "strudel-settingstheme": "strudelTheme", "strudel-settingsisZen": "false", "gk_Blower_level": "-13.905" };
                for (let [key, value] of Object.entries(defaults)) {
                    console.log(key, value);
                    // For Web sites, this should probably be true.
                    if (true) {
                        $('.persistent-element').each(function () {
                            localStorage.setItem(key, value);
                        });
                    }
                    if (non_csound(csound) == false) {
                        csound.SetControlChannel(key, parseFloat(value));
                    }
                    let input = '#' + key;
                    $(input).val(value);
                    let output_selector = '#' + key + '_output';
                    $(output_selector).val(value);
                }
                csound_message_callback("Set controls state from defaults.\n");
            });
            // Reset controls to defaults every time the window loads!
            try {
                $("#default")[0].click();
            } catch (ex) {
                console.log(ex);
            }
        };
    </script>

    <!-- endregion -->

</html>