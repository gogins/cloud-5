<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mandelbrot–Julia WebGPU (Fixed Minimal)</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, sans-serif; background:#0b0b0b; color:#ddd; }
    mandelbrot-julia { display:block; height: 70vh; margin: 12px; border: 1px solid #333; border-radius: 10px; overflow: hidden; }
    .bar { margin: 8px 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .bar input { width: 6rem; }
    pre { margin: 8px 12px; padding: 8px; background:#121212; border:1px solid #222; border-radius:8px; max-height: 25vh; overflow:auto; }
  </style>
</head>
<body>

<div class="bar">
  <label>Exponent p: <input id="expP" type="number" step="0.01" value="2.0"></label>
  <label>MaxIter M: <input id="iterM" type="number" value="500"></label>
  <label>MaxIter J: <input id="iterJ" type="number" value="1000"></label>
  <label>N time: <input id="binsN" type="number" value="512"></label>
  <label>M pitch: <input id="binsM" type="number" value="48"></label>
  <label>K inst: <input id="binsK" type="number" value="4"></label>
  <button id="btnScore">Make Score (Alt+S)</button>
<span>
  Click Mandelbrot = set Julia point •
  Option-Click = zoom in & center •
  Shift+Option-Click = zoom out & center •
  Drag on Julia = select ROI •
  Alt+S = Make Score
</span>
</div>

<mandelbrot-julia></mandelbrot-julia>

<pre id="log">score will print here…</pre>

<script type="module">
class MandelbrotJulia extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({mode:'open'});
    const root = document.createElement('div');
    root.style.cssText = `
      width:100%; height:100%;
      display:grid; grid-template-columns: 1fr 1fr; gap:0; position:relative;
      background:#000;
    `;
    this.canvasM = document.createElement('canvas');
    this.canvasJ = document.createElement('canvas');
    Object.assign(this.canvasM.style, {width:'100%',height:'100%'});
    Object.assign(this.canvasJ.style, {width:'100%',height:'100%'});
    this.sel = document.createElement('div');
    this.sel.style.cssText = `position:absolute; border:1px dashed #9cf; pointer-events:none; display:none; background: rgba(100,150,255,0.15);`;
    root.appendChild(this.canvasM);
    root.appendChild(this.canvasJ);
    root.appendChild(this.sel);
    this.shadowRoot.appendChild(root);

    // Defaults
    this.nTime = 512;
    this.nPitch = 48;
    this.nInst = 4;
    this.maxIterM = 500;
    this.maxIterJ = 1000;
    this.exponent = 2.0;

    this.viewM = { cx:-0.5, cy:0.0, scale:2.5 };
    this.viewJ = { cx:0.0,  cy:0.0, scale:1.5 };
    this.c = { x:-0.8, y:0.156 };
    this.roiJ = null;

    this._resizeObserver = new ResizeObserver(()=> this.resize());
  }

  async connectedCallback() {
    if (!('gpu' in navigator)) {
      this.shadowRoot.innerHTML = `<div style="padding:1rem;color:#f88">WebGPU not available. Use Chrome/Edge with WebGPU enabled.</div>`;
      return;
    }
    this._resizeObserver.observe(this);
    await this.initGPU();
    this.initPipelines();
    this.initInteractions();
    this.resize();
    this.render();
  }
  disconnectedCallback(){ this._resizeObserver.disconnect(); }

  async initGPU() {
    this.adapter = await navigator.gpu.requestAdapter();
    this.device  = await this.adapter.requestDevice();
    const format = navigator.gpu.getPreferredCanvasFormat();
    this.ctxM = this.canvasM.getContext('webgpu');
    this.ctxJ = this.canvasJ.getContext('webgpu');
    this.ctxM.configure({ device:this.device, format, alphaMode:'premultiplied' });
    this.ctxJ.configure({ device:this.device, format, alphaMode:'premultiplied' });
    this.format = format;

    // Two separate uniform buffers (one per pass)
    this.uniformSize = 256;
    this.uniformBufM = this.device.createBuffer({
      size: this.uniformSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.uniformBufJ = this.device.createBuffer({
      size: this.uniformSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // Compute uniforms buffer
    this.csUniformSize = 256;
    this.csUniformBuf  = this.device.createBuffer({
      size: this.csUniformSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    // BGLs
    this.drawBGL = this.device.createBindGroupLayout({
      entries: [{ binding:0, visibility: GPUShaderStage.FRAGMENT, buffer:{type:'uniform'} }]
    });
    this.csBGL0 = this.device.createBindGroupLayout({
      entries: [{ binding:0, visibility: GPUShaderStage.COMPUTE,  buffer:{type:'uniform'} }]
    });
    this.csBGL1 = this.device.createBindGroupLayout({
      entries: [{ binding:1, visibility: GPUShaderStage.COMPUTE,  buffer:{type:'storage'} }]
    });
  }

  initPipelines() {
    const vsWGSL = /*wgsl*/`
      @vertex
      fn main(@builtin(vertex_index) vid: u32) -> @builtin(position) vec4<f32> {
        var pos = array<vec2<f32>,3>(
          vec2<f32>(-1.0, -3.0),
          vec2<f32>( 3.0,  1.0),
          vec2<f32>(-1.0,  1.0)
        );
        let p = pos[vid];
        return vec4<f32>(p, 0.0, 1.0);
      }
    `;

    const fsWGSL = /*wgsl*/`
struct DrawUniforms {
  a: vec4<f32>,  // center.xy, scale, p
  b: vec4<f32>,  // cParam.xy, viewport.xy
  c: vec4<f32>,  // maxIter, mode, aspect, 0
};
@group(0) @binding(0) var<uniform> U : DrawUniforms;

// ----- complex helpers -----
fn clog(z: vec2<f32>) -> vec2<f32> {
  let r = length(z);
  let th = atan2(z.y, z.x);
  return vec2<f32>(log(max(r, 1e-30)), th);
}
fn cexp(w: vec2<f32>) -> vec2<f32> {
  let a = exp(w.x);
  return vec2<f32>(a * cos(w.y), a * sin(w.y));
}
fn cpow(z: vec2<f32>, p: f32) -> vec2<f32> {
  // protect z=0 from log()
  let zsafe = select(z, vec2<f32>(1e-30, 0.0), all(z == vec2<f32>(0.0,0.0)));
  let w = clog(zsafe) * vec2<f32>(p, p);
  return cexp(w);
}

// ----- palettes -----
fn hsv2rgb(h: f32, s: f32, v: f32) -> vec3<f32> {
  let h6 = h * 6.0;
  let i_u = u32(floor(h6));
  let f   = h6 - floor(h6);
  let p = v * (1.0 - s);
  let q = v * (1.0 - s * f);
  let t = v * (1.0 - s * (1.0 - f));
  var rgb: vec3<f32>;
  if (i_u == 0u)      { rgb = vec3<f32>(v, t, p); }
  else if (i_u == 1u) { rgb = vec3<f32>(q, v, p); }
  else if (i_u == 2u) { rgb = vec3<f32>(p, v, t); }
  else if (i_u == 3u) { rgb = vec3<f32>(p, q, v); }
  else if (i_u == 4u) { rgb = vec3<f32>(t, p, v); }
  else                { rgb = vec3<f32>(v, p, q); }
  return rgb;
}
fn palette(t: f32) -> vec3<f32> {
  let pi = 3.141592653589793;
  let a  = vec3<f32>(0.5, 0.5, 0.5);
  let b  = vec3<f32>(0.5, 0.5, 0.5);
  let c  = vec3<f32>(1.0, 1.0, 1.0);
  let d  = vec3<f32>(0.00, 0.33, 0.67);
  return a + b * cos(2.0 * pi * (c * t + d));
}

@fragment
fn main(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
  // uniforms
  let center   = U.a.xy;
  let scale    = U.a.z;
  let p        = U.a.w;
  let cParam   = U.b.xy;
  let viewport = U.b.zw;
  let maxIter  = u32(U.c.x);
  let mode     = u32(U.c.y);
  let aspect   = U.c.z;

  // screen -> complex
  let ndc = (pos.xy / viewport) * 2.0 - vec2<f32>(1.0,1.0);
  var z = vec2<f32>(
    center.x + ndc.x * scale,
    center.y - ndc.y * scale / aspect
  );

  var c = vec2<f32>(0.0, 0.0);
  if (mode == 0u) {
    c = z; z = vec2<f32>(0.0, 0.0);   // Mandelbrot
  } else {
    c = cParam;                        // Julia
  }

  // iterate
  var n: u32 = 0u;
  let R = 4.0;
  loop {
    if (n >= maxIter) { break; }
    z = cpow(z, p) + c;
    if (dot(z,z) > R*R) { break; }
    n = n + 1u;
  }

  // interior: pure black
  if (n >= maxIter) {
    return vec4<f32>(0.0, 0.0, 0.0, 1.0);
  }

  // smooth iteration in [0,1]
  let r = length(z);
  let smooth_ = (f32(n) + 1.0
                 - log(max(log(max(r, 1e-30)), 1e-30)) / log(max(p, 1.0001)))
                / f32(maxIter);
  let t = clamp(pow(smooth_, 0.85), 0.0, 1.0);

  if (mode == 1u) {
    // JULIA palette:
    // - very fast escape -> black (narrow)
    // - middle -> rainbow
    // - boundary -> white
    let fadeIn = clamp((t - 0.01) / 0.05, 0.0, 1.0);          // limits “all black”
    let hue = t - floor(t);                                   // fract(t)
    let rainbow = hsv2rgb(hue, 1.0, 1.0);
    let toWhite = clamp((t - 0.90) / 0.08, 0.0, 1.0);
    let withWhite = mix(rainbow, vec3<f32>(1.0,1.0,1.0), toWhite);
    let col = withWhite * fadeIn;
    return vec4<f32>(col, 1.0);
  }

  // MANDELBROT: keep prior palette
  let col = palette(t);
  return vec4<f32>(col, 1.0);
}
`;

    const csWGSL = /*wgsl*/`
struct CsUniforms {
  // u0: cParam.xy, roiMin.xy
  u0: vec4<f32>,
  // u1: roiMax.xy, p, maxIter (as float)
  u1: vec4<f32>,
  // u2: N, M, K, ton
  u2: vec4<f32>,
  // u3: gamma, unused, unused, unused
  u3: vec4<f32>,
};
@group(0) @binding(0) var<uniform> U : CsUniforms;

struct Cell { v: u32, };
@group(1) @binding(1) var<storage, read_write> GRID : array<Cell>;

fn clog(z: vec2<f32>) -> vec2<f32> {
  let r = length(z);
  let th = atan2(z.y, z.x);
  return vec2<f32>(log(max(r, 1e-30)), th);
}
fn cexp(w: vec2<f32>) -> vec2<f32> {
  let a = exp(w.x);
  return vec2<f32>(a * cos(w.y), a * sin(w.y));
}
fn cpow(z: vec2<f32>, p: f32) -> vec2<f32> {
  let w = clog(z) * vec2<f32>(p, p);
  return cexp(w);
}

@compute @workgroup_size(8,8,1)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let N = u32(U.u2.x);
  let M = u32(U.u2.y);
  let K = u32(U.u2.z);
  if (gid.x >= N || gid.y >= M) { return; }

  let cParam = U.u0.xy;
  let roiMin = U.u0.zw;
  let roiMax = U.u1.xy;
  let p      = U.u1.z;
  let maxIter= u32(U.u1.w);
  let ton    = U.u2.w;
  let gamma  = U.u3.x;

  let tx = (f32(gid.x) + 0.5) / f32(N);
  let ty = (f32(gid.y) + 0.5) / f32(M);
  let z0 = vec2<f32>(
    mix(roiMin.x, roiMax.x, tx),
    mix(roiMax.y, roiMin.y, ty) // top=high
  );

  var z = z0;
  var th_prev = atan2(z.y, z.x);
  var sumTh = 0.0;

  var n: u32 = 0u;
  let R = 4.0;
  loop {
    if (n >= maxIter) { break; }
    let zsafe = select(z, vec2<f32>(1e-30, 0.0), all(z == vec2<f32>(0.0,0.0)));
    let zp = cpow(zsafe, p) + cParam;
    let th = atan2(zp.y, zp.x);
    var dth = th - th_prev;
    if (dth >  3.14159265) { dth -= 6.2831853; }
    if (dth < -3.14159265) { dth += 6.2831853; }
    sumTh += dth;
    z = zp;
    n = n + 1u;
    if (dot(z,z) > R*R) { break; }
    th_prev = th;
  }

  var tvel = 1.0;
  if (n < maxIter) {
    let r = length(z);
    tvel = clamp(
      (f32(n) + 1.0 - log(max(log(max(r, 1e-30)), 1e-30)) / log(max(p, 1.0001)))
      / f32(maxIter), 0.0, 1.0);
  }
  let vel = u32(clamp(1.0 + 126.0 * pow(tvel, gamma), 1.0, 127.0));
  let on  = select(0u, 1u, tvel >= ton);

  let tRot = fract(sumTh / 6.2831853);
  let inst = u32(min(floor(tRot * f32(K)), f32(K - 1u)));

  let packed = (on & 0xffu) | ((vel & 0xffu) << 8u) | ((inst & 0xffu) << 16u);
  let idx = gid.x * M + gid.y;
  GRID[idx].v = packed;
}
    `;

    this.shaderVS = this.device.createShaderModule({ code: vsWGSL });
    this.shaderFS = this.device.createShaderModule({ code: fsWGSL });
    this.shaderCS = this.device.createShaderModule({ code: csWGSL });

    this.pipeline = this.device.createRenderPipeline({
      layout: this.device.createPipelineLayout({ bindGroupLayouts: [this.drawBGL] }),
      vertex: { module: this.shaderVS, entryPoint:'main' },
      fragment:{ module: this.shaderFS, entryPoint:'main', targets:[{ format:this.format }] },
      primitive:{ topology:'triangle-list' }
    });

    // Two draw bind groups (one per canvas)
    this.drawBindGroupM = this.device.createBindGroup({
      layout: this.drawBGL,
      entries: [{ binding:0, resource:{ buffer:this.uniformBufM }}]
    });
    this.drawBindGroupJ = this.device.createBindGroup({
      layout: this.drawBGL,
      entries: [{ binding:0, resource:{ buffer:this.uniformBufJ }}]
    });

    this.csPipeline = this.device.createComputePipeline({
      layout: this.device.createPipelineLayout({ bindGroupLayouts:[ this.csBGL0, this.csBGL1 ] }),
      compute: { module: this.shaderCS, entryPoint:'main' }
    });
  }

  // ------- uniforms writers (vec4-only) -------
  writeDrawUniforms({mode, canvas, center, scale, maxIter, cParam, targetBuffer}) {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    const aspect = w / Math.max(1,h);

    // a: center.xy, scale, p
    // b: cParam.xy, viewport.xy
    // c: maxIter, mode, aspect, 0
    const f = new Float32Array(12);
    f[0]=center.cx; f[1]=center.cy; f[2]=scale;      f[3]=this.exponent;
    f[4]=cParam?.x ?? 0; f[5]=cParam?.y ?? 0; f[6]=w; f[7]=h;
    f[8]=maxIter; f[9]=mode; f[10]=aspect; f[11]=0;

    this.device.queue.writeBuffer(targetBuffer, 0, f.buffer);
    return {w,h};
  }

  writeComputeUniforms(roi, N, M, K) {
    // u0: cParam.xy, roiMin.xy
    // u1: roiMax.xy, p, maxIter
    // u2: N, M, K, ton
    // u3: gamma, 0, 0, 0
    const ton = 0.2, gamma = 0.9;
    const f = new Float32Array(16);
    f[0]=this.c.x; f[1]=this.c.y; f[2]=roi.minx; f[3]=roi.miny;
    f[4]=roi.maxx; f[5]=roi.maxy; f[6]=this.exponent; f[7]=this.maxIterJ;
    f[8]=N; f[9]=M; f[10]=K; f[11]=ton;
    f[12]=gamma; f[13]=0; f[14]=0; f[15]=0;
    this.device.queue.writeBuffer(this.csUniformBuf, 0, f.buffer);
  }

  resize() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    for (const c of [this.canvasM, this.canvasJ]) {
      const w = Math.floor(c.clientWidth * dpr), h = Math.floor(c.clientHeight * dpr);
      if (w && h && (c.width !== w || c.height !== h)) { c.width = w; c.height = h; }
    }
  }

  render() {
    const enc = this.device.createCommandEncoder();

    // Mandelbrot
    this.writeDrawUniforms({
      mode:0, canvas:this.canvasM,
      center:this.viewM, scale:this.viewM.scale,
      maxIter:this.maxIterM, cParam:null, targetBuffer:this.uniformBufM
    });
    const passM = enc.beginRenderPass({
      colorAttachments:[{ view:this.ctxM.getCurrentTexture().createView(),
        loadOp:'clear', storeOp:'store', clearValue:{r:0,g:0,b:0,a:1}}]
    });
    passM.setPipeline(this.pipeline);
    passM.setBindGroup(0, this.drawBindGroupM);
    passM.draw(3,1,0,0);
    passM.end();

    // Julia
    this.writeDrawUniforms({
      mode:1, canvas:this.canvasJ,
      center:this.viewJ, scale:this.viewJ.scale,
      maxIter:this.maxIterJ, cParam:this.c, targetBuffer:this.uniformBufJ
    });
    const passJ = enc.beginRenderPass({
      colorAttachments:[{ view:this.ctxJ.getCurrentTexture().createView(),
        loadOp:'clear', storeOp:'store', clearValue:{r:0,g:0,b:0,a:1}}]
    });
    passJ.setPipeline(this.pipeline);
    passJ.setBindGroup(0, this.drawBindGroupJ);
    passJ.draw(3,1,0,0);
    passJ.end();

    this.device.queue.submit([enc.finish()]);
    requestAnimationFrame(()=>this.render());
  }

  initInteractions() {
  const pIn  = document.getElementById('expP');
  const mIn  = document.getElementById('iterM');
  const jIn  = document.getElementById('iterJ');
  const nIn  = document.getElementById('binsN');
  const MIn  = document.getElementById('binsM');
  const kIn  = document.getElementById('binsK');
  const btnS = document.getElementById('btnScore');

  const clampZoom = () => {
    this.viewM.scale = Math.max(1e-6, Math.min(1000, this.viewM.scale));
    this.viewJ.scale = Math.max(1e-6, Math.min(1000, this.viewJ.scale));
  };

  const sync = () => {
    this.exponent = Math.max(1.0001, parseFloat(pIn.value) || 2.0);
    this.maxIterM = parseInt(mIn.value);
    this.maxIterJ = parseInt(jIn.value);
    this.nTime    = parseInt(nIn.value);
    this.nPitch   = parseInt(MIn.value);
    this.nInst    = parseInt(kIn.value);
    clampZoom();
  };
  [pIn,mIn,jIn,nIn,MIn,kIn].forEach(e=>e.addEventListener('change', sync));
  sync();

  // --- Mandelbrot interactions ---
  this.canvasM.addEventListener('click', (e)=>{
    const { altKey, shiftKey } = e; // Alt=Option on macOS
    const dpr  = Math.max(1, window.devicePixelRatio || 1);
    const rect = this.canvasM.getBoundingClientRect();
    const x = (e.clientX - rect.left) * dpr;
    const y = (e.clientY - rect.top ) * dpr;
    const w = this.canvasM.width, h = this.canvasM.height;
    const ndc = { x: x / w * 2 - 1, y: y / h * 2 - 1 };
    const aspect = w / Math.max(1,h);

    // Complex coord at click
    const zx = this.viewM.cx + ndc.x * this.viewM.scale;
    const zy = this.viewM.cy - ndc.y * this.viewM.scale / aspect;

    // Always set c so Julia updates for this point
    this.c = { x: zx, y: zy };

    // Zoom behavior per spec
    if (altKey && shiftKey) {
      // Shift+Option: zoom OUT and center on clicked point
      this.viewM.cx = zx; this.viewM.cy = zy;
      this.viewM.scale *= 1.5;
    } else if (altKey) {
      // Option: zoom IN and center on clicked point
      this.viewM.cx = zx; this.viewM.cy = zy;
      this.viewM.scale *= 0.6667;
    } else {
      // Plain click: just update Julia's parameter; no zoom on Mandelbrot
    }

    // Keep Julia view centered; parameter c moved already
    this.viewJ.cx = 0.0;
    this.viewJ.cy = 0.0;
  });

  // --- Julia interactions: drag-to-select ROI ---
  let dragging = false;
  let startPx = {x:0, y:0};
  let curPx   = {x:0, y:0};
  const root = this.shadowRoot.querySelector('div'); // grid root for overlay positioning

  const beginDrag = (e) => {
    if (e.button !== 0) return; // left button only
    dragging = true;
    const rJ   = this.canvasJ.getBoundingClientRect();
    startPx.x  = e.clientX;
    startPx.y  = e.clientY;
    curPx.x    = e.clientX;
    curPx.y    = e.clientY;

    // Show selection overlay anchored to Julia canvas
    this.sel.style.display = 'block';
    this._placeSelRect(rJ, startPx, curPx);
    e.preventDefault();
  };
  const moveDrag = (e) => {
    if (!dragging) return;
    const rJ = this.canvasJ.getBoundingClientRect();
    curPx.x = Math.min(Math.max(e.clientX, rJ.left), rJ.right);
    curPx.y = Math.min(Math.max(e.clientY, rJ.top ), rJ.bottom);
    this._placeSelRect(rJ, startPx, curPx);
  };
  const endDrag = (e) => {
    if (!dragging) return;
    dragging = false;
    const rJ  = this.canvasJ.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // Pixel coords relative to Julia canvas
    const x0 = (Math.min(startPx.x, curPx.x) - rJ.left) * dpr;
    const y0 = (Math.min(startPx.y, curPx.y) - rJ.top ) * dpr;
    const x1 = (Math.max(startPx.x, curPx.x) - rJ.left) * dpr;
    const y1 = (Math.max(startPx.y, curPx.y) - rJ.top ) * dpr;

    if (Math.abs(x1 - x0) < 3 || Math.abs(y1 - y0) < 3) {
      return;
    }

    // Convert pixel box -> complex plane box used by Julia shader
    const w = this.canvasJ.width, h = this.canvasJ.height;
    const aspect = w / Math.max(1,h);

    const toComplex = (px, py) => {
      const ndcX = px / w * 2 - 1;
      const ndcY = py / h * 2 - 1;
      return {
        x: this.viewJ.cx + ndcX * this.viewJ.scale,
        y: this.viewJ.cy - ndcY * this.viewJ.scale / aspect
      };
    };

    const zA = toComplex(x0, y0);
    const zB = toComplex(x1, y1);
    this.roiJ = {
      minx: Math.min(zA.x, zB.x),
      maxx: Math.max(zA.x, zB.x),
      miny: Math.min(zA.y, zB.y),
      maxy: Math.max(zA.y, zB.y),
    };
  };

  this.canvasJ.addEventListener('mousedown', beginDrag);
  window.addEventListener('mousemove', moveDrag);
  window.addEventListener('mouseup',   endDrag);

  // --- Score hotkey/button ---
window.addEventListener('keydown', (e)=>{
  const key = e.key.toLowerCase();
  if ((key === 's') && (e.altKey || e.metaKey)) { e.preventDefault(); this.makeScore(); }
  if ((key === 'r') && (e.altKey || e.metaKey)) {
    e.preventDefault();
    this.roiJ = null;
    this.sel.style.display = 'none';   // hide the rectangle
  }
});

  btnS.addEventListener('click', ()=> this.makeScore());
}

// Helper: position selection rectangle overlay within the grid root
_placeSelRect(rJ, startPx, curPx) {
  const rRoot = this.shadowRoot.querySelector('div').getBoundingClientRect();
  const left  = Math.min(startPx.x, curPx.x) - rRoot.left;
  const top   = Math.min(startPx.y, curPx.y) - rRoot.top;
  const width = Math.abs(curPx.x - startPx.x);
  const height= Math.abs(curPx.y - startPx.y);

  // Clamp overlay to Julia canvas bounds
  const jl = rJ.left - rRoot.left, jt = rJ.top - rRoot.top;
  const jr = rJ.right - rRoot.left, jb = rJ.bottom - rRoot.top;
  const L = Math.max(left, jl);
  const T = Math.max(top,  jt);
  const R = Math.min(left + width,  jr);
  const B = Math.min(top  + height, jb);

  Object.assign(this.sel.style, {
    left:   `${L}px`,
    top:    `${T}px`,
    width:  `${Math.max(0, R - L)}px`,
    height: `${Math.max(0, B - T)}px`,
  });
}



  async makeScore() {
    const N = this.nTime, M = this.nPitch, K = this.nInst;
    const roi = this.roiJ ?? {
      minx: this.viewJ.cx - this.viewJ.scale,
      maxx: this.viewJ.cx + this.viewJ.scale,
      miny: this.viewJ.cy - this.viewJ.scale,
      maxy: this.viewJ.cy + this.viewJ.scale
    };
    this.writeComputeUniforms(roi, N, M, K);

    // Output grid (u32 per cell)
    const gridSize = N * M * 4;
    const grid = this.device.createBuffer({ size:gridSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC });
    const csBG0 = this.device.createBindGroup({ layout:this.csBGL0, entries:[{binding:0, resource:{buffer:this.csUniformBuf}}] });
    const csBG1 = this.device.createBindGroup({ layout:this.csBGL1, entries:[{binding:1, resource:{buffer:grid}}] });

    const enc = this.device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(this.csPipeline);
    pass.setBindGroup(0, csBG0);
    pass.setBindGroup(1, csBG1);
    pass.dispatchWorkgroups(Math.ceil(N/8), Math.ceil(M/8), 1);
    pass.end();

    const readBuf = this.device.createBuffer({ size:gridSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
    enc.copyBufferToBuffer(grid, 0, readBuf, 0, gridSize);
    this.device.queue.submit([enc.finish()]);
    await readBuf.mapAsync(GPUMapMode.READ);
    const u32grid = new Uint32Array(readBuf.getMappedRange().slice(0));
    readBuf.unmap();

    // Assemble notes
    const dt = (60/120) * (1/8); // 32nd at MM=120
    const pmin = 36;
    const active = Array.from({length:N}, _=> new Uint8Array(M));
    const vel    = Array.from({length:N}, _=> new Uint8Array(M));
    const inst   = Array.from({length:N}, _=> new Uint8Array(M));
    for (let i=0;i<N;i++){
      for (let j=0;j<M;j++){
        const v = u32grid[i*M + j];
        active[i][j] = v & 0xFF;
        vel[i][j]    = (v >>> 8) & 0xFF;
        inst[i][j]   = (v >>> 16) & 0xFF;
      }
    }

    const runOn   = Array.from({length:M}, _=> Array(K).fill(false));
    const runI0   = Array.from({length:M}, _=> Array(K).fill(0));
    const runVmax = Array.from({length:M}, _=> Array(K).fill(0));
    const score = [];

    for (let i=0;i<=N;i++){
      for (let j=0;j<M;j++){
        const on = (i<N)? active[i][j] : 0;
        const vv = (i<N)? vel[i][j]    : 0;
        const kk = (i<N)? inst[i][j]   : 0;

        for (let k=0;k<K;k++){
          if (runOn[j][k] && (i===N || k!==kk || !on)){
            const i0 = runI0[j][k], i1 = i-1;
            score.push([k, i0*dt, (i1-i0+1)*dt, pmin+j, runVmax[j][k]]);
            runOn[j][k] = false;
          }
        }
        if (i<N && on){
          if (!runOn[j][kk]){ runOn[j][kk]=true; runI0[j][kk]=i; runVmax[j][kk]=vv; }
          else { runVmax[j][kk] = Math.max(runVmax[j][kk], vv); }
        }
      }
    }

    const log = document.getElementById('log');
    log.textContent = `Score notes: ${score.length}\n` +
      score.slice(0,32).map(n=>JSON.stringify(n)).join('\n') +
      (score.length>32? `\n… (${score.length-32} more)` : '');
    console.log('SCORE [instrument, time, duration, key, velocity]:', score);
  }
}

customElements.define('mandelbrot-julia', MandelbrotJulia);

// Wire UI
const el = document.querySelector('mandelbrot-julia');
const ids = ['expP','iterM','iterJ','binsN','binsM','binsK'];
const els = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
function sync(){
  el.exponent = Math.max(1.0001, parseFloat(els.expP.value) || 2.0);
  el.maxIterM = parseInt(els.iterM.value);
  el.maxIterJ = parseInt(els.iterJ.value);
  el.nTime    = parseInt(els.binsN.value);
  el.nPitch   = parseInt(els.binsM.value);
  el.nInst    = parseInt(els.binsK.value);
}
ids.forEach(id=> els[id].addEventListener('change', sync));
sync();
</script>

</body>
</html>
